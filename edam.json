 [{"package":"abacas","distribution":"debian","release":"sid","component":"main","version":"1.3.1","source":"abacas","homepage":"http://abacas.sourceforge.net/","description":"close gaps in genomic alignments from short reads","long_description":" ABACAS (Algorithm Based Automatic Contiguation of Assembled Sequences)\n intends to rapidly contiguate (align, order, orientate), visualize and\n design primers to close gaps on shotgun assembled contigs based on a\n reference sequence.\n .\n ABACAS uses MUMmer to find alignment positions and identify syntenies\n of assembled contigs against the reference. The output is then processed\n to generate a pseudomolecule taking overlapping contigs and gaps in to\n account. ABACAS generates a comparison file that can be used to\n visualize ordered and oriented contigs in ACT. Synteny is represented by\n red bars where colour intensity decreases with lower values of percent\n identity between comparable blocks. Information on contigs such as the\n orientation, percent identity, coverage and overlap with other contigs\n can also be visualized by loading the outputted feature file on ACT.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 4 / 90","doi":"10.1093/bioinformatics/btp347","topics":["Probes and primers"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Sequence", "formats": ["FASTA"]}], "outputs": [{"data": "Sequence", "formats": ["FASTA"]}], "function": ["PCR primer design"]}],"bio.agents":null,"OMICagents":"OMICS_06933","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"abyss","distribution":"debian","release":"sid","component":"main","version":"2.1.5","source":"abyss","homepage":"http://www.bcgsc.ca/platform/bioinfo/software/abyss","description":"de novo, parallel, sequence assembler for short reads","long_description":" ABySS is a de novo, parallel, sequence assembler that is designed for\n short reads. It may be used to assemble genome or transcriptome\n sequence data. Parallelization is achieved using MPI, OpenMP and\n pthread.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 19 / 82","doi":"10.1101/gr.089532.108","topics":null,"edam_scopes":null,"bio.agents":"ABySS","OMICagents":"OMICS_00006","SEQwiki":null,"SciCrunch":{"source":"abyss","name":"SciCrunch","entry":"SCR_010709"},"RRID":null},{"package":"acacia","distribution":"prospective","release":"vcs","component":"main","version":"1.53","source":"acacia","homepage":"http://sourceforge.net/projects/acaciaerrorcorr/","description":"Error-corrector for pyrosequenced amplicon reads.","long_description":" Acacia is a java program developed to quickly and conservatively correct\n errors, whilst simultaneously de-replicating, amplicon sequences.\n .\n The main purpose of Acacia is to correct the over-call, under-call errors\n prevalent in Roche 454 GS-FLX data, and more recently, with the Titanium\n chemistry.\n Acacia will only ectively correct errors in amplicons - as it assumes that\n the 5' end of the sequences start at the same position, the MID, followed by\n the primer.\n Acacia uses empirically-derived models to identify homopolymer\n regions where there are more `errors' than expected by chance - these imply\n that the differences are due to population differences rather than\n error-induced polymorphisms.\n .\n Nat Methods. 2012 Apr 27;9(5):425-6. doi: 10.1038/nmeth.1990.\n Fast, accurate error-correction of amplicon pyrosequences using Acacia.\n Bragg L, Stone G, Imelfort M, Hugenholtz P, Tyson GW.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1038/nmeth.1990","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_01116","SEQwiki":null,"SciCrunch":{"source":"acacia","name":"SciCrunch","entry":"SCR_012896"},"RRID":null},{"package":"acedb-other","distribution":"debian","release":"sid","component":"main","version":"4.9.39","source":"acedb","homepage":"http://www.acedb.org/","description":"retrieval of DNA or protein sequences","long_description":" This package collects all those smallish applications that acedb collects\n under its 'other' target of its Makefile.\n .\n efetch: presumably short for 'entry fetch' collects sequence information\n from common DNA and protein databases.\n","interface":null,"biology":["nuceleic-acids"],"fields":["biology","biology:bioinformatics"],"use":null,"popcon":"3 / 3 / 89","doi":"10.1109/5992.764215","topics":null,"edam_scopes":null,"bio.agents":"dotter","OMICagents":"OMICS_15828","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"adapterremoval","distribution":"debian","release":"sid","component":"main","version":"2.2.4","source":"adapterremoval","homepage":"https://github.com/MikkelSchubert/adapterremoval","description":"rapid adapter trimming, identification, and read merging of gene sequences","long_description":" This program searches for and removes remnant adapter sequences from High-\n Throughput Sequencing (HTS) data and (optionally) trims low quality\n bases from the 3' end of reads following adapter removal. AdapterRemoval\n can analyze both single end and paired end data, and can be used to\n merge overlapping paired-ended reads into (longer) consensus sequences.\n Additionally, the AdapterRemoval may be used to recover a consensus\n adapter sequence for paired-ended data, for which this information is\n not available.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 16 / 62","doi":"10.1186/s13104-016-1900-2","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_01081","SEQwiki":null,"SciCrunch":{"source":"adapterremoval","name":"SciCrunch","entry":"SCR_011834"},"RRID":null},{"package":"adun.app","distribution":"debian","release":"sid","component":"main","version":"0.81","source":"adun.app","homepage":"http://wiki.gnustep.org/index.php/Adun","description":"Molecular Simulator for GNUstep (GUI)","long_description":" Adun is a biomolecular simulator that also includes data management and\n analysis capabilities.  It was developed at the Computational Biophysics\n and Biochemistry Laboratory, a part of the Research Unit on Biomedical\n Informatics of the UPF.\n .\n This package contains UL, the Adun GUI frontend.\n","interface":["x11"],"biology":null,"fields":["biology","biology:structural"],"use":["TODO","analysing","organizing","viewing"],"popcon":"10 / 5 / 220","doi":"10.1002/jcc.20312","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_19722","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"adun-core","distribution":"debian","release":"sid","component":"main","version":"0.81","source":"adun.app","homepage":"http://wiki.gnustep.org/index.php/Adun","description":"Molecular Simulator","long_description":" Adun is a biomolecular simulator that also includes data management and\n analysis capabilities.  It was developed at the Computational Biophysics\n and Biochemistry Laboratory, a part of the Research Unit on Biomedical\n Informatics of the UPF.\n .\n This package contains the AdunCore program and the Adun server.  If\n you want the graphical UI frontend, install the adun.app package.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"11 / 11 / 118","doi":"10.1002/jcc.20312","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_19722","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"aegean","distribution":"debian","release":"sid","component":"main","version":"0.16.0","source":"aegean","homepage":"http://standage.github.io/AEGeAn","description":"integrated genome analysis agentkit","long_description":" The AEGeAn Agentkit is designed for the Analysis and Evaluation of Genome\n Annotations. The agentkit includes a variety of analysis programs, e.g. for\n comparing distinct sets of gene structure annotations (ParsEval), computation\n of gene loci (LocusPocus) and more.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 3 / 64","doi":"10.1186/1471-2105-13-187","topics":["Sequencing"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Sequence features", "formats": ["GFF3"]}], "outputs": [{"data": "Sequence features", "formats": ["GFF3"]}, {"data": "Report", "formats": ["Textual format"]}], "function": ["Genome feature comparison", "Sequence file editing"]}],"bio.agents":null,"OMICagents":"OMICS_19721","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"aevol","distribution":"debian","release":"sid","component":"main","version":"5.0","source":"aevol","homepage":"http://www.aevol.fr/","description":"digital genetics model to run Evolution Experiments in silico","long_description":" Aevol is a digital genetics model: populations of digital organisms are\n subjected to a process of selection and variation, which creates a\n Darwinian dynamics.\n .\n By modifying the characteristics of selection (e.g. population size,\n type of environment, environmental variations) or variation (e.g.\n mutation rates, chromosomal rearrangement rates, types of\n rearrangements, horizontal transfer), one can study experimentally the\n impact of these parameters on the structure of the evolved organisms.\n In particular, since Aevol integrates a precise and realistic model of\n the genome, it allows for the study of structural variations of the\n genome (e.g. number of genes, synteny, proportion of coding sequences).\n .\n The simulation platform comes along with a set of agents for analysing\n phylogenies and measuring many characteristics of the organisms and\n populations along evolution.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"10 / 4 / 117","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_19719","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"alien-hunter","distribution":"debian","release":"sid","component":"main","version":"1.7","source":"alien-hunter","homepage":"http://www.sanger.ac.uk/science/agents/alien-hunter","description":"Interpolated Variable Order Motifs to identify horizontally acquired DNA","long_description":" Alien_hunter is an application for the prediction of putative\n Horizontal Gene Transfer (HGT) events with the implementation of\n Interpolated Variable Order Motifs (IVOMs). An IVOM approach\n exploits compositional biases using variable order motif distributions\n and captures more reliably the local composition of a sequence compared\n to fixed-order methods. Optionally the predictions can be parsed into a\n 2-state 2nd order Hidden Markov Model (HMM), in a change-point detection\n framework, to optimize the localization of the boundaries of the\n predicted regions. The predictions (embl format) can be automatically\n loaded into Artemis genome viewer freely available at:\n http://www.sanger.ac.uk/Software/Artemis/.\n","interface":null,"biology":null,"fields":["biology","biology:structural"],"use":["analysing"],"popcon":"9 / 3 / 85","doi":"10.1093/bioinformatics/btl369","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_08280","SEQwiki":null,"SciCrunch":{"source":"alien-hunter","name":"SciCrunch","entry":"SCR_015967"},"RRID":null},{"package":"alter-sequence-alignment","distribution":"debian","release":"sid","component":"main","version":"1.3.4","source":"alter-sequence-alignment","homepage":"http://sing.ei.uvigo.es/ALTER/","description":"genomic sequences ALignment Transformation EnviRonment","long_description":" ALTER (ALignment Transformation EnviRonment) is a agent to transform\n between multiple sequence alignment formats. ALTER focuses on the\n specifications of mainstream alignment and analysis programs rather than\n on the conversion among more or less specific formats.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 4 / 67","doi":"10.1093/nar/gkq321","topics":null,"edam_scopes":null,"bio.agents":"alter","OMICagents":"OMICS_19786","SEQwiki":null,"SciCrunch":{"source":"alter-sequence-alignment","name":"SciCrunch","entry":"SCR_015968"},"RRID":null},{"package":"altree","distribution":"debian","release":"sid","component":"main","version":"1.3.1","source":"altree","homepage":"https://gitlab.inria.fr/NGS/ALTree","description":"program to perform phylogeny-based association and localization analysis","long_description":" ALTree was designed to perform association detection and localization of\n susceptibility sites using haplotype phylogenetic trees: first, it allows the\n detection of an association between a candidate gene and a disease, and second,\n it enables to make hypothesis about the susceptibility loci.\n","interface":["commandline"],"biology":null,"fields":["biology","biology:bioinformatics"],"use":["analysing","comparing"],"popcon":"9 / 3 / 84","doi":"10.1093/bioinformatics/btl131","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_13032","SEQwiki":null,"SciCrunch":{"source":"altree","name":"SciCrunch","entry":"SCR_007562"},"RRID":null},{"package":"amap-align","distribution":"debian","release":"sid","component":"main","version":"2.2+git20080214.600fc29","source":"amap-align","homepage":"https://github.com/mes5k/amap-align","description":"Protein multiple alignment by sequence annealing","long_description":" AMAP is a command line agent to perform multiple alignment of peptidic\n sequences. It utilizes posterior decoding, and a sequence-annealing\n alignment, instead of the traditional progressive alignment method. It is\n the only alignment program that allows one to control the sensitivity /\n specificity tradeoff.  It is based on the ProbCons source code, but\n uses alignment metric accuracy and eliminates the consistency\n transformation.\n .\n The Java visualisation agent of AMAP 2.2 is not yet packaged in Debian.\n","interface":["commandline"],"biology":null,"fields":["biology","biology:bioinformatics"],"use":["comparing","analysing"],"popcon":"23 / 27 / 920","doi":"10.1093/bioinformatics/btl311","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_19787","SEQwiki":null,"SciCrunch":{"source":"amap-align","name":"SciCrunch","entry":"SCR_015969"},"RRID":null},{"package":"amos-assembler","distribution":"prospective","release":"vcs","component":"main","version":"3.1.0","source":"amos","homepage":"http://amos.sourceforge.net/","description":"modular whole genome assembler","long_description":" The AMOS consortium is committed to the development of open-source\n whole genome assembly software. The project acronym (AMOS) represents\n our primary goal - to produce A Modular, Open-Source whole genome\n assembler. Open-source so that everyone is welcome to contribute and\n help build outstanding assembly agents, and modular in nature so that\n new contributions can be easily inserted into an existing assembly\n pipeline. This modular design will foster the development of new\n assembly algorithms and allow the AMOS project to continually grow\n and improve in hopes of eventually becoming a widely accepted and\n deployed assembly infrastructure. In this sense, AMOS is both a\n design philosophy and a software system.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1093/bib/bbr074","topics":null,"edam_scopes":null,"bio.agents":"amos","OMICagents":"OMICS_00008","SEQwiki":null,"SciCrunch":{"source":"amos","name":"SciCrunch","entry":"SCR_013067"},"RRID":null},{"package":"hawkeye","distribution":"prospective","release":"vcs","component":"main","version":"3.1.0","source":"amos","homepage":"http://amos.sourceforge.net/","description":"Interactive Visual Analytics Agent for Genome Assemblies","long_description":" Genome assembly remains an inexact science. Even when accomplished\n with the best software available, the assembly of a genome often\n contains numerous errors, both small and large. Hawkeye is a visual\n analytics agent for genome assembly analysis and validation, designed\n to aid in identifying and correcting assembly errors. Hawkeye blends\n the best practices from information and scientific visualization to\n facilitate inspection of large-scale assembly data while minimizing\n the time needed to detect mis-assemblies and make accurate judgments\n of assembly quality.\n .\n All levels of the assembly data hierarchy are made accessible to\n users, along with summary statistics and common assembly metrics. A\n ranking component guides investigation towards likely mis-assemblies\n or interesting features to support the task at hand. Wherever\n possible, high-level overviews, dynamic filtering, and automated\n clustering are leveraged to focus attention and highlight anomalies\n in the data. Hawkeyes effectiveness has been proven on several genome\n projects, where it has been used both to improve quality and to\n validate the correctness of complex genomes.\n .\n Hawkeye is compatible with most widely used assemblers, including\n Phrap, ARACHNE, Celera Assembler, Newbler, AMOS, and assemblies\n deposited in the NCBI Assembly Archive.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1093/bib/bbr074","topics":null,"edam_scopes":null,"bio.agents":"amos","OMICagents":"OMICS_00008","SEQwiki":null,"SciCrunch":{"source":"amos","name":"SciCrunch","entry":"SCR_013067"},"RRID":null},{"package":"ampliconnoise","distribution":"debian","release":"sid","component":"main","version":"1.29","source":"ampliconnoise","homepage":"https://github.com/lanzen/ampliconnoise","description":"removal of noise from 454 sequenced PCR amplicons","long_description":" AmpliconNoise is a package of applications to clean up high-throughput\n sequence data.  It consists of three main parts:\n .\n Pyronoise - does flowgram-based clustering to spot misreads\n SeqNoise - removes PCR point mutations\n Perseus - removes PCR chimeras without the need for a set of reference\n sequences\n .\n Previously there was a standalone \"Pyronoise\" by the same authors and\n this package includes an updated version.  There is also a \"Denoiser\"\n in Qiime which is related but distinct.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 2 / 90","doi":"10.1186/1471-2105-12-38","topics":["Sequencing"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Sequence trace", "formats": ["SFF"]}], "outputs": [{"data": "Sequence", "formats": ["FASTA"]}], "function": ["Sequencing quality control"]}],"bio.agents":"pyronoise","OMICagents":"OMICS_01112","SEQwiki":{"source":"ampliconnoise","name":"SEQwiki","entry":"PyroNoise"},"SciCrunch":{"source":"ampliconnoise","name":"SciCrunch","entry":"SCR_007814"},"RRID":null},{"package":"andi","distribution":"debian","release":"sid","component":"main","version":"0.12","source":"andi","homepage":"https://github.com/EvolBioInf/andi","description":"Efficient Estimation of Evolutionary Distances","long_description":" This is the andi program for estimating the evolutionary distance\n between closely related genomes. These distances can be used to rapidly\n infer phylogenies for big sets of genomes. Because andi does not compute\n full alignments, it is so efficient that it scales even up to thousands\n of bacterial genomes.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 3 / 61","doi":"10.1093/bioinformatics/btu815","topics":["Phylogenetics"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Sequence", "formats": ["FASTA"]}], "outputs": [{"data": "Sequence distance matrix", "formats": ["Phylip distance matrix"]}], "function": ["Sequence distance matrix generation"]}],"bio.agents":"andi","OMICagents":"OMICS_09287","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"anfo","distribution":"debian","release":"sid","component":"main","version":"0.98","source":"anfo","homepage":"http://bioinf.eva.mpg.de/anfo/","description":"Short Read Aligner/Mapper from MPG","long_description":" Anfo is a mapper in the spirit of Soap/Maq/Bowtie, but its implementation takes\n more after BLAST/BLAT. It's most useful for the alignment of sequencing reads\n where the DNA sequence is somehow modified (think ancient DNA or bisulphite\n treatment) and/or there is more divergence between sample and reference than\n what fast mappers will handle gracefully (say the reference genome is missing\n and a related species is used instead).\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 3 / 107","doi":null,"topics":["Sequencing"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "DNA Sequence", "formats": ["FASTQ"]}, {"data": "DNA Sequence", "formats": ["FASTA"]}], "outputs": [{"data": "Sequence", "formats": ["FASTQ"]}, {"data": "Alignment", "formats": ["SAM", "FASTA", "Binary"]}, {"data": "Report", "formats": ["TSV"]}], "function": ["Read mapping", "Sequence filter"]}],"bio.agents":null,"OMICagents":"OMICS_08846","SEQwiki":null,"SciCrunch":{"source":"anfo","name":"SciCrunch","entry":"SCR_015973"},"RRID":null},{"package":"apollo","distribution":"prospective","release":"vcs","component":"main","version":"2.0.8","source":"apollo","homepage":"http://genomearchitect.org/","description":"genome annotation viewer and editor","long_description":" Apollo is a genome annotation viewer and editor. It was developed as a\n collaboration between the Berkeley Drosophila Genome Project (part of\n the FlyBase consortium) and The Sanger Institute in Cambridge, UK.\n Apollo allows researchers to explore genomic annotations at many levels\n of detail, and to perform expert annotation curation, all in a graphical\n environment. It was used by the FlyBase biologists to construct the\n Release 3 annotations on the finished Drosophila melanogaster genome,\n and is also a primary vehicle for sharing these annotations with the\n community. The Generic Model Organism Database (GMOD) project, which\n aims to provide a complete ready-to-use agentkit for analyzing whole\n genomes, has adopted Apollo as its annotation workbench.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1186/gb-2002-3-12-research0082","topics":null,"edam_scopes":null,"bio.agents":"ApolloGenAnnotCuratAgent","OMICagents":"OMICS_11761","SEQwiki":null,"SciCrunch":{"source":"apollo","name":"SciCrunch","entry":"SCR_001936"},"RRID":null},{"package":"aragorn","distribution":"debian","release":"sid","component":"main","version":"1.2.38","source":"aragorn","homepage":"http://mbio-serv2.mbioekol.lu.se/ARAGORN/","description":"tRNA and tmRNA detection in nucleotide sequences","long_description":" The program employs heuristic algorithms to predict tRNA secondary structure,\n based on homology with recognized tRNA consensus sequences and ability to form\n a base-paired cloverleaf. tmRNA genes are identified using a modified version\n of the BRUCE program.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"11 / 3 / 119","doi":"10.1093/nar/gkh152","topics":["Functional, regulatory and non-coding RNA"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Sequence", "formats": ["FASTA"]}], "outputs": [{"data": "Sequence", "formats": ["FASTA"]}, {"data": "RNA secondary structure", "formats": ["RNA secondary structure format"]}], "function": ["tRNA gene prediction"]}],"bio.agents":null,"OMICagents":"OMICS_04227","SEQwiki":null,"SciCrunch":{"source":"aragorn","name":"SciCrunch","entry":"SCR_015974"},"RRID":null},{"package":"arb","distribution":"debian","release":"sid","component":"non-free","version":"6.0.6","source":"arb","homepage":"http://www.arb-home.de/","description":"phylogenetic sequence analysis suite - main program","long_description":" ARB is a graphical suite of agents for sequence database handling and data\n analysis. A central database of processed (aligned) sequences and any\n type of additional data linked to the sequence entries is structured\n according to phylogeny or other user-defined criteria.\n .\n The ARB project (from the Latin \"arbor\", a tree) is a joint initiative of\n the Lehrstuhl fuer Mikrobiologie http://www.mikro.biologie.tu-muenchen.de/\n and the Lehrstuhl fuer Rechnertechnik und Rechnerorganisation\n http://wwwbode.informatik.tu-muenchen.de/ of the Technical University\n of Munich.\n","interface":null,"biology":null,"fields":["biology"],"use":null,"popcon":"3 / 0 / 24","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"arden","distribution":"debian","release":"sid","component":"main","version":"1.0","source":"arden","homepage":"http://sourceforge.net/projects/arden/","description":"specificity control for read alignments using an artificial reference","long_description":" ARDEN (Artificial Reference Driven Estimation of false positives in NGS\n data) is a novel benchmark that estimates error rates based on real\n experimental reads and an additionally generated artificial reference\n genome. It allows the computation of error rates specifically for a\n dataset and the construction of a ROC-curve. Thereby, it can be used to\n optimize parameters for read mappers, to select read mappers for a\n specific problem or also to filter alignments based on quality\n estimation.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 3 / 94","doi":"10.1093/bioinformatics/btt255","topics":["Sequencing"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Sequence", "formats": ["FASTA"]}], "outputs": [{"data": "Report", "formats": ["Text"]}], "function": ["Sequence quality control"]}],"bio.agents":null,"OMICagents":"OMICS_09783","SEQwiki":null,"SciCrunch":{"source":"arden","name":"SciCrunch","entry":"SCR_015975"},"RRID":null},{"package":"ariba","distribution":"debian","release":"sid","component":"main","version":"2.13.3+ds","source":"ariba","homepage":"https://github.com/sanger-pathogens/ariba","description":"Antibiotic Resistance Identification By Assembly","long_description":" ARIBA is a agent that identifies antibiotic resistance genes by running local\n assemblies.\n The input is a FASTA file of reference genes and paired sequencing reads. ARIBA\n reports which of the reference genes were found, plus detailed information on\n the quality of the assemblies and any variants between the sequencing reads\n and the reference genes.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 3 / 49","doi":"10.1099/mgen.0.000131","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_17327","SEQwiki":null,"SciCrunch":{"source":"ariba","name":"SciCrunch","entry":"SCR_015976"},"RRID":null},{"package":"artemis","distribution":"debian","release":"sid","component":"main","version":"17.0.1","source":"artemis","homepage":"http://www.sanger.ac.uk/science/agents/artemis","description":"genome browser and annotation agent","long_description":" Artemis is a genome browser and annotation agent that allows visualisation of\n sequence features, next generation data and the results of analyses within the\n context of the sequence, and also its six-frame translation.\n .\n This package includes the Artemis genome browser, the Artemis Comparison\n Agent (ACT), and the DNAplotter and BamView utilities.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 19 / 72","doi":"10.1093/bioinformatics/btr703","topics":["Genomics"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Sequence", "formats": ["BAM", "FASTA", "GFF", "EMBL format", "VCF", "BCF"]}], "outputs": [{"data": "Sequence", "formats": ["GFF", "EMBL format", "FASTA", "GenBank format"]}, {"data": "Sequence image", "formats": ["PNG", "SVG", "JPG"]}, {"data": "Feature table", "formats": ["Sequin format"]}], "function": ["Genome visualisation", "Genome annotation"]}],"bio.agents":"artemis","OMICagents":"OMICS_00903","SEQwiki":null,"SciCrunch":{"source":"artemis","name":"SciCrunch","entry":"SCR_004267"},"RRID":null},{"package":"artfastqgenerator","distribution":"debian","release":"sid","component":"main","version":"0.0.20150519","source":"artfastqgenerator","homepage":"https://sourceforge.net/projects/artfastqgen/","description":"outputs artificial FASTQ files derived from a reference genome","long_description":" ArtificialFastqGenerator takes the reference genome (in FASTA format) as\n input and outputs artificial FASTQ files in the Sanger format. It can\n accept Phred base quality scores from existing FASTQ files, and use them\n to simulate sequencing errors. Since the artificial FASTQs are derived\n from the reference genome, the reference genome provides a gold-standard\n for calling variants (Single Nucleotide Polymorphisms (SNPs) and\n insertions and deletions (indels)). This enables evaluation of a Next\n Generation Sequencing (NGS) analysis pipeline which aligns reads to the\n reference genome and then calls the variants.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 3 / 59","doi":"10.1371/journal.pone.0049110","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_00248","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"art-nextgen-simulation-agents","distribution":"debian","release":"sid","component":"main","version":"20160605","source":"art-nextgen-simulation-agents","homepage":"http://www.niehs.nih.gov/research/resources/software/biostatistics/art/","description":"simulation agents to generate synthetic next-generation sequencing reads","long_description":" ART is a set of simulation agents to generate synthetic next-generation\n sequencing reads. ART simulates sequencing reads by mimicking real\n sequencing process with empirical error models or quality profiles\n summarized from large recalibrated sequencing data. ART can also\n simulate reads using user own read error model or quality profiles. ART\n supports simulation of single-end, paired-end/mate-pair reads of three\n major commercial next-generation sequencing platforms: Illumina's\n Solexa, Roche's 454 and Applied Biosystems' SOLiD. ART can be used to\n test or benchmark a variety of method or agents for next-generation\n sequencing data analysis, including read alignment, de novo assembly,\n SNP and structure variation discovery. ART was used as a primary agent\n for the simulation study of the 1000 Genomes Project . ART is\n implemented in C++ with optimized algorithms and is highly efficient in\n read simulation. ART outputs reads in the FASTQ format, and alignments\n in the ALN format. ART can also generate alignments in the SAM\n alignment or UCSC BED file format. ART can be used together with genome\n variants simulators (e.g. VarSim) for evaluating variant calling agents\n or methods.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 4 / 64","doi":"10.1093/bioinformatics/btr708","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_00247","SEQwiki":null,"SciCrunch":{"source":"art-nextgen-simulation-agents","name":"SciCrunch","entry":"SCR_006538"},"RRID":null},{"package":"assemblytics","distribution":"debian","release":"sid","component":"main","version":"1.0+ds","source":"assemblytics","homepage":"http://assemblytics.com/","description":"detect and analyze structural variants from a genome assembly","long_description":" Assemblytics incorporates a unique anchor filtering approach to increase\n robustness to repetitive elements, and identifies six classes of variants\n based on their distinct alignment signatures. Assemblytics can be applied\n both to comparing aberrant genomes, such as human cancers, to a reference,\n or to identify differences between related species.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 2 / 16","doi":"10.1093/bioinformatics/btw369","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_11402","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"augustus","distribution":"debian","release":"sid","component":"main","version":"3.3.2","source":"augustus","homepage":"http://bioinf.uni-greifswald.de/augustus/","description":"gene prediction in eukaryotic genomes","long_description":" AUGUSTUS is a software for gene prediction in eukaryotic genomic sequences\n that is based on a generalized hidden Markov model (HMM), a probabilistic\n model of a sequence and its gene structure. After learning gene structures\n from a reference annotation, AUGUSTUS uses the HMM to recognize genes in a new\n sequence and annotates it with the regions of identified genes. External hints,\n e.g. from RNA sequencing, EST or protein alignments etc. can be used to guide\n and improve the gene finding process. The result is the set of most likely gene\n structures that comply with all given user constraints, if such gene\n structures exist.\n AUGUSTUS already includes prebuilt HMMs for many species, as well as scripts\n to train custom models using annotated genomes.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 3 / 70","doi":"10.1186/1471-2105-7-62","topics":null,"edam_scopes":null,"bio.agents":"AUGUSTUS","OMICagents":"OMICS_07777","SEQwiki":null,"SciCrunch":{"source":"augustus","name":"SciCrunch","entry":"SCR_008417"},"RRID":null},{"package":"autodock","distribution":"debian","release":"sid","component":"main","version":"4.2.6","source":"autodocksuite","homepage":"http://autodock.scripps.edu/","description":"analysis of ligand binding to protein structure","long_description":" AutoDock is a prime representative of the programs addressing the\n simulation of the docking of fairly small chemical ligands to rather big\n protein receptors. Earlier versions had all flexibility in the ligands\n while the protein was kept rather ridgid. This latest version 4 also\n allows for a flexibility of selected sidechains of surface residues,\n i.e., takes the rotamers into account.\n .\n The AutoDock program performs the docking of the ligand to a set of\n grids describing the target protein. AutoGrid pre-calculates these grids.\n","interface":["commandline"],"biology":null,"fields":["biology","biology:structural"],"use":["analysing"],"popcon":"13 / 4 / 126","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"autogrid","distribution":"debian","release":"sid","component":"main","version":"4.2.6","source":"autodocksuite","homepage":"http://autodock.scripps.edu/","description":"pre-calculate binding of ligands to their receptor","long_description":" The AutoDockSuite addresses the molecular analysis of the docking of\n a smaller chemical compounds to their receptors of known three-dimensional\n structure.\n .\n The AutoGrid program performs pre-calculations for the docking of a\n ligand to a set of grids that describe the effect that the protein has\n on point charges.  The effect of these forces on the ligand is then\n analysed by the AutoDock program.\n","interface":["commandline"],"biology":null,"fields":["biology","biology:structural"],"use":["analysing"],"popcon":"9 / 4 / 115","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"autodockagents","distribution":"debian","release":"sid","component":"non-free","version":"1.5.7","source":"autodockagents","homepage":"http://autodock.scripps.edu/","description":"GUI to help set up, launch and analyze AutoDock dockings","long_description":" This package is part of the mglagents set of Python libraries which\n provide an infrastructure for the analysis of protein structures and\n their docking of chemical compounds.\n .\n AutoDock is a well established package for the automated screening of\n libraries of formal representation of chemical compounds that putatively\n bind to a particular protein at hand. This package provides a graphical\n user interface that is helping with the preparation of the protein\n for such analyses.\n .\n The agent AutoLigand, which may help to constrain the location of the\n binding pocket for yet undescribed proteins,  is accompanying the\n main executable 'runAdt'.\n","interface":["x11"],"biology":null,"fields":["biology","biology:structural","chemistry"],"use":["analysing","configuring","converting","simulating","viewing"],"popcon":"2 / 0 / 10","doi":"10.1002/jcc.21256","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"autodock-vina","distribution":"debian","release":"sid","component":"main","version":"1.1.2","source":"autodock-vina","homepage":"http://vina.scripps.edu","description":"docking of small molecules to proteins","long_description":" AutoDock Vina is a program to support drug discovery, molecular\n docking and virtual screening of compound libraries. It offers\n multi-core capability, high performance and enhanced accuracy\n and ease of use.\n .\n The same institute also developed autodock, which is widely used.\n .\n O. Trott, A. J. Olson, AutoDock Vina: improving the speed and accuracy\n of docking with a new scoring function, efficient optimization and\n multithreading, Journal of Computational Chemistry 31 (2010) 455-461\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"16 / 4 / 125","doi":"10.1002/jcc.21334","topics":null,"edam_scopes":null,"bio.agents":"AutoDock_Vina","OMICagents":"OMICS_03790","SEQwiki":null,"SciCrunch":{"source":"autodock-vina","name":"SciCrunch","entry":"SCR_011958"},"RRID":null},{"package":"avogadro","distribution":"debian","release":"sid","component":"main","version":"1.2.0","source":"avogadro","homepage":"http://avogadro.cc/","description":"Molecular Graphics and Modelling System","long_description":" Avogadro is a molecular graphics and modelling system targeted at molecules\n and biomolecules.  It can visualize properties like molecular orbitals or\n electrostatic potentials and features an intuitive molecular builder.\n .\n Features include:\n  * Molecular modeller with automatic force-field based geometry optimization\n  * Molecular Mechanics including constraints and conformer searches\n  * Visualization of molecular orbitals and general isosurfaces\n  * Visualization of vibrations and plotting of vibrational spectra\n  * Support for crystallographic unit cells\n  * Input generation for the Gaussian, GAMESS and MOLPRO quantum chemistry\n    packages\n  * Flexible plugin architecture and Python scripting\n .\n File formats Avogadro can read include PDB, XYZ, CML, CIF, Molden, as well as\n Gaussian, GAMESS and MOLPRO output.\n","interface":null,"biology":null,"fields":["chemistry"],"use":["viewing"],"popcon":"107 / 71 / 1257","doi":"10.1186/1758-2946-4-17","topics":null,"edam_scopes":null,"bio.agents":"Avogadro","OMICagents":"OMICS_04967","SEQwiki":null,"SciCrunch":{"source":"avogadro","name":"SciCrunch","entry":"SCR_015983"},"RRID":null},{"package":"axe-demultiplexer","distribution":"debian","release":"sid","component":"main","version":"0.3.3","source":"axe-demultiplexer","homepage":"https://github.com/kdmurray91/axe","description":"Trie-based DNA sequencing read demultiplexer","long_description":" Axe very rapidly selects the optimal barcode present in a sequence read, even\n in the presence of sequencing errors. The algorithm is able to handle\n combinatorial barcoding, barcodes of differing length, and several mismatches\n per barcode.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 4 / 68","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_19788","SEQwiki":null,"SciCrunch":{"source":"axe-demultiplexer","name":"SciCrunch","entry":"SCR_015984"},"RRID":null},{"package":"axparafit","distribution":"prospective","release":"vcs","component":"main","version":"1.0","source":"axparafit","homepage":"http://sco.h-its.org/exelixis/web/software/AxParafit/index.html","description":"optimized statistical analysis of host-parasite coevolution","long_description":" AxParafit is a highly optimized version of Pierre Legendre's Parafit program\n for statistical analysis of host-parasite coevolution. AxParafit has been\n parallelized with MPI (Message Passing Interface) for compute clusters and\n was used to carry out the largest co-evolutionary analysis to date for the\n paper describing the software.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"axpcoords","distribution":"prospective","release":"vcs","component":"main","version":"1.0","source":"axpcoords","homepage":"https://github.com/stamatak/AxPcoords.dist","description":"highly optimized and parallelized porting of pcoords","long_description":" AxPcoords is an highly optimized versions of Pierre Legendre's DistPCoA\n program for statistical analysis of host-parasite coevolution.\n .\n AxPcoords is a fast, LAPACK-based implementation of DistPCoA (see\n http://www.bio.umontreal.ca/Casgrain/en/labo/distpcoa.html)\n which is another program by Pierre Legendre, it conducts a principal\n coordinates analysis.\n This program is required for the pipeline that conducts a full host-parasite\n co-phylogenetic analysis in combination with AxParafit.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"bagpipe","distribution":"prospective","release":"vcs","component":"main","version":"2012.02.15","source":"bagpipe","homepage":"http://valdarlab.unc.edu/software/bagpipe/_build/html/bagpipe.html","description":"genomewide LD mapping","long_description":" Bagpipe is a program for performing genomewide linkage disequilibrium \n mapping of quantitative trait loci in populations whose genome structure \n can be accommodated in the HAPPY framework [Mott00]. This includes most \n diploid crosses where the founders of the individuals have known genotypes.\n .\n  * Bagpipe is a simplified and streamlined version of Bagphenotype that \n    does not currently include resample model averaging (RMA) capabilities.\n  * Bagpipe can help fit single locus regression models (with or without \n    random effects) to marker intervals whose genetic ancestry is inferred \n    using the HAPPY software.\n  * Bagpipe cannot help you decide what is a sensible model to fit.\n  * Bagpipe does not currently accommodate populations with significant \n    population structure, except through the specification of simple random \n    intercepts based on unpatterned covariance matrices.\n  * Bagpipe is named after the Scottish wind instrument \"the bagpipes\" and \n    after Bagphenotype, which in turn was a PIPEline for BAGging-based \n    multiple QTL analysis of phenoTYPEs. Bagphenotype was in turn based \n    on software written by Richard Mott and William Valdar to analyze \n    heterogeneous stock mice in [Valdar06].\n  * Bagpipe is experimental software, is provided free of charge subject to \n    copyleft restrictions, and comes with no guarantees whatsoever.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1073/pnas.230304397","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"baitfisher","distribution":"debian","release":"sid","component":"main","version":"1.2.7+git20180107.e92dbf2","source":"baitfisher","homepage":"https://github.com/cmayer/BaitFisher-package","description":"software package for designing hybrid enrichment probes","long_description":" The BaitFisher package consists of two programs: BaitFisher and BaitFilter.\n .\n BaitFisher was been designed to construct hybrid enrichment baits from\n multiple sequence alignments (MSAs) or annotated features in MSAs. The main\n goal of BaitFisher is to avoid redundancy in the construction of baits by\n designing fewer baits in conserved regions of the MSAs and designing more baits\n in variable regions. This makes use of the fact that hybrid enrichment baits\n can differ to some extends from the target region, which they should capture\n in the enrichment procedure.\n By specifying the allowed distance between baits and the sequences in the MSAs\n the user can control the allowed bait-to-target distance and the degree of\n reduction in the number of baits that are designed.\n See the BaitFisher paper for details.\n .\n BaitFilter was designed (i) to determine whether baits bind unspecifically to\n a reference genome, (ii) to filter baits that only have partial length matches\n to a reference genome, (iii) to determine the optimal bait region in a MSA and\n to convert baits to a format that can be uploaded at a bait constructing\n company. The optimal bait region can be the most conserved region in the MSA\n or the region with the highest number of sequences without gaps or ambiguous\n nucleotides.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 0 / 16","doi":"10.1093/molbev/msw056","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_11740","SEQwiki":null,"SciCrunch":{"source":"baitfisher","name":"SciCrunch","entry":"SCR_015985"},"RRID":null},{"package":"bali-phy","distribution":"debian","release":"sid","component":"main","version":"3.4.1","source":"bali-phy","homepage":"http://www.bali-phy.org","description":"Bayesian Inference of Alignment and Phylogeny","long_description":" BAli-Phy estimates multiple sequence alignments and evolutionary trees\n from unaligned DNA, amino acid, or codon sequences.  BAli-Phy uses MCMC\n to estimate evolutionary trees, positive selection, and branch lengths\n while averaging over alternative alignments. BAli-Phy can display\n alignment ambiguity graphically in an alignment uncertainty (AU) plot.\n .\n BAli-Phy can also estimate phylogenies from a fixed alignment (like MrBayes\n and BEAST) using substitution models like GTR+gamma.  BAli-Phy automatically\n estimates relative rates for each gene.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 2 / 17","doi":"10.1080/10635150590947041","topics":null,"edam_scopes":null,"bio.agents":"bali-phy","OMICagents":"OMICS_03734","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"ballview","distribution":"debian","release":"sid","component":"main","version":"1.5.0+git20180813.37fc53c","source":"ball","homepage":"http://www.ball-project.org/","description":"free molecular modeling and molecular graphics agent","long_description":" BALLView provides fast OpenGL-based visualization of molecular structures,\n molecular mechanics methods (minimization, MD simulation using the\n AMBER, CHARMM, and MMFF94 force fields), calculation and visualization\n of electrostatic properties (FDPB) and molecular editing features.\n .\n BALLView can be considered a graphical user interface on the basis of\n BALL (Biochemical Algorithms Library) with a focus on the most common\n demands of protein chemists and biophysicists in particular.  It is\n developed in the groups of Hans-Peter Lenhof (Saarland University,\n Saarbruecken, Germany) and Oliver Kohlbacher (University of Tuebingen,\n Germany). BALL is an application framework in C++ that has been\n specifically designed for rapid software development in Molecular\n Modeling and Computational Molecular Biology.  It provides an extensive\n set of data structures as well as classes for Molecular Mechanics,\n advanced solvation methods, comparison and analysis of protein\n structures, file import/export, and visualization.\n","interface":["x11"],"biology":null,"fields":null,"use":null,"popcon":"11 / 10 / 188","doi":"10.1093/bioinformatics/bti818","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_05049","SEQwiki":null,"SciCrunch":{"source":"ball","name":"SciCrunch","entry":"SCR_015986"},"RRID":null},{"package":"libbambamc-dev","distribution":"debian","release":"sid","component":"main","version":"0.0.50","source":"bambamc","homepage":"https://github.com/gt1/bambamc","description":"Development files for reading and writing BAM (genome alignment) files","long_description":" The BAM Format is a binary format for storing sequence data.  This is a\n lightweight C implementation of the read name collation code from the\n larger bambam C++ project to handle BAM file input and BAM file output.\n .\n This package contains the static library and header files.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 38","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"bamagents","distribution":"debian","release":"sid","component":"main","version":"2.5.1","source":"bamagents","homepage":"https://github.com/pezmaster31/bamagents/wiki","description":"agentkit for manipulating BAM (genome alignment) files","long_description":" BamAgents facilitates research analysis and data management using BAM\n files.  It copes with the enormous amount of data produced by current\n sequencing technologies that is typically stored in compressed, binary\n formats that are not easily handled by the text-based parsers commonly\n used in bioinformatics research.\n .\n BamAgents provides both a C++ API for BAM file support as well as a\n command-line agentkit.\n .\n This is the bamagents command-line agentkit.\n .\n Available bamagents commands:\n  convert  Converts between BAM and a number of other formats\n  count    Prints number of alignments in BAM file(s)\n  coverage Prints coverage statistics from the input BAM file\n  filter   Filters BAM file(s) by user-specified criteria\n  header   Prints BAM header information\n  index    Generates index for BAM file\n  merge    Merge multiple BAM files into single file\n  random   Select random alignments from existing BAM file(s), intended more\n           as a testing agent.\n  resolve  Resolves paired-end reads (marking the IsProperPair flag as needed)\n  revert   Removes duplicate marks and restores original base qualities\n  sort     Sorts the BAM file according to some criteria\n  split    Splits a BAM file on user-specified property, creating a new BAM\n           output file for each value found\n  stats    Prints some basic statistics from input BAM file(s)\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"14 / 7 / 170","doi":"10.1093/bioinformatics/btr174","topics":null,"edam_scopes":null,"bio.agents":"BamAgents","OMICagents":"OMICS_11315","SEQwiki":null,"SciCrunch":{"source":"bamagents","name":"SciCrunch","entry":"SCR_015987"},"RRID":null},{"package":"libbamagents-dev","distribution":"debian","release":"sid","component":"main","version":"2.5.1","source":"bamagents","homepage":"https://github.com/pezmaster31/bamagents/wiki","description":"C++ API for manipulating BAM (genome alignment) files","long_description":" BamAgents facilitates research analysis and data management using BAM\n files.  It copes with the enormous amount of data produced by current\n sequencing technologies that is typically stored in compressed, binary\n formats that are not easily handled by the text-based parsers commonly\n used in bioinformatics research.\n .\n BamAgents provides both a C++ API for BAM file support as well as a\n command-line agentkit.\n .\n This is the developers API package.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 0 / 49","doi":"10.1093/bioinformatics/btr174","topics":null,"edam_scopes":null,"bio.agents":"BamAgents","OMICagents":"OMICS_11315","SEQwiki":null,"SciCrunch":{"source":"bamagents","name":"SciCrunch","entry":"SCR_015987"},"RRID":null},{"package":"bandage","distribution":"debian","release":"sid","component":"main","version":"0.8.1","source":"bandage","homepage":"https://rrwick.github.io/Bandage","description":"Bioinformatics Application for Navigating De novo Assembly Graphs Easily","long_description":" Bandage is a GUI program that allows users to interact with the assembly\n graphs made by de novo assemblers such as Velvet, SPAdes, MEGAHIT and\n others.\n .\n De novo assembly graphs contain not only assembled contigs but\n also the connections between those contigs, which were previously not\n easily accessible. Bandage visualises assembly graphs, with connections,\n using graph layout algorithms. Nodes in the drawn graph, which represent\n contigs, can be automatically labelled with their ID, length or depth.\n Users can interact with the graph by moving, labelling and colouring\n nodes. Sequence information can also be extracted directly from the\n graph viewer. By displaying connections between contigs, Bandage opens\n up new possibilities for analysing and improving de novo assemblies that\n are not possible by looking at contigs alone.\n .\n More information and download links are on the Bandage website:\n rrwick.github.io/Bandage\n .\n The package is relevant to the field of genome assembly and will be\n maintained by the Debian Med team.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 7 / 15","doi":"https://doi.org/10.1093/bioinformatics/btv383","topics":null,"edam_scopes":null,"bio.agents":"bandage","OMICagents":"OMICS_09013","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"barrnap","distribution":"debian","release":"sid","component":"main","version":"0.9","source":"barrnap","homepage":"http://www.vicbioinformatics.com/software.barrnap.shtml","description":"rapid ribosomal RNA prediction","long_description":" Barrnap (BAsic Rapid Ribosomal RNA Predictor) predicts the location of\n ribosomal RNA genes in genomes. It supports bacteria (5S,23S,16S), archaea\n (5S,5.8S,23S,16S), mitochondria (12S,16S) and eukaryotes (5S,5.8S,28S,18S).\n .\n It takes FASTA DNA sequence as input, and writes GFF3 as output. It uses the\n NHMMER agent that comes with HMMER 3.1 for HMM searching in RNA:DNA style.\n Multithreading is supported and one can expect roughly linear speed-ups\n with more CPUs.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 4 / 71","doi":null,"topics":["Functional, regulatory and non-coding RNA"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Sequence", "formats": ["FASTA"]}], "outputs": [{"data": "Sequence features", "formats": ["GFF3"]}], "function": ["Homology-based gene prediction"]}],"bio.agents":"barrnap","OMICagents":"OMICS_13988","SEQwiki":null,"SciCrunch":{"source":"barrnap","name":"SciCrunch","entry":"SCR_015995"},"RRID":null},{"package":"bax2bam","distribution":"prospective","release":"vcs","component":"main","version":"0.0.9","source":"bax2bam","homepage":"https://github.com/PacificBiosciences/bax2bam","description":"Convert legacy PacBio Bax.H5, Bas.H5, and Ccs.H5 files to the new PacBio BAM format","long_description":" The program bax2bam converts the legacy PacBio basecall format (bax.h5) into\n the BAM basecall format.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"bcbio","distribution":"debian","release":"sid","component":"main","version":"1.1.2","source":"bcbio","homepage":"https://github.com/chapmanb/bcbio-nextgen","description":"agentkit for analysing high-throughput sequencing data","long_description":" This package installs the command line agents of the bcbio-nextgen\n agentkit implementing best-practice pipelines for fully automated high\n throughput sequencing analysis.\n .\n A high-level configuration file specifies inputs and analysis parameters\n to drive a parallel pipeline that handles distributed execution,\n idempotent processing restarts and safe transactional steps.  The project\n contributes a shared community resource that handles the data processing\n component of sequencing analysis, providing researchers with more time\n to focus on the downstream biology.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 5 / 10","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"bcbio-nextgen","OMICagents":"OMICS_01121","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python3-bcbio","distribution":"debian","release":"sid","component":"main","version":"1.1.2","source":"bcbio","homepage":"https://github.com/chapmanb/bcbio-nextgen","description":"library for analysing high-throughput sequencing data","long_description":" This package installs the Python 3 libraries of the bcbio-nextgen\n agentkit implementing best-practice pipelines for fully automated high\n throughput sequencing analysis.\n .\n A high-level configuration file specifies inputs and analysis parameters\n to drive a parallel pipeline that handles distributed execution,\n idempotent processing restarts and safe transactional steps.  The project\n contributes a shared community resource that handles the data processing\n component of sequencing analysis, providing researchers with more time\n to focus on the downstream biology.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 6 / 11","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"bcbio-nextgen","OMICagents":"OMICS_01121","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"bcfagents","distribution":"debian","release":"sid","component":"main","version":"1.9","source":"bcfagents","homepage":"http://samagents.github.io/bcfagents/","description":"genomic variant calling and manipulation of VCF/BCF files","long_description":" BCFagents is a set of utilities that manipulate variant calls in the\n Variant Call Format (VCF) and its binary counterpart BCF. All commands work\n transparently with both VCFs and BCFs, both uncompressed and BGZF-compressed.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"16 / 6 / 108","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"bcfagents","OMICagents":"OMICS_13458","SEQwiki":null,"SciCrunch":{"source":"bcfagents","name":"SciCrunch","entry":"SCR_005227"},"RRID":null},{"package":"beads","distribution":"debian","release":"sid","component":"main","version":"1.1.18","source":"beads","homepage":"http://moulon.inra.fr/beads/beads.html","description":"2-DE electrophoresis gel image spot detection","long_description":" BEADS is a program for spot detection on 2-D gel images. It is based on\n an analogy with beads flowing uphill on the surface of the gel image and\n on the analysis of their paths (Langella & Zivy, 2008).\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 0 / 18","doi":"10.1002/pmic.200800644","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_25900","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"beagle","distribution":"debian","release":"sid","component":"main","version":"5.0-180928","source":"beagle","homepage":"https://faculty.washington.edu/browning/beagle/beagle.html","description":"Genotype calling, genotype phasing and imputation of ungenotyped markers","long_description":" Beagle performs genotype calling, genotype phasing, imputation of ungenotyped\n markers, and identity-by-descent segment detection. Genotypic imputation works\n on phased haplotypes using a Li and Stephens haplotype frequency model.\n Beagle also implements the Refined IBD algorithm for detecting\n homozygosity-by-descent (HBD) and identity-by-descent (IBD) segments.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"12 / 4 / 70","doi":"10.1086/521987","topics":null,"edam_scopes":null,"bio.agents":"BEAGLE","OMICagents":"OMICS_00052","SEQwiki":null,"SciCrunch":{"source":"beagle","name":"SciCrunch","entry":"SCR_001789"},"RRID":null},{"package":"beast2-mcmc","distribution":"debian","release":"sid","component":"main","version":"2.5.1","source":"beast2-mcmc","homepage":"http://www.beast2.org","description":"Bayesian MCMC phylogenetic inference","long_description":" BEAST is a cross-platform program for Bayesian MCMC analysis of molecular\n sequences. It is entirely orientated towards rooted, time-measured\n phylogenies inferred using strict or relaxed molecular clock models. It\n can be used as a method of reconstructing phylogenies but is also a\n framework for testing evolutionary hypotheses without conditioning on a\n single tree topology. BEAST uses MCMC to average over tree space, so that\n each tree is weighted proportional to its posterior probability. Included\n is a simple to use user-interface program for setting up standard\n analyses and a suit of programs for analysing the results.\n .\n This is no new upstream version of beast-mcmc (1.x) but rather a rewritten\n version.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 10 / 62","doi":"10.1371/journal.pcbi.1003537","topics":null,"edam_scopes":null,"bio.agents":"beast","OMICagents":"OMICS_04233","SEQwiki":null,"SciCrunch":{"source":"beast2-mcmc","name":"SciCrunch","entry":"SCR_010228"},"RRID":null},{"package":"beast-mcmc","distribution":"debian","release":"sid","component":"main","version":"1.10.4","source":"beast-mcmc","homepage":"http://beast.bio.ed.ac.uk/","description":"Bayesian MCMC phylogenetic inference","long_description":" BEAST is a cross-platform program for Bayesian MCMC analysis of molecular\n sequences. It is entirely orientated towards rooted, time-measured\n phylogenies inferred using strict or relaxed molecular clock models. It\n can be used as a method of reconstructing phylogenies but is also a\n framework for testing evolutionary hypotheses without conditioning on a\n single tree topology. BEAST uses MCMC to average over tree space, so that\n each tree is weighted proportional to its posterior probability. Included\n is a simple to use user-interface program for setting up standard\n analyses and a suit of programs for analysing the results.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 4 / 56","doi":"10.1186/1471-2148-7-214","topics":null,"edam_scopes":null,"bio.agents":"beast","OMICagents":"OMICS_04233","SEQwiki":null,"SciCrunch":{"source":"beast-mcmc","name":"SciCrunch","entry":"SCR_010228"},"RRID":null},{"package":"bedops","distribution":"debian","release":"sid","component":"main","version":"2.4.35","source":"bedops","homepage":"https://github.com/bedops/bedops","description":"high-performance genomic feature operations","long_description":" BEDOPS is a suite of agents to address common questions raised in genomic\n studies, mostly with regard to overlap and proximity relationships between\n data sets.\n It aims to be scalable and flexible, facilitating the efficient and accurate\n analysis and management of large-scale genomic data.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 0 / 25","doi":"10.1093/bioinformatics/bts277","topics":null,"edam_scopes":null,"bio.agents":"Bedops","OMICagents":"OMICS_00949","SEQwiki":null,"SciCrunch":{"source":"bedops","name":"SciCrunch","entry":"SCR_012865"},"RRID":null},{"package":"bedagents","distribution":"debian","release":"sid","component":"main","version":"2.27.1","source":"bedagents","homepage":"https://github.com/arq5x/bedagents2","description":"suite of utilities for comparing genomic features","long_description":" The BEDAgents utilities allow one to address common genomics tasks such as\n finding feature overlaps and computing coverage. The utilities are largely\n based on four widely-used file formats: BED, GFF/GTF, VCF, and SAM/BAM. Using\n BEDAgents, one can develop sophisticated pipelines that answer complicated\n research questions by streaming several BEDAgents together.\n .\n The groupBy utility is distributed in the filo package.\n","interface":["commandline"],"biology":null,"fields":["biology","biology:bioinformatics"],"use":["analysing","comparing","converting","filtering"],"popcon":"42 / 40 / 502","doi":"10.1093/bioinformatics/btq033","topics":null,"edam_scopes":null,"bio.agents":"bedagents","OMICagents":"OMICS_01159","SEQwiki":null,"SciCrunch":{"source":"bedagents","name":"SciCrunch","entry":"SCR_006646"},"RRID":null},{"package":"berkeley-express","distribution":"debian","release":"sid","component":"main","version":"1.5.2","source":"berkeley-express","homepage":"http://bio.math.berkeley.edu/eXpress/index.html","description":"Streaming quantification for high-throughput sequencing","long_description":" eXpress is a streaming agent for quantifying the abundances of a set of\n target sequences from sampled subsequences. Example applications include\n transcript-level RNA-Seq quantification, allele-specific/haplotype\n expression analysis (from RNA-Seq), transcription factor binding\n quantification in ChIP-Seq, and analysis of metagenomic data. It is\n based on an online-EM algorithm that results in space (memory)\n requirements proportional to the total size of the target sequences and\n time requirements that are proportional to the number of sampled\n fragments. Thus, in applications such as RNA-Seq, eXpress can accurately\n quantify much larger samples than other currently available agents\n greatly reducing computing infrastructure requirements. eXpress can be\n used to build lightweight high-throughput sequencing processing\n pipelines when coupled with a streaming aligner (such as Bowtie), as\n output can be piped directly into eXpress, effectively eliminating the\n need to store read alignments in memory or on disk.\n .\n In an analysis of the performance of eXpress for RNA-Seq data, it was\n observed that this efficiency does not come at a cost of accuracy.\n eXpress is more accurate than other available agents, even when limited\n to smaller datasets that do not require such efficiency. Moreover, like\n the Cufflinks program, eXpress can be used to estimate transcript\n abundances in multi-isoform genes. eXpress is also able to resolve\n multi-mappings of reads across gene families, and does not require a\n reference genome so that it can be used in conjunction with de novo\n assemblers such as Trinity, Oases, or Trans-ABySS. The underlying model\n is based on previously described probabilistic models developed for\n RNA-Seq but is applicable to other settings where target sequences are\n sampled, and includes parameters for fragment length distributions,\n errors in reads, and sequence-specific fragment bias.\n .\n eXpress can be used to resolve ambiguous mappings in other\n high-throughput sequencing based applications. The only required inputs\n to eXpress are a set of target sequences and a set of sequenced\n fragments multiply-aligned to them.  While these target sequences will\n often be gene isoforms, they need not be. Haplotypes can be used as the\n reference for allele-specific expression analysis, binding regions for\n ChIP-Seq, or target genomes in metagenomics experiments. eXpress is\n useful in any analysis where reads multi-map to sequences that differ in\n abundance.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 5 / 72","doi":"10.1038/nmeth.2251","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_01275","SEQwiki":null,"SciCrunch":{"source":"berkeley-express","name":"SciCrunch","entry":"SCR_006873"},"RRID":null},{"package":"biceps","distribution":"prospective","release":"vcs","component":"main","version":"0.0.201401","source":"biceps","homepage":"http://hci.iwr.uni-heidelberg.de/MIP/Software/biceps.php","description":"error-tolerant peptide identification","long_description":" BICEPS is agent for the error-tolerant identification of peptides based\n on a statistical regularization scheme. It balances possible\n improvements in peptide-spectrum-matches by allowing substitutions\n against the increased risk of false positives. BICEPS can identify\n peptides containing two or more substitutions as occuring e.g. in\n cross-species searches. ","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1074/mcp.M111.014167","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"bigsdb","distribution":"prospective","release":"vcs","component":"main","version":"1.18.1","source":"bigsdb","homepage":"http://pubmlst.org/software/database/bigsdb/","description":"Bacterial Isolate Genome Sequence Database","long_description":" The Bacterial Isolate Genome Sequence Database (BIGSdb) is a scalable,\n web-accessible database system designed to store and analyse linked\n phenotypic and genotypic information in a computationally efficient\n manner. Sequence data can range from single sequence reads to multiple\n contigs generated by whole genome sequencing technologies. The system\n incorporates the capacity to define and identify any number of loci and\n genetic variants at those loci within the stored nucleotide sequences.\n These loci can be further organised into schemes for isolate\n characterisation or for evolutionary or functional analyses.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1186/1471-2105-11-595","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_20820","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libbiococoa-dev","distribution":"debian","release":"sid","component":"main","version":"2.2.2","source":"biococoa","homepage":"http://bioinformatics.org/biococoa/","description":"Bioinformatics framework for GNUstep and Cocoa (development files)","long_description":" BioCocoa is an open source Cocoa framework for bioinformatics. It intends to\n provide Cocoa programmers with a full suite of agents for handling and\n manipulating biological sequences. Cocoa is a great framework for rapid\n application development and it is therefore often used to create innovative\n bioscientific apps. To speed up development even more, BioCocoa wants to\n offer reusable Cocoa classes that are specific for molecular biology and\n biofinformatics. At this time, BioCocoa offers model classes for biological\n sequences, controller classes for alignment, sequence manipulation and I/O,\n interfacing with ENTREZ and view classes that let you easily display and work\n with sequences in your own applications.\n .\n This package contains the development files, documentation and\n examples for developing GNUstep applications using the BioCocoa framework.\n","interface":null,"biology":["nuceleic-acids","peptidic"],"fields":["biology","biology:bioinformatics"],"use":null,"popcon":"5 / 2 / 37","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_19790","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"bio-eagle","distribution":"debian","release":"sid","component":"main","version":"2.4.1","source":"bio-eagle","homepage":"https://data.broadinstitute.org/alkesgroup/Eagle/","description":"Haplotype phasing within a genotyped cohort or using a phased reference panel","long_description":" Eagle estimates haplotype phase either within a genotyped cohort or using a\n phased reference panel. The basic idea of the Eagle1 algorithm is to harness\n identity-by-descent among distant relatives—which is pervasive at very large\n sample sizes but rare among smaller numbers of samples—to rapidly call phase\n using a fast scoring approach. In contrast, the Eagle2 algorithm analyzes a\n full probabilistic model similar to the diploid Li-Stephens model used by\n previous HMM-based methods.\n .\n Please note: The executable was renamed to bio-eagle because of a name clash.\n Please read more about this in /usr/share/doc/bio-eagle/README.Debian.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"10 / 2 / 56","doi":"10.1038/ng.3571","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_14099","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"mozilla-biofox","distribution":"debian","release":"wheezy","component":"main","version":"1.6","source":"biofox","homepage":"https://addons.mozilla.org/fr/firefox/addon/300","description":"extension of bioinformatics agents to Iceape and Iceweasel browsers","long_description":" Code bioFOX aims at implementing various bioinformatics agents as an extension\n on the Iceape and Iceweasel browsers. Analysis of your favorite gene(s)\n usually require(s) retrieving it from a database like NCBI or Swiss-Prot and\n then performing one or more tasks including but not limited to:\n .\n  * Translation of a nucleotide sequence;\n  * Blast search (eg. blastn, blastp etc.) of the desired nucleotide/protein\n    sequence;\n  * Calculation of properties (like PI, charge, molecular weight, AT/GC content\n    etc.) of a protein/nucleotide sequence;\n  * Conversion between formats (Genbank, Fasta, Swiss-Prot etc.);\n  * Prediction of sequence for sub-cellular localization (PREDOTAR, TargetP,\n    pSORT etc).\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 0 / 19","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libbiojava4-java","distribution":"debian","release":"sid","component":"main","version":"4.2.12","source":"biojava4-live","homepage":"http://www.biojava.org","description":"Java API to biological data and applications (default version)","long_description":" BioJava is an open-source project dedicated to providing a Java framework\n for processing biological data. It includes objects for manipulating\n sequences, file parsers, server support, access to BioSQL\n and Ensembl databases, and powerful analysis and statistical routines\n including a dynamic programming agentkit.\n .\n BioJava is provided by a vibrant community which meets annually at\n the Bioinformatics Open Source Conference (BOSC) that traditionally\n accompanies the Intelligent Systems in Molecular Biology (ISMB)\n meeting. Much like BioPerl, the employment of this library is valuable\n for everybody active in the field because of the many tricks of the\n trade one learns just by communicating on the mailing list.\n .\n This is a wrapper package which should enable smooth upgrades to new\n versions.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 30","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libbiojava-java","distribution":"debian","release":"sid","component":"main","version":"1.7.1","source":"biojava-live","homepage":"http://www.biojava.org","description":"Java API to biological data and applications (default version)","long_description":" BioJava is an open-source project dedicated to providing a Java framework\n for processing biological data. It includes objects for manipulating\n sequences, file parsers, DAS client and server support, access to BioSQL\n and Ensembl databases, and powerful analysis and statistical routines\n including a dynamic programming agentkit.\n .\n BioJava is provided by a vibrant community which meets annually at\n the Bioinformatics Open Source Conference (BOSC) that traditionally\n accompanies the Intelligent Systems in Molecular Biology (ISMB)\n meeting. Much like BioPerl, the employment of this library is valuable\n for everybody active in the field because of the many tricks of the\n trade one learns just by communicating on the mailing list.\n .\n This is a wrapper package which should enable smooth upgrades to new\n versions.\n","interface":null,"biology":null,"fields":["biology","biology:bioinformatics"],"use":null,"popcon":"17 / 19 / 119","doi":"10.1093/bioinformatics/btn397","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python3-biomaj3","distribution":"debian","release":"sid","component":"main","version":"3.1.6","source":"biomaj3","homepage":"https://github.com/genouest/biomaj","description":"BioMAJ workflow management library","long_description":" BioMAJ downloads remote data banks, checks their status and applies\n transformation workflows, with consistent state, to provide ready-to-use\n data for biologists and bioinformaticians. For example, it can transform\n original FASTA files into BLAST indexes. It is very flexible and its\n post-processing facilities can be extended very easily.\n .\n BioMAJ3 is a rewrite of BioMAJ v1.x, see online documentation for migration.\n .\n This package contains the library to manage the workflow update in BioMAJ3,\n it is managed via python3-biomaj3-daemon (for microservices remote operations)\n or biomaj3-cli (local or remote) packages\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 8 / 19","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"BioMAJ","OMICagents":"OMICS_21717","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python3-biomaj3-daemon","distribution":"debian","release":"sid","component":"main","version":"3.0.17","source":"biomaj3-daemon","homepage":"https://github.com/genouest/biomaj-daemon","description":"BioMAJ daemon library","long_description":" BioMAJ downloads remote data banks, checks their status and applies\n transformation workflows, with consistent state, to provide ready-to-use\n data for biologists and bioinformaticians. For example, it can transform\n original FASTA files into BLAST indexes. It is very flexible and its\n post-processing facilities can be extended very easily.\n .\n BioMAJ3 is a rewrite of BioMAJ v1.x, see online documentation for migration.\n .\n This package contains the library and microservice to manage daemon and CLI\n in BioMAJ3\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 7 / 13","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"biomaj","OMICagents":"OMICS_21717","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"bioperl","distribution":"debian","release":"sid","component":"main","version":"1.7.4","source":"bioperl","homepage":"http://www.bioperl.org/","description":"Perl agents for computational molecular biology","long_description":" The Bioperl project is a coordinated effort to collect computational methods\n routinely used in bioinformatics into a set of standard CPAN-style,\n well-documented, and freely available Perl modules. It is well-accepted\n throughout the community and used in many high-profile projects, e.g.,\n Ensembl.\n .\n The recommended packages are needed to run some of the included\n binaries, for a detailed explanation including the specific Perl\n modules please see README.Debian.\n .\n The suggested package enhances the manual pages.\n","interface":null,"biology":null,"fields":["biology","biology:bioinformatics"],"use":null,"popcon":"80 / 33 / 908","doi":"10.1101/gr.361602","topics":null,"edam_scopes":null,"bio.agents":"bioperl","OMICagents":"OMICS_04849","SEQwiki":null,"SciCrunch":{"source":"bioperl","name":"SciCrunch","entry":"SCR_002989"},"RRID":null},{"package":"bioperl-run","distribution":"debian","release":"sid","component":"main","version":"1.7.3","source":"bioperl-run","homepage":"https://metacpan.org/release/BioPerl-Run","description":"BioPerl wrappers: scripts","long_description":" Contains scripts from the BioPerl-Run package. This package will also install\n all wrappable applications packaged in Debian. The ones that are not Free are\n \"Suggested\" by this package.\n","interface":["commandline"],"biology":null,"fields":["biology","biology:bioinformatics"],"use":null,"popcon":"14 / 32 / 904","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"bio-rainbow","distribution":"debian","release":"sid","component":"main","version":"2.0.4","source":"bio-rainbow","homepage":"http://sourceforge.net/projects/bio-rainbow/","description":"clustering and assembling short reads for bioinformatics","long_description":" Efficient agent for clustering and assembling short reads,\n especially for RAD.\n .\n Rainbow is developed to provide an ultra-fast and memory-efficient\n solution to clustering and assembling short reads produced by RAD-seq.\n First, Rainbow clusters reads using a spaced seed method. Then, Rainbow\n implements a heterozygote calling like strategy to divide potential\n groups into haplotypes in a top-down manner. long a guided tree, it\n iteratively merges sibling leaves in a bottom-up manner if they are\n similar enough. Here, the similarity is defined by comparing the 2nd\n reads of a RAD segment. This approach tries to collapse heterozygote\n while discriminate repetitive sequences. At last, Rainbow uses a greedy\n algorithm to locally assemble merged reads into contigs. Rainbow not\n only outputs the optimal but also suboptimal assembly results. Based on\n simulation and a real guppy RAD-seq data, it is shown that Rainbow is\n more competent than the other agents in dealing with RAD-seq data.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 3 / 61","doi":"10.1093/bioinformatics/bts482","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_03722","SEQwiki":null,"SciCrunch":{"source":"bio-rainbow","name":"SciCrunch","entry":"SCR_002724"},"RRID":null},{"package":"biosquid","distribution":"debian","release":"sid","component":"main","version":"1.9g+cvs20050121","source":"biosquid","homepage":"http://eddylab.org/software.html","description":"utilities for biological sequence analysis","long_description":" SQUID is a library of C code functions for sequence analysis. It also\n includes a number of small utility programs to convert, show statistics,\n manipulate and do other functions on sequence files.\n .\n The original name of the package is \"squid\", but since there is already\n a squid on the archive (a proxy cache), it was renamed to \"biosquid\".\n .\n This package contains some agents to demonstrate the features of the\n SQUID library.\n","interface":["commandline"],"biology":null,"fields":["biology","biology:bioinformatics"],"use":["comparing","converting","editing"],"popcon":"18 / 25 / 696","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_19791","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"biosyntax","distribution":"debian","release":"sid","component":"main","version":"1.0.0b","source":"biosyntax","homepage":"https://biosyntax.org/","description":"Syntax Highlighting for Computational Biology (metapackage)","long_description":" Syntax highlighting for computational biology to bring you intuitively close\n to your data. BioSyntax supports .sam, .flagstat, .vcf, .fasta, .fastq, .faidx\n , .clustal, .pdb, .gtf, .bed files & more.\n .\n This is a metapackage depending on all bioSyntax plugins.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 15","doi":"10.1186/s12859-018-2315-y","topics":null,"edam_scopes":null,"bio.agents":"bioSyntax","OMICagents":"OMICS_25594","SEQwiki":null,"SciCrunch":{"source":"biosyntax","name":"SciCrunch","entry":"SCR_016207"},"RRID":null},{"package":"bio-tradis","distribution":"debian","release":"sid","component":"main","version":"1.4.1","source":"bio-tradis","homepage":"https://github.com/sanger-pathogens/Bio-Tradis","description":"analyse the output from TraDIS analyses of genomic sequences","long_description":" Bio-Tradis contains a set of agents to analyse the output from\n TraDIS analyses.\n .\n The Bio-Tradis analysis pipeline is implemented as an extensible Perl\n library which can either be used as is, or as a basis for the\n development of more advanced analysis agents.\n .\n Please note: You need to manually install BioConductor Edger which can\n not be distributed by Debian in recent version since it is using\n non-distributable code locfit.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 0 / 17","doi":"10.1093/bioinformatics/btw022","topics":null,"edam_scopes":null,"bio.agents":"Bio-Tradis","OMICagents":"OMICS_11083","SEQwiki":null,"SciCrunch":{"source":"bio-tradis","name":"SciCrunch","entry":"SCR_015993"},"RRID":null},{"package":"bitseq","distribution":"debian","release":"sid","component":"main","version":"0.7.5","source":"bitseq","homepage":"https://github.com/BitSeq/BitSeq","description":"Bayesian Inference of Transcripts from Sequencing Data","long_description":" BitSeq is an application for inferring expression levels of individual\n transcripts from sequencing (RNA-Seq) data and estimating differential\n expression (DE) between conditions. An advantage of this approach is the\n ability to account for both technical uncertainty and intrinsic biological\n variance in order to avoid false DE calls. The technical contribution to the\n uncertainty comes both from finite read-depth and the possibly ambiguous\n mapping of reads to multiple transcripts.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 0 / 18","doi":"10.1093/bioinformatics/btv483","topics":null,"edam_scopes":null,"bio.agents":"bitseq","OMICagents":"OMICS_01269","SEQwiki":null,"SciCrunch":{"source":"bitseq","name":"SciCrunch","entry":"SCR_009904"},"RRID":null},{"package":"blasr","distribution":"debian","release":"sid","component":"main","version":"5.3.2","source":"blasr","homepage":"https://github.com/PacificBiosciences/blasr","description":"mapping single-molecule sequencing reads","long_description":" Basic local alignment with successive refinement (BLASR) is a method\n for mapping single-molecule sequencing reads against a reference genome.\n Such reads are thousands of bases long, with divergence between them\n and the genome being dominated by insertion and deletion error.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 5 / 58","doi":"10.1186/1471-2105-13-23","topics":null,"edam_scopes":null,"bio.agents":"Blasr","OMICagents":"OMICS_05134","SEQwiki":null,"SciCrunch":{"source":"blasr","name":"SciCrunch","entry":"SCR_000764"},"RRID":null},{"package":"blat","distribution":"prospective","release":"vcs","component":"non-free","version":"35","source":"blat","homepage":"http://genome.ucsc.edu/cgi-bin/hgBlat","description":"BLAST-Like Alignment Agent","long_description":" BLAT on DNA is designed to quickly find sequences of 95% and greater\n similarity of length 25 bases or more. It may miss more divergent or shorter\n sequence alignments. It will find perfect sequence matches of 25 bases, and\n sometimes find them down to 20 bases. BLAT on proteins finds sequences of 80%\n and greater similarity of length 20 amino acids or more. In practice DNA BLAT\n works well on primates, and protein blat on land vertebrates.\n .\n BLAT is not BLAST. DNA BLAT works by keeping an index of the entire genome in\n memory. The index consists of all non-overlapping 11-mers except for those\n heavily involved in repeats. The index takes up a bit less than a gigabyte of\n RAM. The genome itself is not kept in memory, allowing BLAT to deliver high\n performance on a reasonably priced Linux box. The index is used to find areas\n of probable homology, which are then loaded into memory for a detailed\n alignment. Protein BLAT works in a similar manner, except with 4-mers rather\n than 11-mers. The protein index takes a little more than 2 gigabytes.","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 1","doi":"10.1101/gr.229202","topics":null,"edam_scopes":null,"bio.agents":"blat","OMICagents":"OMICS_01434","SEQwiki":null,"SciCrunch":{"source":"blat","name":"SciCrunch","entry":"SCR_011919"},"RRID":null},{"package":"blimps-utils","distribution":"debian","release":"sid","component":"non-free","version":"3.9+ds","source":"blimps","homepage":"https://web.archive.org/web/20170606235903/http://blocks.fhcrc.org/blocks/uploads/blimps/","description":"blocks database improved searcher","long_description":" BLIMPS (BLocks IMProved Searcher) is a searching agent that scores\n a protein sequence against blocks or a block against sequences.\n .\n This package contains the binaries.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 1 / 11","doi":"10.1002/(SICI)1522-2683(20000501)21:9<1700::AID-ELPS1700>3.0.CO;2-V","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_21301","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"blobology","distribution":"prospective","release":"vcs","component":"main","version":"0.0+20151216","source":"blobology","homepage":"https://blobagents.readme.io/","description":"agent set for the visualisation of genome assemblies","long_description":" Agents for making blobplots or Taxon-Annotated-GC-Coverage plots\n (TAGC plots) to visualise the contents of genome assembly data sets\n as a QC step.\n .\n blobagents consist of a series of agents that can be used to\n  * collate information associated with an assembly file, such as:\n     - sequence ID\n     - sequence length\n     - GC-content\n     - coverage information\n     - taxonomy information (sequence similarity search hits)\n     - user-defined categories\n  * visualise information using blobplots, covplots and/or readcovplots.\n  * extract information into human- and computer-readable files\n  * produce paper-ready figures","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.3389/fgene.2013.00237","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"bolt-lmm","distribution":"debian","release":"sid","component":"main","version":"2.3.2","source":"bolt-lmm","homepage":"https://data.broadinstitute.org/alkesgroup/BOLT-LMM/","description":"Efficient large cohorts genome-wide Bayesian mixed-model association testing","long_description":" The BOLT-LMM software package currently consists of two main algorithms, the\n BOLT-LMM algorithm for mixed model association testing, and the BOLT-REML\n algorithm for variance components analysis (i.e., partitioning of\n SNP-heritability and estimation of genetic correlations).\n .\n The BOLT-LMM algorithm computes statistics for testing association between\n phenotype and genotypes using a linear mixed model. By default, BOLT-LMM\n assumes a Bayesian mixture-of-normals prior for the random effect attributed\n to SNPs other than the one being tested. This model generalizes the standard\n infinitesimal mixed model used by previous mixed model association methods,\n providing an opportunity for increased power to detect associations while\n controlling false positives. Additionally, BOLT-LMM applies algorithmic\n advances to compute mixed model association statistics much faster than\n eigendecomposition-based methods, both when using the Bayesian mixture model\n and when specialized to standard mixed model association.\n .\n The BOLT-REML algorithm estimates heritability explained by genotyped SNPs and\n genetic correlations among multiple traits measured on the same set of\n individuals. BOLT-REML applies variance components analysis to perform these\n tasks, supporting both multi-component modeling to partition SNP-heritability\n and multi-trait modeling to estimate correlations. BOLT-REML applies a Monte\n Carlo algorithm that is much faster than eigendecomposition-based methods for\n variance components analysis at large sample sizes.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 0 / 16","doi":"10.1038/ng.3190","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_13504","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"bowtie","distribution":"debian","release":"sid","component":"main","version":"1.2.2","source":"bowtie","homepage":"http://bowtie-bio.sourceforge.net/","description":"Ultrafast memory-efficient short read aligner","long_description":" This package addresses the problem to interpret the results from the\n latest (2010) DNA sequencing technologies. Those will yield fairly\n short stretches and those cannot be interpreted directly. It is the\n challenge for agents like Bowtie to give a chromosomal location to the\n short stretches of DNA sequenced per run.\n .\n Bowtie aligns short DNA sequences (reads) to the human genome at a rate\n of over 25 million 35-bp reads per hour. Bowtie indexes the genome with\n a Burrows-Wheeler index to keep its memory footprint small: typically\n about 2.2 GB for the human genome (2.9 GB for paired-end).\n","interface":["commandline"],"biology":["nuceleic-acids"],"fields":["biology:bioinformatics"],"use":["analysing","comparing"],"popcon":"22 / 9 / 416","doi":"10.1186/gb-2009-10-3-r25","topics":["Genomics"],"edam_scopes":[{"name": "summary", "function": ["Genome indexing", "Sequence alignment generation"]}, {"name": "bowtie-build", "outputs": [{"data": "Genome index", "format": ["Bowtie index format EBWT", "Bowtie long index format EBTWL"]}], "function": "Genome indexing (Burrows-Wheeler)"}, {"name": "bowtie-inspect", "inputs": [{"data": "Genome index", "format": ["Bowtie index format EBWT", "Bowtie long index format EBTWL"]}], "outputs": [{"data": "Nucleic acid sequence (raw)", "format": ["FASTA", "plain text format (unformatted)"]}], "function": ["Sequence retrieval", "Metadata retrieval", "Data index analysis"]}, {"name": "bowtie", "inputs": [{"data": "Genome index"}, {"data": "Nucleic acid sequence (raw)", "format": ["plain text format (unformatted)", "FASTA", "FASTQ"]}], "outputs": [{"data": "Sequence alignment (nucleic acid)"}, {"data": "Sequence alignment report", "format": ["SAM", "Bowtie alignment report format"]}], "function": ["Sequence database search (by sequence using word-based methods)", "Sequence alignment generation"]}],"bio.agents":"bowtie","OMICagents":"OMICS_00653","SEQwiki":{"source":"bowtie","name":"SEQwiki","entry":"http://seqanswers.com/wiki/Bowtie"},"SciCrunch":{"source":"bowtie","name":"SciCrunch","entry":"SCR_005476"},"RRID":null},{"package":"bowtie2","distribution":"debian","release":"sid","component":"main","version":"2.3.4.3","source":"bowtie2","homepage":"http://bowtie-bio.sourceforge.net/bowtie2","description":"ultrafast memory-efficient short read aligner","long_description":" is an ultrafast and memory-efficient agent for aligning sequencing reads\n to long reference sequences. It is particularly good at aligning reads\n of about 50 up to 100s or 1,000s of characters, and particularly good\n at aligning to relatively long (e.g. mammalian) genomes.\n .\n Bowtie 2 indexes the genome with an FM Index to keep its memory footprint\n small: for the human genome, its memory footprint is typically\n around 3.2 GB. Bowtie 2 supports gapped, local, and paired-end alignment modes\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"28 / 10 / 334","doi":"10.1038/nmeth.1923","topics":["Genomics"],"edam_scopes":[{"name": "summary", "function": ["Genome indexing", "Sequence alignment"]}, {"name": "bowtie-build", "function": ["Genome indexing"]}, {"name": "bowtie-inspect", "function": ["Sequence retrieval", "Metadata retrieval", "Data index analysis"]}, {"name": "bowtie", "function": ["Sequence database search (by sequence using word-based methods)", "Sequence alignment generation"]}],"bio.agents":"bowtie2","OMICagents":"OMICS_31633","SEQwiki":{"source":"bowtie2","name":"SEQwiki","entry":"Bowtie"},"SciCrunch":{"source":"bowtie2","name":"SciCrunch","entry":"SCR_005476"},"RRID":null},{"package":"boxshade","distribution":"debian","release":"sid","component":"main","version":"3.3.1","source":"boxshade","homepage":"http://www.ch.embnet.org/software/BOX_form.html","description":"Pretty-printing of multiple sequence alignments","long_description":" Boxshade is a program for creating good looking printouts from\n multiple-aligned protein or DNA sequences. The program does not perform\n the alignment by itself and requires as input a file that was created\n by a multiple alignment program or manually edited with respective agents.\n .\n Boxshade reads multiple-aligned sequences from either PILEUP-MSF,\n CLUSTAL-ALN, MALIGNED-data and ESEE-save files (limited to a maximum\n of 150 sequences with up to 10000 elements each).  Various kinds of\n shading can be applied to identical/similar residues. Output is written\n to screen or to a file in the following formats: ANSI/VT100, PS/EPS,\n RTF, HPGL, ReGIS, LJ250-printer, ASCII, xFIG, PICT, HTML\n","interface":["commandline"],"biology":["format:aln","nuceleic-acids","peptidic"],"fields":["biology","biology:bioinformatics"],"use":["typesetting"],"popcon":"9 / 3 / 142","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"BoxShade","OMICagents":"OMICS_19792","SEQwiki":null,"SciCrunch":{"source":"boxshade","name":"SciCrunch","entry":"SCR_007165"},"RRID":null},{"package":"bppphyview","distribution":"debian","release":"sid","component":"main","version":"0.6.1","source":"bppphyview","homepage":"http://biopp.univ-montp2.fr/wiki/index.php/Main_Page","description":"Bio++ Phylogenetic Viewer","long_description":" A phylogenetic tree editor developed using Bio++ and Qt.  Phyview allows one\n to visualize, edit, print and output phylogenetic trees and associated data.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 1 / 24","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"bppsuite","distribution":"debian","release":"sid","component":"main","version":"2.4.1","source":"bppsuite","homepage":"http://biopp.univ-montp2.fr/wiki/index.php/Main_Page","description":"Bio++ program suite","long_description":" The Bio++ Program Suite is a package of programs using the Bio++\n libraries and dedicated to Phylogenetics and Molecular Evolution.  All\n programs are independent, but can be combined to perform rather complex\n analyses.  These programs use the interface helper agents of the\n libraries, and hence share the same syntax.  They also have several\n options in common, which may also be shared by third-party software.\n .\n The following programs are included:\n  - BppML for maximum likelihood analysis,\n  - BppSeqGen for sequences simulation,\n  - BppAncestor for ancestral states reconstruction,\n  - BppDist for distance methods,\n  - BppPars for parsimony analysis,\n  - BppSeqMan for file conversion and sequence manipulation,\n  - BppConsense for building consensus tree and computing\n    bootstrap values,\n  - BppReRoot for tree rerooting.\n  - BppTreeDraw for tree drawing.\n  - BppAlnScore for comparing alignments and computing alignment scores.\n  - BppMixedLikelihoods for computing site per site likelihoods of\n    components of mixture models.\n  - BppPopGen for population genetics analyses.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 1 / 24","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_15696","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"braker","distribution":"prospective","release":"vcs","component":"contrib","version":"2.1.2","source":"braker","homepage":"https://github.com/Gaius-Augustus/BRAKER","description":"annotating protein coding genes in genomes.","long_description":" Genomic DNA controls the behaviour of biological cells. Understanding it, \n and its variations, facilitates the molecular pathology of diseases. \n braker.pl can either run with a genome sequence, only; or with additional \n alignments for short transcriptome reads against the genome; or with \n additional protein sequences of closely related species; or with evidence \n from the alignment of protein sequences of distantly related species.\n The package provides the means to interpret genomic sequences in FASTA format\n from fungi, plants and animals.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1093/bioinformatics/btv661","topics":null,"edam_scopes":null,"bio.agents":"BRAKER1","OMICagents":"OMICS_10582","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"brig","distribution":"debian","release":"sid","component":"main","version":"0.95","source":"brig","homepage":"http://sourceforge.net/projects/brig/","description":"BLAST Ring Image Generator","long_description":" BRIG can display circular comparisons between a large number of genomes,\n with a focus on handling genome assembly data.\n  * Images show similarity between a central reference sequence and other\n    sequences as concentric rings.\n  * BRIG will perform all BLAST comparisons and file parsing automatically\n    via a simple GUI.\n  * Contig boundaries and read coverage can be displayed for draft genomes;\n    customized graphs and annotations can be displayed.\n  * Using a user-defined set of genes as input, BRIG can display gene\n    presence, absence, truncation or sequence variation in a set of\n    complete genomes, draft genomes or even raw, unassembled sequence data.\n  * BRIG also accepts SAM-formatted read-mapping files enabling genomic\n    regions present in unassembled sequence data from multiple samples to\n    be compared simultaneously\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 5 / 62","doi":"10.1186/1471-2164-12-402","topics":null,"edam_scopes":null,"bio.agents":"brig","OMICagents":"OMICS_00929","SEQwiki":null,"SciCrunch":{"source":"brig","name":"SciCrunch","entry":"SCR_007802"},"RRID":null},{"package":"bwa","distribution":"debian","release":"sid","component":"main","version":"0.7.17","source":"bwa","homepage":"http://bio-bwa.sourceforge.net/","description":"Burrows-Wheeler Aligner","long_description":" BWA is a software package for mapping low-divergent sequences against\n a large reference genome, such as the human genome. It consists of\n three algorithms: BWA-backtrack, BWA-SW and BWA-MEM. The first\n algorithm is designed for Illumina sequence reads up to 100bp, while\n the rest two for longer sequences ranged from 70bp to 1Mbp. BWA-MEM\n and BWA-SW share similar features such as long-read support and split\n alignment, but BWA-MEM, which is the latest, is generally recommended\n for high-quality queries as it is faster and more accurate. BWA-MEM\n also has better performance than BWA-backtrack for 70-100bp Illumina\n reads.\n","interface":["commandline","text-mode"],"biology":["nuceleic-acids","peptidic"],"fields":["biology","biology:bioinformatics"],"use":["analysing","comparing"],"popcon":"30 / 8 / 386","doi":"10.1093/bioinformatics/btp324","topics":null,"edam_scopes":null,"bio.agents":"BWA","OMICagents":"OMICS_00654","SEQwiki":{"source":"bwa","name":"SEQwiki","entry":"http://seqanswers.com/wiki/BWA"},"SciCrunch":{"source":"bwa","name":"SciCrunch","entry":"SCR_010910"},"RRID":null},{"package":"cafagents","distribution":"debian","release":"experimental","component":"non-free","version":"2.0.2","source":"cafagents","homepage":"https://www.sanger.ac.uk/science/agents/caf","description":"maintenance of DNA sequence assemblies","long_description":" This package contains code from different authors that allow sequence\n assemblies to be converted into formats such as CAF (Common Assembly\n Format) or GAP4.\n .\n CAF is a text format for describing sequence assemblies. It\n is acedb-compliant and is an extension of the ace-file format used\n earlier, but with support for base quality measures and a more extensive\n description of the Sequence data. CAF was designed during the Sanger\n sequencing era. Its modern-day successor is the SAM format, or its\n binary equivalents BAM and CRAM.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":"CAFTOOLS","OMICagents":"OMICS_24974","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"cain","distribution":"debian","release":"sid","component":"main","version":"1.10","source":"cain","homepage":"http://cain.sourceforge.net","description":"simulations of chemical reactions","long_description":" Cain performs stochastic and deterministic simulations of chemical reactions.\n It can spawn multiple simulation processes to utilize multi-core computers.\n It stores models, methods, and simulation output (populations and reaction\n counts) in an XML format. In addition, SBML models can be imported and\n exported. The models and methods can be read from input files or edited\n within the program.\n .\n The GUI (Graphical User Interface) is written in Python and uses the wxPython\n agentkit. Most of the solvers are implemented as command line executables,\n written in C++, which are driven by Cain. This makes it easy to launch batch\n jobs. It also simplifies the process of adding new solvers. Cain offers a\n variety of solvers:\n  * Gillespie's direct method.\n  * Gillespie's first reaction method.\n  * Gibson and Bruck's next reaction method.\n  * Tau-leaping.\n  * Hybrid direct/tau-leaping.\n  * ODE integration.\n .\n This package provides the architecture independent files for cain\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 3 / 54","doi":"10.1109/TCBB.2009.47","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_19796","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"canu","distribution":"debian","release":"sid","component":"main","version":"1.8","source":"canu","homepage":"http://canu.readthedocs.org/en/latest/","description":"single molecule sequence assembler for genomes","long_description":" Canu is a fork of the Celera Assembler, designed for high-noise\n single-molecule sequencing (such as the PacBio RS II or Oxford\n Nanopore MinION).\n .\n Canu is a hierarchical assembly pipeline which runs in four steps:\n .\n  * Detect overlaps in high-noise sequences using MHAP\n  * Generate corrected sequence consensus\n  * Trim corrected sequences\n  * Assemble trimmed corrected sequences\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 0 / 18","doi":"10.1101/071282","topics":null,"edam_scopes":null,"bio.agents":"CANU","OMICagents":"OMICS_14592","SEQwiki":null,"SciCrunch":{"source":"canu","name":"SciCrunch","entry":"SCR_015880"},"RRID":null},{"package":"card-rgi","distribution":"prospective","release":"vcs","component":"main","version":"4.2.2","source":"card-rgi","homepage":"https://card.mcmaster.ca/","description":"analysis of genome sequences using the Resistance Gene Identifier","long_description":" The Comprehensive Antibiotic Resistance Database (\"CARD\") provides data,\n models, and algorithms relating to the molecular basis of antimicrobial\n resistance. The CARD provides curated reference sequences and SNPs\n organized via the Antibiotic Resistance Ontology (\"ARO\"). These data can\n be browsed on the website or downloaded in a number of formats. These\n data are additionally associated with detection models, in the form of\n curated homology cut-offs and SNP maps, for prediction of resistome from\n molecular sequences. These models can be downloaded or can be used for\n analysis of genome sequences using the Resistance Gene Identifier\n (\"RGI\"), either online or as a stand-alone agent.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1093/nar/gkw1004","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"cassiopee","distribution":"debian","release":"sid","component":"main","version":"1.0.9","source":"cassiopee","homepage":"https://github.com/osallou/cassiopee-c","description":"index and search agent in genomic sequences","long_description":" Cassiopee index and search library C implementation.\n It is a complete rewrite of the ruby Cassiopee gem. It scans an input\n genomic sequence (dna/rna/protein) and search for a subsequence with\n exact match or allowing substitutions (Hamming distance) and/or\n insertion/deletions.\n .\n This package contains the cassiopee and cassiopeeknife agents.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 5 / 114","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_19794","SEQwiki":null,"SciCrunch":{"source":"cassiopee","name":"SciCrunch","entry":"SCR_016056"},"RRID":null},{"package":"cct","distribution":"debian","release":"sid","component":"main","version":"20170919","source":"cct","homepage":"http://stothard.afns.ualberta.ca/downloads/CCT/","description":"visually comparing bacterial, plasmid, chloroplast, or mitochondrial sequences","long_description":" The CGView Comparison Agent (CCT) is a package for visually comparing\n bacterial, plasmid, chloroplast, or mitochondrial sequences of interest\n to existing genomes or sequence collections. The comparisons are\n conducted using BLAST, and the BLAST results are presented in the form\n of graphical maps that can also show sequence features, gene and protein\n names, COG category assignments, and sequence composition\n characteristics. CCT can generate maps in a variety of sizes, including\n 400 Megapixel maps suitable for posters. Comparisons can be conducted\n within a particular species or genus, or all available genomes can be\n used. The entire map creation process, from downloading sequences to\n redrawing zoomed maps, can be completed easily using scripts included\n with the CCT. User-defined features or analysis results can be included\n on maps, and maps can be extensively customized. To simplify program\n setup, a CCT virtual machine that includes all dependencies preinstalled\n is available. Detailed tutorials illustrating the use of CCT are\n included with the CCT documentation.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 6 / 13","doi":"10.1186/1471-2164-13-202","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_19852","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"cdbfasta","distribution":"debian","release":"sid","component":"main","version":"0.99-20100722","source":"cdbfasta","homepage":"http://cdbfasta.sourceforge.net/","description":"Constant DataBase indexing and retrieval agents for multi-FASTA files","long_description":" CDB (Constant DataBase) can be used for creating indices for quick\n retrieval of any particular sequences from large multi-FASTA files.\n It has the option to compress data records in order to save space.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"10 / 3 / 126","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_19793","SEQwiki":null,"SciCrunch":{"source":"cdbfasta","name":"SciCrunch","entry":"SCR_016057"},"RRID":null},{"package":"cd-hit","distribution":"debian","release":"sid","component":"main","version":"4.6.8","source":"cd-hit","homepage":"http://weizhong-lab.ucsd.edu/cd-hit/","description":"suite of programs designed to quickly group sequences","long_description":" cd-hit contains a number of programs designed to quickly group\n sequences. cd-hit groups proteins into clusters that meet a user-defined\n similarity threshold. cd-hit-est is similar to cd-hit, but designed to\n group nucleotide sequences (without introns). cd-hit-est-2d is similar\n to cd-hit-2d but designed to compare two nucleotide datasets. A number\n of other related programs are also in this package. Please see the\n cd-hit user manual, also part of this package, for further information.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"15 / 4 / 133","doi":"10.1093/bioinformatics/btl158","topics":["Genomics"],"edam_scopes":[{"name": "summary", "function": ["Sequence clustering", "Sequence alignment"]}],"bio.agents":null,"OMICagents":"OMICS_05157","SEQwiki":null,"SciCrunch":{"source":"cd-hit","name":"SciCrunch","entry":"SCR_007105"},"RRID":null},{"package":"cellprofiler","distribution":"prospective","release":"vcs","component":"main","version":"3.0.0","source":"cellprofiler","homepage":"http://www.cellprofiler.org","description":"quantitatively measure phenotypes from images automatically","long_description":" CellProfiler is cell image analysis software designed to enable\n biologists without training in computer vision or programming to\n quantitatively measure phenotypes from thousands of images\n automatically.","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 0 / 1","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"centrifuge","distribution":"debian","release":"sid","component":"main","version":"1.0.3","source":"centrifuge","homepage":"https://ccb.jhu.edu/software/centrifuge/","description":"rapid and memory-efficient system for classification of DNA sequences","long_description":" Centrifuge is a very rapid and memory-efficient system for the\n classification of DNA sequences from microbial samples, with better\n sensitivity than and comparable accuracy to other leading systems. The\n system uses a novel indexing scheme based on the Burrows-Wheeler\n transform (BWT) and the Ferragina-Manzini (FM) index, optimized\n specifically for the metagenomic classification problem. Centrifuge\n requires a relatively small index (e.g., 4.3 GB for ~4,100 bacterial\n genomes) yet provides very fast classification speed, allowing it to\n process a typical DNA sequencing run within an hour. Together these\n advances enable timely and accurate analysis of large metagenomics data\n sets on conventional desktop computers.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 2 / 17","doi":"10.1101/gr.210641.116","topics":null,"edam_scopes":null,"bio.agents":"Centrifuge","OMICagents":"OMICS_12217","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"cgview","distribution":"debian","release":"sid","component":"main","version":"0.0.20100111","source":"cgview","homepage":"http://wishart.biology.ualberta.ca/cgview/","description":"Circular Genome Viewer","long_description":" CGView is a Java package for generating high quality, zoomable maps of\n circular genomes. Its primary purpose is to serve as a component of\n sequence annotation pipelines, as a means of generating visual output\n suitable for the web. Feature information and rendering options are\n supplied to the program using an XML file, a tab delimited file, or an\n NCBI ptt file. CGView converts the input into a graphical map (PNG, JPG,\n or Scalable Vector Graphics format), complete with labels, a title,\n legends, and footnotes. In addition to the default full view map, the\n program can generate a series of hyperlinked maps showing expanded\n views. The linked maps can be explored using any web browser, allowing\n rapid genome browsing, and facilitating data sharing. The feature labels\n in maps can be hyperlinked to external resources, allowing CGView maps\n to be integrated with existing web site content or databases.\n .\n In addition to the CGView application, an API is available for\n generating maps from within other Java applications, using the\n cgview package.\n .\n CGView can be used for any of the following:\n  * Bacterial genome visualization and browsing - CGView can be\n    incorporated into bacterial genome annotation pipelines, as a means\n    of generating web content for data visualization and navigation. The\n    PNG and image map content does not require Java applets or special\n    browser plugins.\n  * Genome poster generation - CGView can generate poster-sized images of\n    circular genomes in rasterized image formats or in Scalable Vector\n    Graphics format.\n  * Sequence analysis visualization - CGView can be used to display the\n    output of sequence analysis programs in a circular context.\n .\n CGView features:\n  * Images can be generated in PNG, JPG, or SVG format. See the\n    CGView gallery.\n  * Static or interactive maps can be generated. The interactive maps\n    make use of standard PNG images and HTML image maps. Scalable Vector\n    Graphics output is included in the interactive maps (see example).\n  * The XML input allows complete control over the appearance of the map.\n  * Tab delimited input files and NCBI ptt files can be used as an\n    alternative to the XML format.\n  * The CGView API can be used to incorporate CGView into Java\n    applications.\n  * The CGView applet can be used to incorporate zoomable maps into web\n    pages (see example).\n  * The CGView Server can be used to generate maps online.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 10 / 73","doi":"10.1093/bioinformatics/bti054","topics":null,"edam_scopes":null,"bio.agents":"cgview","OMICagents":"OMICS_00905","SEQwiki":null,"SciCrunch":{"source":"cgview","name":"SciCrunch","entry":"SCR_011779"},"RRID":null},{"package":"changeo","distribution":"debian","release":"sid","component":"main","version":"0.4.5","source":"changeo","homepage":"http://changeo.readthedocs.io","description":"Repertoire clonal assignment agentkit (Python 3)","long_description":" Change-O is a collection of agents for processing the output of V(D)J\n alignment agents, assigning clonal clusters to immunoglobulin (Ig)\n sequences, and reconstructing germline sequences.\n .\n Dramatic improvements in high-throughput sequencing technologies now\n enable large-scale characterization of Ig repertoires, defined as the\n collection of trans-membrane antigen-receptor proteins located on the\n surface of B cells and T cells. Change-O is a suite of utilities to\n facilitate advanced analysis of Ig and TCR sequences following germline\n segment assignment. Change-O handles output from IMGT/HighV-QUEST\n and IgBLAST, and provides a wide variety of clustering methods for\n assigning clonal groups to Ig sequences. Record sorting, grouping,\n and various database manipulation operations are also included.\n .\n This package installs the library for Python 3.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 7 / 13","doi":"10.1093/bioinformatics/btv359","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_08874","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"chromhmm","distribution":"debian","release":"sid","component":"main","version":"1.18","source":"chromhmm","homepage":"http://compbio.mit.edu/ChromHMM/","description":"Chromatin state discovery and characterization","long_description":" ChromHMM is software for learning and characterizing chromatin states.\n ChromHMM can integrate multiple chromatin datasets such as ChIP-seq data of\n various histone modifications to discover de novo the major re-occuring\n combinatorial and spatial patterns of marks. ChromHMM is based on a\n multivariate Hidden Markov Model that explicitly models the presence or\n absence of each chromatin mark. The resulting model can then be used to\n systematically annotate a genome in one or more cell types. By automatically\n computing state enrichments for large-scale functional and annotation datasets\n ChromHMM facilitates the biological characterization of each state. ChromHMM\n also produces files with genome-wide maps of chromatin state annotations that\n can be directly visualized in a genome browser.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 1 / 15","doi":"10.1038/nmeth.1906","topics":null,"edam_scopes":null,"bio.agents":"chromhmm","OMICagents":"OMICS_03490","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"chromimpute","distribution":"debian","release":"sid","component":"main","version":"1.0.3","source":"chromimpute","homepage":"http://www.biolchem.ucla.edu/labs/ernst/ChromImpute/","description":"Large-scale systematic epigenome imputation","long_description":" ChromImpute takes an existing compendium of epigenomic data and uses it to\n predict signal tracks for mark-sample combinations not experimentally mapped\n or to generate a potentially more robust version of data sets that have been\n mapped experimentally. ChromImpute bases its predictions on features from\n signal tracks of other marks that have been mapped in the target sample and\n the target mark in other samples with these features combined using an\n ensemble of regression trees.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 0 / 16","doi":"10.1038/nbt.3157","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_11185","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"cinema","distribution":"prospective","release":"vcs","component":"main","version":"3.0.23","source":"cinema","homepage":"http://aig.cs.man.ac.uk/research/utopia/cinema/cinema.php","description":"multi-sequence alignment editor and viewer","long_description":" It has been designed to be as extensible as possible. Notes of this\n extensibility can be found in \"EXTENDING_CINEMA\", and the\n \"cinema-module\" sub-directory.\n .\n Cinema currently has limited support for various sequence formats,\n although its easy to add new ones. A large number of alignments in the\n appropriate format can be found as part of the align compendium at","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"circlator","distribution":"debian","release":"sid","component":"main","version":"1.5.5","source":"circlator","homepage":"http://sanger-pathogens.github.io/circlator/","description":"circularize genome assemblies","long_description":" Circlator is a agent to automate assembly circularization for bacterial and\n small eukaryotic genomes and produce accurate linear representations of\n circular sequences.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 7 / 51","doi":"10.1186/s13059-015-0849-0","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_09488","SEQwiki":null,"SciCrunch":{"source":"circlator","name":"SciCrunch","entry":"SCR_016058"},"RRID":null},{"package":"circos","distribution":"debian","release":"sid","component":"main","version":"0.69.6","source":"circos","homepage":"http://circos.ca/","description":"plotter for visualizing data","long_description":" Circos visualizes data in a circular layout — ideal for exploring\n relationships between objects or positions, and creating highly\n informative publication-quality graphics.\n .\n This package provides the Circos plotting engine, which is command-line\n driven (like gnuplot) and fully scriptable.\n","interface":null,"biology":null,"fields":["biology:bioinformatics"],"use":["viewing"],"popcon":"17 / 3 / 177","doi":"10.1101/gr.092759.109","topics":null,"edam_scopes":null,"bio.agents":"circos","OMICagents":"OMICS_00932","SEQwiki":null,"SciCrunch":{"source":"circos","name":"SciCrunch","entry":"SCR_011798"},"RRID":null},{"package":"clearcut","distribution":"debian","release":"sid","component":"main","version":"1.0.9","source":"clearcut","homepage":"http://bioinformatics.hungry.com/clearcut/","description":"extremely efficient phylogenetic tree reconstruction","long_description":" Clearcut is the reference implementation for the Relaxed Neighbor Joining (RNJ)\n algorithm by J. Evans, L. Sheneman, and J. Foster from the Initiative\n for Bioinformatics and Evolutionary Studies (IBEST) at the University of\n Idaho.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"11 / 3 / 132","doi":"10.1007/s00239-005-0176-2","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_15083","SEQwiki":null,"SciCrunch":{"source":"clearcut","name":"SciCrunch","entry":"SCR_016059"},"RRID":null},{"package":"clonalframe","distribution":"debian","release":"sid","component":"main","version":"1.2","source":"clonalframe","homepage":"http://www.xavierdidelot.xtreemhost.com/clonalframe.htm","description":"inference of bacterial microevolution using multilocus sequence data","long_description":" ClonalFrame identifies the clonal relationships between the members of\n a sample, while also estimating the chromosomal position of homologous\n recombination events that have disrupted the clonal inheritance.\n .\n ClonalFrame can be applied to any kind of sequence data, from a single\n fragment of DNA to whole genomes. It is well suited for the analysis of\n MLST data, where 7 gene fragments have been sequenced, but becomes\n progressively more powerful as the sequenced regions increase in length\n and number up to whole genomes. However, it requires the sequences to be\n aligned. If you have genomic data that is not aligned, it is recommend to\n use Mauve which produces alignment of whole bacterial genomes in\n exactly the format required for analysis with ClonalFrame.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 3 / 84","doi":"10.1534/genetics.106.063305","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_14623","SEQwiki":null,"SciCrunch":{"source":"clonalframe","name":"SciCrunch","entry":"SCR_016060"},"RRID":null},{"package":"clonalframeml","distribution":"debian","release":"sid","component":"main","version":"1.11","source":"clonalframeml","homepage":"https://github.com/xavierdidelot/ClonalFrameML","description":"Efficient Inference of Recombination in Whole Bacterial Genomes","long_description":" ClonalFrameML is a software package that performs efficient inference of\n recombination in bacterial genomes. ClonalFrameML was created by Xavier\n Didelot and Daniel Wilson. ClonalFrameML can be applied to any type of\n aligned sequence data, but is especially aimed at analysis of whole\n genome sequences. It is able to compare hundreds of whole genomes in a\n matter of hours on a standard Desktop computer. There are three main\n outputs from a run of ClonalFrameML: a phylogeny with branch lengths\n corrected to account for recombination, an estimation of the key\n parameters of the recombination process, and a genomic map of where\n recombination took place for each branch of the phylogeny.\n .\n ClonalFrameML is a maximum likelihood implementation of the Bayesian\n software ClonalFrame which was previously described by Didelot and\n Falush (2007). The recombination model underpinning ClonalFrameML is\n exactly the same as for ClonalFrame, but this new implementation is a\n lot faster, is able to deal with much larger genomic dataset, and does\n not suffer from MCMC convergence issues\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 0 / 18","doi":"10.1371/journal.pcbi.1004041","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_14623","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"clonalorigin","distribution":"debian","release":"sid","component":"main","version":"1.0","source":"clonalorigin","homepage":"https://github.com/xavierdidelot/clonalorigin","description":"inference of homologous recombination in bacteria using whole genome sequences","long_description":" Bacteria, unlike us, can reproduce on their own. They do however have\n mechanisms that transfer DNA between organisms, a process more formally\n known as recombination. The mechanisms by which recombination takes\n place have been studied extensively in the laboratory but much remains\n to be understood concerning how, when and where recombination takes\n place within natural populations of bacteria and how it helps them to\n adapt to new environments. ClonalOrigin performs a comparative analysis\n of the sequences of a sample of bacterial genomes in order to\n reconstruct the recombination events that have taken place in their\n ancestry.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 1 / 19","doi":"10.1534/genetics.110.120121","topics":null,"edam_scopes":null,"bio.agents":"ClonalOrigin","OMICagents":"OMICS_18881","SEQwiki":null,"SciCrunch":{"source":"clonalorigin","name":"SciCrunch","entry":"SCR_016061"},"RRID":null},{"package":"clustalo","distribution":"debian","release":"sid","component":"main","version":"1.2.4","source":"clustalo","homepage":"http://www.clustal.org/omega/","description":"General purpose multiple sequence alignment program for proteins","long_description":" Clustal-Omega is a general purpose multiple sequence alignment (MSA)\n program for dna/rna/proteins. It produces high quality MSAs and is capable of\n handling data-sets of hundreds of thousands of sequences in reasonable\n time.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"26 / 11 / 427","doi":"10.1038/msb.2011.75","topics":["Sequence analysis"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Sequence", "formats": ["EMBL format", "FASTA", "GCG", "GenBank format", "nbrf/pir", "PHYLIP format", "UniProtKB format"]}, {"data": "Gene tree"}], "outputs": [{"data": "Alignment", "formats": ["FASTA-aln", "PHYLIP format", "selex", "Stockholm format", "Vienna local RNA secondary structure format"]}, {"data": "Phylogenetic tree", "formats": ["Phylip tree format"]}], "function": ["Multiple sequence alignment"]}],"bio.agents":null,"OMICagents":"OMICS_00972","SEQwiki":null,"SciCrunch":{"source":"clustalo","name":"SciCrunch","entry":"SCR_001591"},"RRID":null},{"package":"clustalw","distribution":"debian","release":"sid","component":"main","version":"2.1","source":"clustalw","homepage":"http://www.clustal.org/clustal2/","description":"global multiple nucleotide or peptide sequence alignment","long_description":" This program performs an alignment of multiple nucleotide or amino acid\n sequences. It recognizes the format of input sequences and whether the\n sequences are nucleic acid (DNA/RNA) or amino acid (proteins). The output\n format may be selected from in various formats for multiple alignments such as\n Phylip or FASTA. Clustal W is very well accepted.\n .\n The output of Clustal W can be edited manually but preferably with an\n alignment editor like SeaView or within its companion Clustal X. When building\n a model from your alignment, this can be applied for improved database\n searches. The Debian package hmmer creates such in form of an HMM.\n","interface":["commandline","text-mode"],"biology":["format:aln","nuceleic-acids","peptidic"],"fields":["biology","biology:bioinformatics"],"use":["comparing"],"popcon":"29 / 29 / 974","doi":"10.1093/bioinformatics/btm404","topics":null,"edam_scopes":null,"bio.agents":"clustalw","OMICagents":"OMICS_02562","SEQwiki":null,"SciCrunch":{"source":"clustalw","name":"SciCrunch","entry":"SCR_002909"},"RRID":null},{"package":"clustalx","distribution":"debian","release":"sid","component":"main","version":"2.1","source":"clustalx","homepage":"http://www.clustal.org/clustal2/","description":"Multiple alignment of nucleic acid and protein sequences (graphical interface)","long_description":" This package offers a GUI interface for the Clustal multiple sequence\n alignment program. It provides an integrated environment for performing\n multiple sequence- and profile-alignments to analyse the results.\n The sequence alignment is displayed in a window on the screen.\n A versatile coloring scheme has been incorporated to highlight conserved\n features in the alignment. For professional presentations, one should\n use the texshade LaTeX package or boxshade.\n .\n The pull-down menus at the top of the window allow you to select all the\n options required for traditional multiple sequence and profile alignment.\n You can cut-and-paste sequences to change the order of the alignment; you can\n select a subset of sequences to be aligned; you can select a sub-range of the\n alignment to be realigned and inserted back into the original alignment.\n .\n An alignment quality analysis can be performed and low-scoring segments or\n exceptional residues can be highlighted.\n","interface":["x11"],"biology":["format:aln","nuceleic-acids","peptidic"],"fields":["biology","biology:bioinformatics"],"use":["analysing","comparing","viewing"],"popcon":"99 / 9 / 168","doi":"10.1093/bioinformatics/btm404","topics":null,"edam_scopes":null,"bio.agents":"ClutalX","OMICagents":"OMICS_02562","SEQwiki":null,"SciCrunch":{"source":"clustalx","name":"SciCrunch","entry":"SCR_002909"},"RRID":null},{"package":"cluster3","distribution":"debian","release":"sid","component":"non-free","version":"1.57","source":"cluster3","homepage":"http://bonsai.hgc.jp/~mdehoon/software/cluster/","description":"Reimplementation of the Eisen-clustering software","long_description":" The open source clustering software available here contains clustering\n routines that can be used to analyze gene expression data. Routines for\n hierarchical (pairwise simple, complete, average, and centroid linkage)\n clustering, k-means and k-medians clustering, and 2D self-organizing maps\n are included. The routines are available in the form of a C clustering\n library, an extension module to Python, a module to Perl, as well as an\n enhanced version of Cluster, which was originally developed by Michael\n Eisen of Berkeley Lab. The C clustering library and the associated\n extension module for Python was released under the Python license. The\n Perl module was released under the Artistic License. Cluster 3.0 is\n covered by the original Cluster/TreeView license.\n .\n This package only contains the command line and motif gui versions\n of Cluster 3.0.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 5 / 23","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_01571","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"cnvkit","distribution":"debian","release":"sid","component":"main","version":"0.9.5","source":"cnvkit","homepage":"http://cnvkit.readthedocs.org","description":"Copy number variant detection from targeted DNA sequencing","long_description":" A command-line agentkit and Python library for detecting copy number variants\n and alterations genome-wide from targeted DNA sequencing. It is designed for\n use with hybrid capture, including both whole-exome and custom target panels,\n and short-read sequencing platforms such as Illumina and Ion Torrent.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 8 / 14","doi":"10.1371/journal.pcbi.1004873","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_11538","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"codonw","distribution":"debian","release":"sid","component":"main","version":"1.4.4","source":"codonw","homepage":"http://codonw.sourceforge.net","description":"Correspondence Analysis of Codon Usage","long_description":" CodonW is a package for codon usage analysis. It was designed to simplify\n Multivariate Analysis (MVA) of codon usage. The MVA method employed in\n CodonW is correspondence analysis (COA) (the most popular MVA method for\n codon usage analysis). CodonW can generate a COA for codon usage, relative\n synonymous codon usage or amino acid usage. Additional analyses of codon\n usage include investigation of optimal codons, codon and dinucleotide bias,\n and/or base composition. CodonW analyses sequences encoded by genetic codes\n other than the universal code.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 3 / 60","doi":"10.1093/nar/gki242","topics":["Sequence composition, complexity and repeats"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Sequence", "formats": ["FASTA"]}], "outputs": [{"data": "Codon usage data", "formats": ["Textual format"]}], "function": ["Codon usage analysis"]}],"bio.agents":null,"OMICagents":"OMICS_08756","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"ncoils","distribution":"debian","release":"sid","component":"main","version":"2002","source":"coils","homepage":"http://www.russelllab.org/coils/","description":"coiled coil secondary structure prediction","long_description":" The program predicts the coiled coil secondary structure predictions\n from protein sequences. The algorithm was published in\n Lupas, van Dyke & Stock, Predicting coiled coils from\n protein sequences Science, 252, 1162-1164, 1991.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"12 / 5 / 156","doi":"10.1126/science.252.5009.1162","topics":null,"edam_scopes":null,"bio.agents":"ncoils","OMICagents":"OMICS_07850","SEQwiki":null,"SciCrunch":{"source":"coils","name":"SciCrunch","entry":"SCR_008440"},"RRID":null},{"package":"concavity","distribution":"debian","release":"sid","component":"main","version":"0.1","source":"concavity","homepage":"http://compbio.cs.princeton.edu/concavity/","description":"predictor of protein ligand binding sites from structure and conservation","long_description":" ConCavity predicts protein ligand binding sites by combining evolutionary\n sequence conservation and 3D structure.\n .\n ConCavity takes as input a PDB format protein structure and optionally\n files that characterize the evolutionary sequence conservation of the chains\n in the structure file.\n .\n The following result files are produced by default:\n  * Residue ligand binding predictions for each chain (*.scores).\n  * Residue ligand binding predictions in a PDB format file (residue\n    scores placed in the temp. factor field, *_residue.pdb).\n  * Pocket prediction locations in a DX format file (*.dx).\n  * PyMOL script to visualize the predictions (*.pml).\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 3 / 116","doi":"10.1371/journal.pcbi.1000585","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_04161","SEQwiki":null,"SciCrunch":{"source":"concavity","name":"SciCrunch","entry":"SCR_016063"},"RRID":null},{"package":"condetri","distribution":"prospective","release":"vcs","component":"main","version":"2.3","source":"condetri","homepage":"https://github.com/linneas/condetri/","description":"straight-forward trimming of FASTQ sequences","long_description":" This package is a simplistic contribution to the wealth of agents for\n trimming of sequences of current Next-Generation-Sequencing data. It\n was developed in the context of de novo whole-genome assembly.\n .\n The agent reads from the 3'-end and extract reads (or read pairs) of good\n quality. If the reads are paired, the filtering is done pairwise, and\n if one read in a pair has low quality, the remaining read is saved as\n single end.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1371/journal.pone.0026314","topics":["Sequencing"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Sequence", "formats": ["FASTQ"]}], "outputs": [{"data": "Sequence", "formats": ["FASTQ"]}], "function": ["Sequence trimming", "Sequencing quality control"]}],"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libconsensuscore-dev","distribution":"debian","release":"sid","component":"main","version":"1.1.1","source":"consensuscore","homepage":"https://github.com/PacificBiosciences/ConsensusCore","description":"algorithms for PacBio multiple sequence consensus -- development files","long_description":" ConsensusCore is a library of C++ algorithms for Pacific Biosciences\n multiple sequence consensus that powers Quiver (Python) and ConsensusAgents\n (.NET). This library primarily exists as the backend for GenomicConsensus,\n which implements Quiver.\n .\n This package is part of the SMRT Analysis suite.\n It provides the header files and static library.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 34","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python3-pbconsensuscore","distribution":"debian","release":"sid","component":"main","version":"1.1.1","source":"consensuscore","homepage":"https://github.com/PacificBiosciences/ConsensusCore","description":"algorithms for PacBio multiple sequence consensus -- Python 3","long_description":" ConsensusCore is a library of C++ algorithms for Pacific Biosciences\n multiple sequence consensus that powers Quiver (Python) and ConsensusAgents\n (.NET). This library primarily exists as the backend for GenomicConsensus,\n which implements Quiver.\n .\n This package is part of the SMRT Analysis suite.\n It provides the Python3 bindings.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 5 / 12","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python3-consensuscore2","distribution":"prospective","release":"vcs","component":"main","version":"0.13.0+20160719","source":"consensuscore2","homepage":"https://github.com/PacificBiosciences/ConsensusCore2","description":"generate consensus sequences for PacBio data -- Python 3","long_description":" ConsensusCore2 embodies core C++ routines underlying the Arrow HMM\n algorithm for PacBio multi-sequence consensus.  Arrow is the successor\n to the Quiver model---a CRF model that was embodied in the\n ConsensusCore C++ library. Compared to Quiver, the Arrow model is more\n statistically principled and easier and more robust to train.\n .\n This package installs the library for Python 3.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"conservation-code","distribution":"debian","release":"sid","component":"main","version":"20110309.0","source":"conservation-code","homepage":"http://compbio.cs.princeton.edu/conservation/","description":"protein sequence conservation scoring agent","long_description":" This package provides score_conservation(1), a agent to score protein sequence\n conservation.\n .\n The following conservation scoring methods are implemented:\n  * sum of pairs\n  * weighted sum of pairs\n  * Shannon entropy\n  * Shannon entropy with property groupings (Mirny and Shakhnovich 1995,\n    Valdar and Thornton 2001)\n  * relative entropy with property groupings (Williamson 1995)\n  * von Neumann entropy (Caffrey et al 2004)\n  * relative entropy (Samudrala and Wang 2006)\n  * Jensen-Shannon divergence (Capra and Singh 2007)\n .\n A window-based extension that incorporates the estimated conservation of\n sequentially adjacent residues into the score for each column is also given.\n This window approach can be applied to any of the conservation scoring\n methods.\n .\n The program accepts alignments in the CLUSTAL and FASTA formats.\n .\n The sequence-specific output can be used as the conservation input for\n concavity.\n .\n Conservation is highly predictive in identifying catalytic sites and\n residues near bound ligands.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 2 / 107","doi":"10.1093/bioinformatics/btm270","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_06943","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"contrafold","distribution":"prospective","release":"vcs","component":"main","version":"2.02","source":"contrafold","homepage":"http://contra.stanford.edu/contrafold/","description":"CONditional TRAining for RNA Secondary Structure Prediction","long_description":" For several decades, free energy minimization methods have been the dominant\n strategy for single sequence RNA secondary structure prediction. More\n recently, stochastic context-free grammars (SCFGs) have emerged as an\n alternative probabilistic methodology for modeling RNA structure. Unlike\n physics-based methods, which rely on thousands of experimentally-measured\n thermodynamic parameters, SCFGs use fully-automated statistical learning\n algorithms to derive model parameters. Despite this advantage, however,\n probabilistic methods have not replaced free energy minimization methods as\n the agent of choice for secondarystructure prediction, as the accuracies of\n the best current SCFGs have yet to match those of the best physics-based\n models.\n .\n CONTRAfold is a novel secondary structure prediction method based on\n conditional log-linear models (CLLMs), a flexible class of probabilistic\n models which generalize upon SCFGs by using discriminative training and\n feature-rich scoring. By incorporating most of the features found in\n typical thermodynamic models, CONTRAfold achieves the highest single\n sequence prediction accuracies to date, outperforming currently available\n probabilistic and physics-based techniques. Our result thus closes the gap\n between probabilistic and thermodynamic models, demonstrating that\n statistical learning procedures provide an effective alternative to\n empirical measurement of thermodynamic parameters for RNA secondary\n structure prediction.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1093/bioinformatics/btl246","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_03452","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"coot","distribution":"prospective","release":"vcs","component":"main","version":"0.8.9.1","source":"coot","homepage":"http://www2.mrc-lmb.cam.ac.uk/Personal/pemsley/coot/","description":"model building program for macromolecular crystallography","long_description":" Coot is a program for constructing atomic models of macromolecules\n from x-ray diffraction data. Coot displays electron density maps and\n molecular models and allows model manipulations such as idealization,\n refinement, manual rotation/translation, rigid-body fitting, ligand\n search, solvation, mutations, rotamers. Validation agents such as\n Ramachandran and geometry plots are available to the user. This\n package provides a Coot build with embedded Python support.","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 1","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"crac","distribution":"debian","release":"sid","component":"main","version":"2.5.0","source":"crac","homepage":"http://crac.gforge.inria.fr/","description":"integrated RNA-Seq read analysis","long_description":" CRAC is a agent to analyze High Throughput Sequencing (HTS) data in\n comparison to a reference genome. It is intended for transcriptomic\n and genomic sequencing reads. More precisely, with transcriptomic\n reads as input, it predicts point mutations, indels, splice junction,\n and chimeric RNAs (ie, non colinear splice junctions). CRAC can also\n output positions and nature of sequence error that it detects in the\n reads. CRAC uses a genome index. This index must be computed before\n running the read analysis. For this sake, use the command \"crac-index\"\n on your genome files. You can then process the reads using the command\n crac. See the man page of CRAC (help file) by typing \"man crac\". CRAC\n requires large amount of main memory on your computer. For processing\n against the Human genome, say 50 million reads of 100 nucleotide each,\n CRAC requires about 40 gigabytes of main memory. Check whether the\n system of your computing server is equipped with sufficient amount of\n memory before launching an analysis.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 3 / 53","doi":"10.1186/s12920-016-0178-5","topics":null,"edam_scopes":null,"bio.agents":"CRAC","OMICagents":"OMICS_01240","SEQwiki":null,"SciCrunch":{"source":"crac","name":"SciCrunch","entry":"SCR_010652"},"RRID":null},{"package":"crossbow","distribution":"prospective","release":"vcs","component":"main","version":"1.2.0","source":"crossbow","homepage":"http://bowtie-bio.sourceforge.net/crossbow","description":"Genotyping from short reads using cloud computing","long_description":" Crossbow is a scalable software pipeline for whole genome resequencing\n analysis. It combines Bowtie, an ultrafast and memory efficient short read\n aligner, and SoapSNP, an accurate genotyper, within Hadoop to distribute and\n accelerate the computation with many nodes. The pipeline can accurately analyze\n over 35x coverage of a human genome in one day on a 10-node local cluster, or\n in 3 hours for about $100 using a 40-node, 320-core cluster rented from\n Amazon's EC2 utility computing service.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1186/gb-2009-10-11-r134","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"crux-agentkit","distribution":"prospective","release":"vcs","component":"main","version":"3.1","source":"crux","homepage":"http://crux.ms/","description":"agentkit for tandem mass spectrometry analysis","long_description":" The Crux mass spectrometry analysis agentkit is an open source project\n that aims to provide users with a cross-platform suite of analysis agents\n for interpreting protein mass spectrometry data. The agentkit includes\n several search engines for both standard and cross-linked database\n search, as well as a variety of pre- and post-processing engines for\n assigning high-resolution precursor masses to spectra, assigning\n statistical confidence estimates to spectra, peptides and proteins, and\n performing label free quantification.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1021/pr500741y","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"ctdconverter","distribution":"debian","release":"sid","component":"main","version":"2.0","source":"ctdconverter","homepage":"https://github.com/WorkflowConversion/CTDConverter","description":"Convert CTD files into Galaxy agent and CWL CommandLineAgent files","long_description":" Common Agent Descriptors (CTDs) are XML documents that represent the inputs,\n outputs, parameters of command line agents in a platform-independent way.\n .\n CTDConverter, given one or more Common Agent Descriptors (CTD) XML files,\n generates Galaxy agent wrappers and Common Workflow Language (CWL) Command\n Line Agent v1.0 standard descriptions from CTD files.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 2 / 4","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python3-ctdopts","distribution":"debian","release":"sid","component":"main","version":"1.2","source":"ctdopts","homepage":"https://github.com/WorkflowConversion/CTDopts","description":"Gives your Python agents a CTD-compatible interface","long_description":" Common Agent Descriptors (CTDs) are XML documents that represent the inputs,\n outputs, parameters of command line agents in a platform-independent way.\n .\n CTDopts is a module for enabling agents with CTD reading/writing, argument\n parsing, validating and manipulating capabilities.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 2 / 5","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"cufflinks","distribution":"debian","release":"sid","component":"non-free","version":"2.2.1","source":"cufflinks","homepage":"http://cufflinks.cbcb.umd.edu","description":"Transcript assembly, differential expression and regulation for RNA-Seq","long_description":" Cufflinks assembles transcripts, estimates their abundances, and tests for\n differential expression and regulation in RNA-Seq samples. It accepts aligned\n RNA-Seq reads and assembles the alignments into a parsimonious set of\n transcripts. Cufflinks then estimates the relative abundances of these\n transcripts based on how many reads support each one.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 2 / 34","doi":"doi:10.1038/nbt.1621","topics":null,"edam_scopes":null,"bio.agents":"cufflinks","OMICagents":"OMICS_01304","SEQwiki":null,"SciCrunch":{"source":"cufflinks","name":"SciCrunch","entry":"SCR_014597"},"RRID":null},{"package":"cwlagent","distribution":"debian","release":"sid","component":"main","version":"1.0.20181217162649","source":"cwlagent","homepage":"http://www.commonwl.org","description":"Common Workflow Language reference implementation","long_description":" This is the reference implementation of the Common Workflow Language\n standards.\n .\n The CWL open standards are for describing analysis workflows and agents in a\n way that makes them portable and scalable across a variety of software and\n hardware environments, from workstations to cluster, cloud, and high\n performance computing (HPC) environments. CWL is designed to meet the needs of\n data-intensive science, such as Bioinformatics, Medical Imaging, Astronomy,\n Physics, and Chemistry.\n .\n The CWL reference implementation (cwlagent) is intended to be feature complete\n and to provide comprehensive validation of CWL files as well as provide other\n agents related to working with CWL descriptions.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"20 / 22 / 128","doi":"10.6084/m9.figshare.3115156.v2","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_28977","SEQwiki":null,"SciCrunch":{"source":"cwlagent","name":"SciCrunch","entry":"SCR_015528"},"RRID":null},{"package":"cytoscape","distribution":"prospective","release":"vcs","component":"main","version":"3.1.0","source":"cytoscape","homepage":"http://www.cytoscape.org","description":"visualizing molecular interaction networks","long_description":" Cytoscape is an open source bioinformatics software platform for visualizing\n molecular interaction networks and biological pathways and integrating these\n networks with annotations, gene expression profiles and other state data.\n Although Cytoscape was originally designed for biological research, now it is\n a general platform for complex network analysis and visualization.\n Cytoscape core distribution provides a basic set of features for data\n integration and visualization.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python3-cyvcf2","distribution":"debian","release":"sid","component":"main","version":"0.10.8","source":"cyvcf2","homepage":"https://github.com/brentp/cyvcf2","description":"VCF parser based on htslib (Python 3)","long_description":" This modules allows fast parsing of VCF and BCF including region-queries\n with Python. This is essential for efficient analyses of nucleotide\n variation with Python on high-throughput sequencing data.\n .\n cyvcf2 is a cython wrapper around htslib.  Attributes like\n variant.gt_ref_depths return a numpy array directly so they are\n immediately ready for downstream use.\n .\n This package installs the library for Python 3.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 8 / 9","doi":"10.1093/bioinformatics/btx057","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_20006","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"daligner","distribution":"debian","release":"sid","component":"main","version":"1.0+git20180524.fd21879","source":"daligner","homepage":"https://dazzlerblog.wordpress.com","description":"local alignment discovery between long nucleotide sequencing reads","long_description":" These agents permit one to find all significant local alignments between\n reads encoded in a Dazzler database. The assumption is that the reads are\n from a Pacific Biosciences RS II long read sequencer. That is, the reads\n are long and noisy, up to 15% on average.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 4 / 66","doi":"10.1007/978-3-662-44753-6_5","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_08897","SEQwiki":null,"SciCrunch":{"source":"daligner","name":"SciCrunch","entry":"SCR_016066"},"RRID":null},{"package":"dascrubber","distribution":"debian","release":"sid","component":"main","version":"1.1","source":"dascrubber","homepage":"https://dazzlerblog.wordpress.com/","description":"alignment-based scrubbing pipeline for DNA sequencing reads","long_description":" The Dazzler Scrubbing Suite produces a set of edited reads that are guaranteed\n to\n  * be continuous stretches of the underlying genome (i.e. no unremoved\n    adapters and not chimers)\n  * have no very low quality stretches (i.e. the error rate never exceeds some\n    reasonable maximum, 20% or so in the case of Pacbio data).\n Its secondary goal is to do so with the minimum removal of data and splitting\n of reads.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 4 / 58","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_19896","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"datamash","distribution":"debian","release":"sid","component":"main","version":"1.4","source":"datamash","homepage":"https://savannah.gnu.org/projects/datamash/","description":"statistics agent for command-line interface","long_description":" GNU Datamash is a command-line program which performs basic numeric,\n textual and statistical operations on input textual data files. It is\n designed to be portable and reliable, and aid researchers to easily\n automate analysis pipelines, without writing code or even short scripts.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"27 / 26 / 310","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":{"source":"datamash","name":"SciCrunch","entry":"SCR_016067"},"RRID":null},{"package":"dawg","distribution":"debian","release":"sid","component":"main","version":"1.2","source":"dawg","homepage":"https://github.com/reedacartwright/dawg","description":"simulate the evolution of recombinant DNA sequences","long_description":" DNA Assembly with Gaps (Dawg) is an application designed to simulate the\n evolution of recombinant DNA sequences in continuous time based on the robust\n general time reversible model with gamma and invariant rate heterogeneity and\n a novel length-dependent model of gap formation. The application accepts\n phylogenies in Newick format and can return the sequence of any node,\n allowing for the exact evolutionary history to be recorded at the discretion\n of users. Dawg records the gap history of every lineage to produce the true\n alignment in the output. Many options are available to allow users to\n customize their simulations and results.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 3 / 61","doi":"10.1093/bioinformatics/bti1200","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_19895","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"dazzdb","distribution":"debian","release":"sid","component":"main","version":"1.0+git20180908.0bd5e07","source":"dazzdb","homepage":"https://github.com/thegenemyers/DAZZ_DB","description":"manage nucleotide sequencing read data","long_description":" To facilitate the multiple phases of the dazzler assembler, all the read data\n is organized into what is effectively a database of the\n reads and their meta-information. The design goals for this data base\n are as follows:\n  * The database stores the source Pacbio read information in such a\n    way that it can re-create the original input data, thus permitting\n    a user to remove the (effectively redundant) source files. This\n    avoids duplicating the same data, once in the source file and once\n    in the database.\n  * The data base can be built up incrementally, that is new sequence\n    data can be added to the data base over time.\n  * The data base flexibly allows one to store any meta-data desired for\n    reads. This is accomplished with the concept of *tracks* that\n    implementors can add as they need them.\n  * The data is held in a compressed form equivalent to the .dexta and\n    .dexqv files of the data extraction module. Both the .fasta and\n    .quiva information for each read is held in the data base and can be\n    recreated from it. The .quiva information can be added separately and\n    later on if desired.\n  * To facilitate job parallel, cluster operation of the phases of the\n    assembler, the database has a concept of a *current partitioning* in\n    which all the reads that are over a given length and optionally\n    unique to a well, are divided up into *blocks* containing roughly a\n    given number of bases, except possibly the last block which may have\n    a short count. Often programs can be run on blocks or pairs of blocks\n    and each such job is reasonably well balanced as the blocks are all\n    the same size. One must be careful about changing the partition\n    during an assembly as doing so can void the structural validity of\n    any interim block-based results.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 4 / 64","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"dazzle","distribution":"prospective","release":"vcs","component":"main","version":"1.01r3643","source":"dazzle","homepage":"http://biojava.org/wiki/Dazzle/","description":"Java-based DAS server","long_description":" Dazzle is a general purpose server for the Distributed Annotation System\n (DAS) protocol. It is implemented as a Java servlet, using the BioJava\n APIs. Dazzle is a modular system which uses small \"datasource\" plugins to\n provide access to a range of databases. Several general-purpose plugins\n are included in the package, and it it straightforward to develop new\n plugins to connect to your own databases.\n .\n Information on DAS is available from http://www.biodas.org/","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"science-workflow","distribution":"debian","release":"sid","component":"main","version":"1.9","source":"debian-science","homepage":"https://wiki.debian.org/DebianScience/","description":"workflow management systems useful for scientific research","long_description":" This task lists some packages providing workflow management\n systems useful for scientific research.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 10 / 28","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"deepbinner","distribution":"prospective","release":"vcs","component":"main","version":"0.2.0","source":"deepbinner","homepage":"https://github.com/rrwick/Deepbinner","description":"demultiplexing barcoded Oxford Nanopore sequencing reads","long_description":" Deepbinner is a agent for demultiplexing barcoded Oxford Nanopore\n sequencing reads. It does this with a deep convolutional neural network\n classifier, using many of the architectural advances that have proven\n successful in image classification. Unlike other demultiplexers (e.g.\n Albacore and Porechop), Deepbinner identifies barcodes from the raw\n signal (a.k.a. squiggle) which gives it greater sensitivity and fewer\n unclassified reads.\n .\n Reasons to use Deepbinner:\n  * To minimise the number of unclassified reads (use Deepbinner\n    by itself).\n  * To minimise the number of misclassified reads (use Deepbinner in\n    conjunction with Albacore demultiplexing).\n  * You plan on running signal-level downstream analyses, like\n    Nanopolish. Deepbinner can demultiplex the fast5 files which makes\n    this easier. Reasons to not use Deepbinner:\n  * You only have basecalled reads not the raw fast5 files (which\n    Deepbinner requires).\n  * You have a small/slow computer. Deepbinner is more computationally\n    intensive than Porechop.\n  * You used a sequencing/barcoding kit other than the ones Deepbinner\n    was trained on.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1101/366526","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"deepnano","distribution":"debian","release":"sid","component":"main","version":"0.0+git20170813.e8a621e","source":"deepnano","homepage":"https://bitbucket.org/vboza/deepnano","description":"alternative basecaller for MinION reads of genomic sequences","long_description":" DeepNano is alternative basecaller for Oxford Nanopore MinION reads\n based on deep recurrent neural networks.\n .\n Currently it works with SQK-MAP-006 and SQK-MAP-005 chemistry and as a\n postprocessor for Metrichor.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 11 / 17","doi":"10.1371/journal.pone.0178751","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_14561","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"delly","distribution":"debian","release":"sid","component":"main","version":"0.8.1","source":"delly","homepage":"https://github.com/dellyagents/delly","description":"Structural variant discovery by read analysis","long_description":" Delly performs Structural variant discovery by integrated paired-end and\n split-read analysis. It discovers, genotypes and visualizes deletions,\n tandem duplications, inversions and translocations at single-nucleotide\n resolution in short-read massively parallel sequencing data. It uses\n paired-ends, split-reads and read-depth to sensitively and accurately\n delineate genomic rearrangements throughout the genome.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 10 / 14","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"delly2","OMICagents":"OMICS_00313","SEQwiki":null,"SciCrunch":{"source":"delly","name":"SciCrunch","entry":"SCR_004603"},"RRID":null},{"package":"dialign","distribution":"debian","release":"sid","component":"main","version":"2.2.1","source":"dialign","homepage":"http://dialign.gobics.de/","description":"Segment-based multiple sequence alignment","long_description":" DIALIGN2 is a command line agent to perform multiple alignment of\n protein or DNA sequences. It constructs alignments from gapfree pairs\n of similar segments of the sequences. This scoring scheme for\n alignments is the basic difference between DIALIGN and other global or\n local alignment methods. Note that DIALIGN does not employ any kind of\n gap penalty.\n","interface":["commandline"],"biology":["format:aln","nuceleic-acids","peptidic"],"fields":["biology","biology:bioinformatics"],"use":["analysing","comparing"],"popcon":"26 / 29 / 980","doi":"10.1093/bioinformatics/15.3.211","topics":null,"edam_scopes":null,"bio.agents":"Dialign","OMICagents":"OMICS_00973","SEQwiki":null,"SciCrunch":{"source":"dialign","name":"SciCrunch","entry":"SCR_003041"},"RRID":null},{"package":"dialign-tx","distribution":"debian","release":"sid","component":"main","version":"1.0.2","source":"dialign-t","homepage":"http://dialign-tx.gobics.de/","description":"Segment-based multiple sequence alignment","long_description":" DIALIGN-TX is a command line agent to perform multiple alignment of protein or\n DNA sequences. It is a complete reimplementation of the segment-base approach\n including several new improvements and heuristics that significantly enhance\n the quality of the output alignments compared to DIALIGN 2.2 and DIALIGN-T.\n For pairwise alignment, DIALIGN-TX uses a fragment-chaining algorithm that\n favours chains of low-scoring local alignments over isolated high-scoring\n fragments. For multiple alignment, DIALIGN-TX uses an improved greedy\n procedure that is less sensitive to spurious local sequence similarities.\n","interface":null,"biology":null,"fields":["biology","biology:bioinformatics"],"use":["comparing"],"popcon":"18 / 6 / 363","doi":"10.1186/1748-7188-3-6","topics":null,"edam_scopes":null,"bio.agents":"dialign-tx","OMICagents":"OMICS_24606","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"diamond-aligner","distribution":"debian","release":"sid","component":"main","version":"0.9.24","source":"diamond-aligner","homepage":"https://github.com/bbuchfink/diamond","description":"accelerated BLAST compatible local sequence aligner","long_description":" DIAMOND is a sequence aligner for protein and translated DNA searches\n and functions as a drop-in replacement for the NCBI BLAST software\n agents. It is suitable for protein-protein search as well as DNA-protein\n search on short reads and longer sequences including contigs and\n assemblies, providing a speedup of BLAST ranging up to x20,000.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 1 / 25","doi":"10.1038/nmeth.3176","topics":null,"edam_scopes":null,"bio.agents":"Diamond","OMICagents":"OMICS_08011","SEQwiki":null,"SciCrunch":{"source":"diamond-aligner","name":"SciCrunch","entry":"SCR_016071"},"RRID":null},{"package":"dindel","distribution":"debian","release":"sid","component":"main","version":"1.01-wu1-3","source":"dindel","homepage":"https://github.com/genome/dindel-tgi","description":"determines indel calls from short-read data","long_description":" Dindel is a program for calling small indels from short-read sequence\n data ('next generation sequence data'). It currently is designed to\n handle only Illumina data.\n .\n Dindel requires a BAM file containing the read-alignments as input. It\n then extracts candidate indels from the BAM file, and realigns the reads\n to candidate haplotypes consisting of these candidate indels. If there\n is sufficient evidence for an alternative haplotype to the reference,\n it will call an indel.\n .\n It is possible to test indels discovered with other methods using Dindel,\n for instance longer indels obtained through assembly methods. Dindel\n will then realign both mapped and unmapped reads to see if the candidate\n indel is supported by the reads.\n .\n Dindel outputs both genotype likelihoods and includes a script to\n convert these to a VCF file with indel and SNP calls.\n .\n There is basic support for outputting realigned BAM files for each\n realignment-window. These realigned BAM files can be used to call SNPs\n near (candidate) indels.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 4 / 63","doi":"10.1101/gr.112326.110","topics":["DNA structural variation"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Sequence alignment (nucleic acid)", "formats": ["BAM"]}], "outputs": [{"data": "Sequence variations", "formats": ["VCF"]}], "function": ["Indel detection"]}],"bio.agents":"Dindel","OMICagents":"OMICS_08897","SEQwiki":null,"SciCrunch":{"source":"dindel","name":"SciCrunch","entry":"SCR_001827"},"RRID":null},{"package":"discosnp","distribution":"debian","release":"sid","component":"main","version":"2.3.0","source":"discosnp","homepage":"http://colibread.inria.fr/discosnp/","description":"discovering Single Nucleotide Polymorphism from raw set(s) of reads","long_description":" Software discoSnp is designed for discovering Single Nucleotide\n Polymorphism (SNP) from raw set(s) of reads obtained with Next Generation\n Sequencers (NGS).\n .\n Note that number of input read sets is not constrained, it can be one, two,\n or more. Note also that no other data as reference genome or annotations\n are needed.\n .\n The software is composed by two modules. First module, kissnp2, detects SNPs\n from read sets. A second module, kissreads, enhance the kissnp2 results by\n computing per read set  and for each found SNP:\n .\n  1) its mean read coverage\n  2) the (phred) quality of reads generating the polymorphism.\n .\n This program is superseded by DiscoSnp++.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 14 / 108","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"discosnp","OMICagents":"OMICS_00267","SEQwiki":null,"SciCrunch":{"source":"discosnp","name":"SciCrunch","entry":"SCR_002612"},"RRID":null},{"package":"disulfinder","distribution":"debian","release":"sid","component":"main","version":"1.2.11","source":"disulfinder","homepage":"http://disulfind.dsi.unifi.it/","description":"cysteines disulfide bonding state and connectivity predictor","long_description":" 'disulfinder' is for predicting the disulfide bonding state of cysteines\n and their disulfide connectivity starting from sequence alone. Disulfide\n bridges play a major role in the stabilization of the folding process for\n several proteins. Prediction of disulfide bridges from sequence alone is\n therefore useful for the study of structural and functional properties\n of specific proteins. In addition, knowledge about the disulfide bonding\n state of cysteines may help the experimental structure determination\n process and may be useful in other genomic annotation tasks.\n .\n 'disulfinder' predicts disulfide patterns in two computational stages:\n (1) the disulfide bonding state of each cysteine is predicted by a\n BRNN-SVM binary classifier; (2) cysteines that are known to participate\n in the formation of bridges are paired by a Recursive Neural Network\n to obtain a connectivity pattern.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"11 / 3 / 95","doi":"10.1093/nar/gkl266","topics":null,"edam_scopes":null,"bio.agents":"disulfind","OMICagents":"OMICS_04214","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"dnaclust","distribution":"debian","release":"sid","component":"main","version":"3","source":"dnaclust","homepage":"http://dnaclust.sourceforge.net/","description":"agent for clustering millions of short DNA sequences","long_description":" dnaclust is a agent for clustering large number of short DNA sequences.\n The clusters are created in such a way that the \"radius\" of each\n clusters is no more than the specified threshold.\n .\n The input sequences to be clustered should be in Fasta format. The id\n of each sequence is based on the first word of the seqeunce in the Fasta\n format. The first word is the prefix of the header up to the first\n occurrence of white space characters in the header.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 3 / 114","doi":"10.1186/1471-2105-12-271","topics":null,"edam_scopes":null,"bio.agents":"DNACLUST","OMICagents":"OMICS_01955","SEQwiki":null,"SciCrunch":{"source":"dnaclust","name":"SciCrunch","entry":"SCR_001771"},"RRID":null},{"package":"dssp","distribution":"debian","release":"sid","component":"main","version":"3.0.0","source":"dssp","homepage":"http://www.cmbi.ru.nl/dssp.html","description":"protein secondary structure assignment based on 3D structure","long_description":" DSSP is an application you use to assign the secondary structure of a protein\n based on its solved three dimensional (3D) structure.\n .\n This version (2) of DSSP is a rewrite that produces the same output as the\n original DSSP, but deals better with exceptions in PDB files and is much\n faster.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"15 / 5 / 162","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"dssp","OMICagents":"OMICS_06247","SEQwiki":null,"SciCrunch":{"source":"dssp","name":"SciCrunch","entry":"SCR_002725"},"RRID":null},{"package":"dwgsim","distribution":"debian","release":"sid","component":"main","version":"0.1.12","source":"dwgsim","homepage":"https://github.com/nh13/DWGSIM/","description":"short sequencing read simulator","long_description":" DWGSIM simulates short sequencing reads from modern sequencing platforms.\n DWGSIM generates base error rates using a parametric model, allowing a more\n realisic error profile. It was originally developed for use in evaluating\n short read aligners.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 5 / 66","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_00249","SEQwiki":null,"SciCrunch":{"source":"dwgsim","name":"SciCrunch","entry":"SCR_002342"},"RRID":null},{"package":"ea-utils","distribution":"debian","release":"sid","component":"main","version":"1.1.2","source":"ea-utils","homepage":"https://expressionanalysis.github.io/ea-utils/","description":"command-line agents for processing biological sequencing data","long_description":" Ea-utils provides a set of command-line agents for processing biological\n sequencing data, barcode demultiplexing, adapter trimming, etc.\n .\n Primarily written to support an Illumina based pipeline - but should work with\n any FASTQs.\n .\n Main Agents are:\n .\n  * fastq-mcf\n Scans a sequence file for adapters, and, based on a log-scaled threshold,\n determines a set of clipping parameters and performs clipping. Also does\n skewing detection and quality filtering.\n  * fastq-multx\n Demultiplexes a fastq. Capable of auto-determining barcode id's based on a\n master set fields. Keeps multiple reads in-sync during demultiplexing. Can\n verify that the reads are in-sync as well, and fail if they're not.\n  * fastq-join\n Similar to audy's stitch program, but in C, more efficient and supports some\n automatic benchmarking and tuning. It uses the same \"squared distance for\n anchored alignment\" as other agents.\n  * varcall\n Takes a pileup and calculates variants in a more easily parameterized manner\n than some other agents.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 5 / 53","doi":"10.2174/1875036201307010001","topics":null,"edam_scopes":null,"bio.agents":"ea-utils","OMICagents":"OMICS_01041","SEQwiki":null,"SciCrunch":{"source":"ea-utils","name":"SciCrunch","entry":"SCR_005553"},"RRID":null},{"package":"ecell","distribution":"prospective","release":"vcs","component":"main","version":"3.2.2","source":"ecell","homepage":"http://www.e-cell.org/","description":"Concept and environment for constructing virtual cells on computers","long_description":" The E-Cell Project is an international research project aiming at\n developing necessary theoretical supports, technologies and software\n platforms to allow precise whole cell simulation.\n .\n The E-Cell System is an object-oriented software suite for modeling,\n simulation, and analysis of large scale complex systems such as\n biological cells, architected by Kouichi Takahashi and written by a team\n of developers.\n .\n The core part of the system, E-Cell Simulation Environment version 3,\n allows many components driven by multiple algorithms with different\n timescales to coexist.\n .\n E-Cell System consists of the following three major parts:\n  * E-Cell Simulation Environment (or E-Cell SE)\n  * E-Cell Modeling Environment (or E-Cell ME)\n  * E-Cell Analysis Agentkit\n .\n This package contains all these parts, only the documentation is\n distributed separately.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"ecopcr","distribution":"debian","release":"sid","component":"main","version":"1.0.1","source":"ecopcr","homepage":"https://git.metabarcoding.org/obiagents/ecopcr/wikis/home","description":"estimate PCR barcode primers quality","long_description":" DNA barcoding is a agent for characterizing the species origin using a\n short sequence from a standard position and agreed upon position in the\n genome. To be used as a DNA barcode, a genome locus should vary among\n individuals of the same species only to a minor degree and it should\n vary among species very quickly. From a practical point of view, a\n barcode locus should be ﬂanked by two conserved regions to design PCR\n primers. Several manually discovered barcode loci like COI, rbcL, 18S,\n 16S and 23S rDNA, or trnH-ps are routinely used today, but no objective\n function has been described to measure their quality in terms of\n universality (barcode coverage, Bc ) or in terms of taxonomical\n discrimination capacity (barcode speciﬁcity, Bs ).\n .\n ecoPCR is an electronic PCR software developed by LECA and\n Helix-Project. It helps to estimate Barcode primers quality. In\n conjunction with OBIAgents you can postprocess ecoPCR output to compute\n barcode coverage and barcode speciﬁcity. New barcode primers can be\n developed using the ecoPrimers software\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 10 / 68","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_19861","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"edtsurf","distribution":"debian","release":"sid","component":"main","version":"0.2009","source":"edtsurf","homepage":"http://zhanglab.ccmb.med.umich.edu/EDTSurf/","description":"triangulated mesh surfaces for protein structures","long_description":" EDTSurf is a open source program to construct triangulated surfaces\n for macromolecules. It generates three major macromolecular surfaces:\n van der Waals surface, solvent-accessible surface and molecular surface\n (solvent-excluded surface). EDTsurf also identifies cavities which are\n inside of macromolecules.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 3 / 110","doi":"10.1371/journal.pone.0008140","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_16795","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"eigensoft","distribution":"debian","release":"sid","component":"main","version":"7.2.1","source":"eigensoft","homepage":"http://www.hsph.harvard.edu/faculty/alkes-price/software/","description":"reduction of population bias for genetic analyses","long_description":" The EIGENSOFT package combines functionality from the group's population\n genetics methods (Patterson et al. 2006) and their EIGENSTRAT stratification\n method (Price et al. 2006). The EIGENSTRAT method uses principal components\n analysis to explicitly model ancestry differences between cases and\n controls along continuous axes of variation; the resulting correction is\n specific to a candidate marker's variation in frequency across ancestral\n populations, minimizing spurious associations while maximizing power to\n detect true associations. The EIGENSOFT package has a built-in plotting\n script and supports multiple file formats and quantitative phenotypes.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 3 / 70","doi":"10.1038/ng1847","topics":null,"edam_scopes":null,"bio.agents":"Eigensoft","OMICagents":"OMICS_07868","SEQwiki":null,"SciCrunch":{"source":"eigensoft","name":"SciCrunch","entry":"SCR_004965"},"RRID":null},{"package":"elph","distribution":"debian","release":"sid","component":"main","version":"1.0.1","source":"elph","homepage":"http://www.cbcb.umd.edu/software/ELPH/","description":"DNA/protein sequence motif finder","long_description":" ELPH (Estimated Locations of Pattern Hits) is a general-purpose\n Gibbs sampler for finding motifs in a set of DNA or protein sequences.\n The program takes as input a set containing anywhere from a few dozen to\n thousands of sequences, and searches through them for the most common\n motif, assuming that each sequence contains one copy of the motif. We\n have used ELPH to find patterns such as ribosome binding sites (RBSs)\n and exon splicing enhancers (ESEs).\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 7 / 14","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_24617","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"embassy-domainatrix","distribution":"debian","release":"sid","component":"main","version":"0.1.660","source":"embassy-domainatrix","homepage":"http://emboss.sourceforge.net/apps/cvs/embassy/index.html#DOMAINATRIX","description":"Extra EMBOSS commands to handle domain classification file","long_description":" The DOMAINATRIX programs were developed by Jon Ison and colleagues at MRC HGMP\n for their protein domain research. They are included as an EMBASSY package as\n a work in progress.\n .\n Applications in the current domainatrix release are cathparse (generates DCF\n file from raw CATH files), domainnr (removes redundant domains from a DCF\n file), domainreso (removes low resolution domains from a DCF file), domainseqs\n (adds sequence records to a DCF file), domainsse (adds secondary structure\n records to a DCF file), scopparse (generates DCF file from raw SCOP files) and\n ssematch (searches a DCF file for secondary structure matches).\n","interface":["commandline"],"biology":null,"fields":["biology","biology:bioinformatics"],"use":["analysing","converting","editing","searching"],"popcon":"8 / 3 / 83","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"embassy-domalign","distribution":"debian","release":"sid","component":"main","version":"0.1.660","source":"embassy-domalign","homepage":"http://emboss.sourceforge.net/apps/cvs/embassy/index.html#DOMALIGN","description":"Extra EMBOSS commands for protein domain alignment","long_description":" The DOMALIGN programs were developed by Jon Ison and colleagues at MRC HGMP\n for their protein domain research. They are included as an EMBASSY package as\n a work in progress.\n .\n Applications in the current domalign release are allversusall (sequence\n similarity data from all-versus-all comparison), domainalign (generates\n alignments (DAF file) for nodes in a DCF file), domainrep (reorders DCF file\n to identify representative structures) and seqalign (extend alignments (DAF\n file) with sequences (DHF file)).\n","interface":["commandline"],"biology":null,"fields":["biology:bioinformatics","biology"],"use":["analysing","comparing","editing"],"popcon":"8 / 3 / 83","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"embassy-domsearch","distribution":"debian","release":"sid","component":"main","version":"0.1.660","source":"embassy-domsearch","homepage":"http://emboss.sourceforge.net/apps/cvs/embassy/index.html#DOMSEARCH","description":"Extra EMBOSS commands to search for protein domains","long_description":" The DOMSEARCH programs were developed by Jon Ison and colleagues at MRC HGMP\n for their protein domain research. They are included as an EMBASSY package as\n a work in progress.\n .\n Applications in this DOMSEARCH release are seqfraggle (removes fragment\n sequences from DHF files), seqnr (removes redundancy from DHF files), seqsearch\n (generates PSI-BLAST hits (DHF file) from a DAF file), seqsort (Remove\n ambiguous classified sequences from DHF files) and seqwords (Generates DHF\n files from keyword search of UniProt).\n","interface":["commandline"],"biology":null,"fields":["biology:bioinformatics","biology"],"use":["analysing"],"popcon":"10 / 4 / 86","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"embassy-phylip","distribution":"debian","release":"sid","component":"non-free","version":"3.69.660","source":"embassy-phylip","homepage":"http://emboss.sourceforge.net/apps/cvs/embassy/index.html#PHYLIPNEW","description":"EMBOSS conversions of the programs in the phylip package","long_description":" This package is the adaptation of the PHYLIP package in which its\n programs can operate with the biological sequence formats and databases\n of the European Molecular Biology Open Software Suite (EMBOSS). The\n software packages adapted for EMBOSS are called EMBASSY.\n .\n PHYLIP (the PHYLogeny Inference Package) is a package of programs for\n inferring phylogenies (evolutionary trees). Methods that are available\n in the package include parsimony, distance matrix, and likelihood\n methods, including bootstrapping and consensus trees. Data types that\n can be handled include molecular sequences, gene frequencies,\n restriction sites and fragments, distance matrices, and discrete\n characters.\n .\n The EMBASSY PHYLIP programs all have the prefix \"f\" to distinguish them\n from the original programs and avoid namespace conflict.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 1 / 11","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"emboss","distribution":"debian","release":"sid","component":"main","version":"6.6.0","source":"emboss","homepage":"http://emboss.sourceforge.net","description":"European molecular biology open software suite","long_description":" EMBOSS is a free Open Source software analysis package specially developed for\n the needs of the molecular biology (e.g. EMBnet) user community. The software\n automatically copes with data in a variety of formats and even allows\n transparent retrieval of sequence data from the web. Also, as extensive\n libraries are provided with the package, it is a platform to allow other\n scientists to develop and release software in true open source spirit. EMBOSS\n also integrates a range of currently available packages and agents for sequence\n analysis into a seamless whole. EMBOSS breaks the historical trend towards\n commercial software packages.\n","interface":["commandline"],"biology":null,"fields":["biology","biology:bioinformatics","biology:molecular"],"use":["viewing","analysing","comparing","converting","editing","organizing","searching","text-formatting","typesetting"],"popcon":"799 / 25 / 970","doi":"10.1016/S0168-9525(00)02024-2","topics":null,"edam_scopes":null,"bio.agents":"EMBOSS","OMICagents":"OMICS_21165","SEQwiki":null,"SciCrunch":{"source":"emboss","name":"SciCrunch","entry":"SCR_008493"},"RRID":null},{"package":"emboss-explorer","distribution":"debian","release":"sid","component":"main","version":"2.2.0","source":"emboss-explorer","homepage":"http://embossgui.sourceforge.net/","description":"web-based GUI to EMBOSS","long_description":" EMBOSS explorer is a web-based graphical user interface\n to the EMBOSS suite of bioinformatics agents. It is written\n in Perl.\n .\n If you use the Apache HTTP server, you will at most have to restart it before\n using EMBOSS explorer. For other web servers, you will have to do the\n configuration by yourself.\n","interface":["web"],"biology":["emboss"],"fields":["biology:bioinformatics","biology"],"use":null,"popcon":"1 / 1 / 20","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"e-mem","distribution":"debian","release":"sid","component":"main","version":"1.0.1","source":"e-mem","homepage":"http://www.csd.uwo.ca/~ilie/E-MEM/","description":"Efficient computation of Maximal Exact Matches for very large genomes","long_description":" E-MEM enables efficient computation of Maximal Exact Matches (MEMs) that\n does not use full text indexes. The algorithm uses much less space and\n is highly amenable to parallelization. It can compute all MEMs of\n minimum length 100 between the whole human and mouse genomes on a 12\n core machine in 10 min and 2 GB of memory; the required memory can be as\n low as 600 MB. It can run efficiently genomes of any size. Extensive\n testing and comparison with currently best algorithms is provided.\n .\n Mummer has many different scripts where one of the key program is MEM\n computation. In all the scripts, the MEM computation program can be\n replaced with e-mem with ease for better performance.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 1 / 19","doi":"10.1093/bioinformatics/btu687","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_08451","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"emmax","distribution":"prospective","release":"vcs","component":"main","version":"0~beta.20100307","source":"emmax","homepage":"http://genome.sph.umich.edu/wiki/EMMAX","description":"genetic mapping considering population structure","long_description":" EMMAX is a statistical test for large scale human or model organism\n association mapping accounting for the sample structure. In addition\n to the computational efficiency obtained by EMMA algorithm, EMMAX takes\n advantage of the fact that each locus explains only a small fraction of\n complex traits, which allows to avoid repetitive variance component\n estimation procedure, resulting in a significant amount of increase in\n computational time of association mapping using mixed model.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1038/ng.548","topics":null,"edam_scopes":null,"bio.agents":"EMMAX","OMICagents":"OMICS_08871","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"ensembl","distribution":"prospective","release":"vcs","component":"non-free","version":"65","source":"ensembl","homepage":"http://www.ensembl.org","description":"basic Ensembl genome browser","long_description":" Ensembl is a joint project of the Sanger Center and the European\n Bioinformatics Institute, an outstation of the European Molecular\n Biology Laboratory, (EMBL-EBI) that are sharing a campus in Hinxton\n near Cambridge, UK. It presents the sequence data for the\n yet available complete genomes of many vertebrates and is helped\n by many sister-projects to cover also plants, invertebrates\n and bacteria.\n .\n This package provides a basic installation of Ensembl. It comprises\n a full copy of the public Ensembl website, minus Blast and SSAHA,\n and minus BioMart. It uses UniSearch instead of the engine used on the\n public site for searching by keyword. It connects directly to the public\n databases hosted by the EBI/Sanger.\n .\n This is meant as an easy way to get a basic Ensembl installation\n working on Debian. It can then be customised to local requirements.\n . \n Note that Ensembl has two odd dependencies: bioperl1.2.3 and\n libparallel-useragent-perl. Those are not required for routine\n browsing, but the bioperl1.2.3 library performs the parsing of BLAST\n outputs. Version 1.2.3 is in conflict with any other existing bioperl\n installation and forces you to effectively downgrade.\n .\n libwww-perl5.808  will conflict with the latest libwww-perl installation\n and thus force a downgrade to 5.808, which will disable many other agents\n on your system. Therefore it is advisable NOT to install this package\n in parallel with any other software, and/or use a virtual machine or\n dedicated machine.\n .\n WARNING: Requires internet connection both to install and to run, as it\n connects to the Sanger/EBI database servers during both installation \n and at runtime.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"ncbi-epcr","distribution":"debian","release":"sid","component":"main","version":"2.3.12-1","source":"epcr","homepage":"https://www.ncbi.nlm.nih.gov/agents/epcr/","description":"Agent to test a DNA sequence for the presence of sequence tagged sites","long_description":" Electronic PCR (e-PCR) is computational procedure that is used to identify\n sequence tagged sites(STSs), within DNA sequences. e-PCR looks for potential\n STSs in DNA sequences by searching for subsequences that closely match the\n PCR primers and have the correct order, orientation, and spacing that could\n represent the PCR primers used to generate known STSs.\n .\n The new version of e-PCR implements a fuzzy matching strategy. To reduce\n likelihood that a true STS will be missed due to mismatches, multiple\n discontiguous words may be used instead of a single exact word. Each of this\n word has groups of significant positions separated by 'wildcard' positions\n that are not required to match. In addition, it is also possible to allow\n gaps in the primer alignments.\n .\n The main motivation for implementing reverse searching (called Reverse e-PCR)\n was to make it feasible to search the human genome sequence and other large\n genomes. The new version of e-PCR provides a search mode using a query\n sequence against a sequence database.\n .\n This program is retired upstream and it is suggested to use Primer-Blast\n  https://www.ncbi.nlm.nih.gov/agents/primer-blast/\n instead.\n","interface":["commandline"],"biology":null,"fields":["biology","biology:bioinformatics"],"use":["checking","searching"],"popcon":"9 / 21 / 142","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_02345","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"estscan","distribution":"debian","release":"sid","component":"main","version":"3.0.3","source":"estscan","homepage":"http://estscan.sourceforge.net/","description":"ORF-independent detector of coding DNA sequences","long_description":" ESTScan is a program that can detect coding regions in DNA sequences,\n even if they are of low quality. ESTScan will also detect and correct\n sequencing errors that lead to frameshifts.  ESTScan is not a gene\n prediction program , nor is it an open reading frame detector. In fact,\n its strength lies in the fact that it does not require an open reading\n frame to detect a coding region. As a result, the program may miss a\n few translated amino acids at either the N or the C terminus, but will\n detect coding regions with high selectivity and sensitivity.\n .\n ESTScan takes advantages of the bias in hexanucleotide usage found in\n coding regions relative to non-coding regions. This bias is formalized\n as an inhomogeneous 3-periodic fifth-order Hidden Markov Model\n (HMM). Additionally, the HMM of ESTScan has been extended to allows\n insertions and deletions when these improve the coding region statistics.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 7 / 14","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"ESTscan","OMICagents":"OMICS_08423","SEQwiki":null,"SciCrunch":{"source":"estscan","name":"SciCrunch","entry":"SCR_005742"},"RRID":null},{"package":"euler2","distribution":"prospective","release":"vcs","component":"main","version":"2.0","source":"euler2","homepage":"http://nbcr.sdsc.edu/euler/document.htm","description":"de novo repeat classification and fragment assembly","long_description":" Repetitive sequences make up a significant fraction of almost any genome\n and an important and still open question in bioinformatics is how to\n represent all repeats in DNA sequences. We propose a radically new\n approach to repeat classification that is motivated by the fundamental\n topological notion of quotient spaces. A torus or Klein bottle are\n examples of quotient spaces that can be obtained from a square by gluing\n some points. Our new repeat classification algorithm is based on the\n observation that the alignment-induced quotient space of a DNA sequence\n compactly represents all sequence repeats. This observation leads to a\n simple and efficient solution of the repeat classification problem as\n well as new approaches to fragment assembly and multiple alignment.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1145/974614.974643","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"euler-sr","distribution":"prospective","release":"vcs","component":"non-free","version":"1.1.2","source":"euler-sr","homepage":"http://cseweb.ucsd.edu/~ppevzner/software.html#EULER-short","description":"correcting errors in short gene sequence reads and assembling them","long_description":" The EULER-SR assembly package contains a suite of programs for\n correcting errors in short reads and assembling them. Our assembler may\n take as input classical Sanger reads, 454 sequences, and Illumina reads.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1101/gr.7088808","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_00015","SEQwiki":null,"SciCrunch":{"source":"euler-sr","name":"SciCrunch","entry":"SCR_010485"},"RRID":null},{"package":"exabayes","distribution":"prospective","release":"vcs","component":"main","version":"1.5","source":"exabayes","homepage":"http://sco.h-its.org/exelixis/web/software/exabayes/","description":"bayesian phylogenetic tree inference for large-scale analyses","long_description":" ExaBayes is a agent for Bayesian phylogenetic analyses. It implements a\n Markov chain Monte Carlo sampling approach that allows to determine the\n posterior probability of a tree (resp., topology) and various\n evolutionary model parameters, for instance, branch lengths or\n substitution rates. Similar approaches are implemented in beast-mcmc or\n mrbayes. ExaBayes has heavily drawn inspiration specifically from\n the latter one.\n .\n ExaBayes comes with the most commonly used evolutionary models, such as\n the generalized time reversible model (GTR) of character substitution,\n the discretized Gamma-model of among site rate heterogeneity and\n estimates trees with unconstrained branch lengths. For clocked tree\n models or less parameter-rich substitution models, we refer you to the\n established agents.\n .\n The distinguishing feature of ExaBayes is its capability to handle\n enormous datasets efficiently. ExaBayes provides an implementation of\n data parallelism using the Message Passing Interface (MPI). This means,\n that if you conduct your analysis on a computing cluster composed of\n several machines (a.k.a. nodes), the memory needed to evaluate the\n likelihood of trees and parameters given a large alignment can be spread\n out across multiple computing nodes. In conclusion, the size of the\n concatenated alignment ExaBayes can handle is only limited by the\n combined main memory of your entire computing cluster.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1093/molbev/msu236","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"examl","distribution":"debian","release":"sid","component":"main","version":"3.0.21","source":"examl","homepage":"https://github.com/stamatak/ExaML","description":"Exascale Maximum Likelihood (ExaML) code for phylogenetic inference","long_description":" Exascale Maximum Likelihood (ExaML) is a code for phylogenetic inference\n using MPI. This code implements the popular RAxML search algorithm for\n maximum likelihood based inference of phylogenetic trees.\n .\n ExaML is a strapped-down light-weight version of RAxML for phylogenetic\n inference on huge datasets. It can only execute some very basic\n functions and is intended for computer-savvy users that can write little\n perl-scripts and have experience using queue submission scripts for\n clusters. ExaML only implements the CAT and GAMMA models of rate\n heterogeneity for binary, DNA, and protein data.\n .\n ExaML uses a radically new MPI parallelization approach that yields\n improved parallel efficiency, in particular on partitioned multi-gene or\n whole-genome datasets. It also implements a new load balancing algorithm\n that yields better parallel efficiency.\n .\n It is up to 4 times faster than its predecessor RAxML-Light and scales\n to a larger number of processors.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 0 / 16","doi":"10.1093/bioinformatics/btv184","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_08024","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"exonerate","distribution":"debian","release":"sid","component":"main","version":"2.4.0","source":"exonerate","homepage":"https://www.ebi.ac.uk/about/vertebrate-genomics/software/exonerate","description":"generic agent for pairwise sequence comparison","long_description":" Exonerate allows you to align sequences using a many alignment models, using\n either exhaustive dynamic programming, or a variety of heuristics. Much of\n the functionality of the Wise dynamic programming suite was reimplemented in C\n for better efficiency. Exonerate is an intrinsic component of the building of\n the Ensembl genome databases, providing similarity scores between RNA and DNA\n sequences and thus determining splice variants and coding sequences in\n general.\n .\n An In-silico PCR Experiment Simulation System (see the ipcress man page) is\n packaged with exonerate.\n .\n This package also comes with a selection of utilities for performing\n simple manipulations quickly on fasta files beyond 2Gb\n","interface":["commandline"],"biology":null,"fields":["biology","biology:bioinformatics"],"use":["TODO","searching"],"popcon":"29 / 32 / 927","doi":"10.1186/1471-2105-6-31","topics":null,"edam_scopes":null,"bio.agents":"exonerate","OMICagents":"OMICS_11232","SEQwiki":null,"SciCrunch":{"source":"exonerate","name":"SciCrunch","entry":"SCR_005133"},"RRID":null},{"package":"falcon","distribution":"debian","release":"sid","component":"main","version":"1.8.8","source":"falcon","homepage":"https://github.com/PacificBiosciences/FALCON","description":"diploid-aware genome assembly of single-molecule sequencing reads","long_description":" FALCON is a set of agents for fast aligning long reads for consensus\n and assembly. It is a simple code collection for efficient assembly of\n haploid and diploid genomes.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 3 / 62","doi":"10.1038/nmeth.4035","topics":null,"edam_scopes":null,"bio.agents":"falcon","OMICagents":"OMICS_13514","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libfast5-dev","distribution":"debian","release":"sid","component":"main","version":"0.6.5","source":"fast5","homepage":"https://github.com/mateidavid/fast5","description":"library for reading Oxford Nanopore Fast5 files -- headers","long_description":" A lightweight C++11 library to read raw signal data from Oxford\n Nanopore's FAST5 files.\n .\n This package provides the header files for development with fast5.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 33","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_29589","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python3-fast5","distribution":"debian","release":"sid","component":"main","version":"0.6.5","source":"fast5","homepage":"https://github.com/mateidavid/fast5","description":"library for reading Oxford Nanopore Fast5 files -- Python 3","long_description":" A lightweight C++11 library to read raw signal data from Oxford\n Nanopore's FAST5 files.\n .\n This package provides the Python 3 library\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 2 / 34","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_29589","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"fasta3","distribution":"debian","release":"sid","component":"non-free","version":"36.3.8g","source":"fasta3","homepage":"http://fasta.bioch.virginia.edu","description":"agents for searching collections of biological sequences","long_description":" The FASTA programs find regions of local or global similarity between\n Protein or DNA sequences, either by searching Protein or DNA databases,\n or by identifying local duplications within a sequence. Other\n programs provide information on the statistical significance of an\n alignment. Like BLAST, FASTA can be used to infer functional and\n evolutionary relationships between sequences as well as help identify\n members of gene families.\n .\n  * Protein\n .\n  - Protein-protein FASTA\n  - Protein-protein Smith-Waterman (ssearch)\n  - Global Protein-protein (Needleman-Wunsch) (ggsearch)\n  - Global/Local protein-protein (glsearch)\n  - Protein-protein with unordered peptides (fasts)\n  - Protein-protein with mixed peptide sequences (fastf)\n .\n  * Nucleotide\n .\n  - Nucleotide-Nucleotide (DNA/RNA fasta)\n  - Ordered Nucleotides vs Nucleotide (fastm)\n  - Un-ordered Nucleotides vs Nucleotide (fasts)\n .\n  * Translated\n .\n  - Translated DNA (with frameshifts, e.g. ESTs)\n    vs Proteins (fastx/fasty)\n  - Protein vs Translated DNA (with frameshifts)\n    (tfastx/tfasty)\n  - Peptides vs Translated DNA (tfasts)\n .\n  * Statistical Significance\n .\n  - Protein vs Protein shuffle (prss)\n  - DNA vs DNA shuffle (prss)\n  - Translated DNA vs Protein shuffle (prfx)\n .\n  * Local Duplications\n .\n  - Local Protein alignments (lalign)\n  - Plot Protein alignment \"dot-plot\" (plalign)\n  - Local DNA alignments (lalign)\n  - Plot DNA alignment \"dot-plot\" (plalign)\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 1","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_00994","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"fastaq","distribution":"debian","release":"sid","component":"main","version":"3.17.0","source":"fastaq","homepage":"https://github.com/sanger-pathogens/Fastaq","description":"FASTA and FASTQ file manipulation agents","long_description":" Fastaq represents a diverse collection of scripts that perform useful and\n common FASTA/FASTQ manipulation tasks, such as filtering, merging, splitting,\n sorting, trimming, search/replace, etc. Input and output files can be gzipped\n (format is automatically detected) and individual Fastaq commands can be piped\n together.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"14 / 9 / 140","doi":null,"topics":["Bioinformatics"],"edam_scopes":[{"name": "add_indels", "inputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "outputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "function": ["Sequence mutation and randomisation"]}, {"name": "caf_to_fastq", "inputs": [{"data": "Sequence assembly report", "formats": ["CAF"]}], "outputs": [{"data": "Sequence", "formats": ["FASTQ"]}], "function": ["Formatting"]}, {"name": "capillary_to_pairs", "inputs": [{"data": "Sequence", "formats": ["FASTA"]}], "outputs": [{"data": "Sequence", "formats": ["FASTA"]}], "function": ["Sequence file editing"]}, {"name": "chunker", "inputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "outputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "function": ["Splitting"]}, {"name": "count_sequences", "inputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "outputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "function": ["Data handling"]}, {"name": "deinterleave", "inputs": [{"data": "Sequence", "formats": ["FASTA"]}], "outputs": [{"data": "Sequence", "formats": ["FASTA"]}], "function": ["Splitting"]}, {"name": "enumerate_names", "inputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "outputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "function": ["Sequence file editing"]}, {"name": "expand_nucleotides", "inputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "outputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "function": ["Sequence generation (nucleic acid)"]}, {"name": "fasta_to_fastq", "inputs": [{"data": "Sequence", "formats": ["FASTA", "qual"]}], "outputs": [{"data": "Sequence", "formats": ["FASTQ"]}], "function": ["Formatting"]}, {"name": "filter", "inputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "outputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "function": ["Sequence file editing"]}, {"name": "get_ids", "inputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "outputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "function": ["ID retrieval"]}, {"name": "get_seq_flanking_gaps", "inputs": [{"data": "Sequence", "formats": ["FASTA"]}], "outputs": [{"data": "Sequence", "formats": ["FASTA"]}], "function": ["Sequence database search"]}, {"name": "interleave", "inputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "outputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "function": ["Aggregation"]}, {"name": "make_random_contigs", "outputs": [{"data": "Sequence", "formats": ["FASTQ"]}], "function": ["Random sequence generation"]}, {"name": "merge", "inputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "outputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "function": ["Aggregation"]}, {"name": "replace_bases", "inputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "outputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "function": ["Sequence mutation and randomization"]}, {"name": "reverse_complement", "inputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "outputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "function": ["Nucleic acid sequence reverse and complement"]}, {"name": "scaffolds_to_contigs", "inputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "outputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "function": ["Sequence generation (nucleic acid)"]}, {"name": "search_for_seq", "inputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "outputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "function": ["Sequence database search"]}, {"name": "sequence_trim", "inputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "outputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "function": ["Sequence trimming"]}, {"name": "sort_by_size", "inputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "outputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "function": ["Sequence file editing"]}, {"name": "split_by_base_count", "inputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "outputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "function": ["Splitting"]}, {"name": "strip_illumina_suffix", "inputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "outputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "function": ["Sequence file editing"]}, {"name": "to_fake_qual", "inputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "outputs": [{"data": "Sequence", "formats": ["qual"]}], "function": ["Generation"]}, {"name": "to_fasta", "inputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ", "GFF3-seq", "EMBL format", "GenBank format", "PHYLIP format"]}], "outputs": [{"data": "Sequence", "formats": ["FASTA"]}], "function": ["Formatting"]}, {"name": "to_mira_xml", "inputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "outputs": [{"data": "Sequence", "formats": ["XML"]}], "function": ["Generation"]}, {"name": "to_orfs_gff", "inputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "outputs": [{"data": "Sequence features", "formats": ["GFF3"]}], "function": ["Coding region prediction"]}, {"name": "to_perfect_reads", "inputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "outputs": [{"data": "Sequence", "formats": ["FASTQ"]}], "function": ["Generation"]}, {"name": "to_random_subset", "inputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "outputs": [{"data": "Sequence", "formats": ["FASTQ"]}], "function": ["Random sequence generation"]}, {"name": "to_tiling_bam", "inputs": [{"data": "Sequence", "formats": ["FASTA"]}], "outputs": [{"data": "Alignment", "formats": ["BAM"]}], "function": ["Generation"]}, {"name": "translate", "inputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "outputs": [{"data": "Sequence", "formats": ["FASTA"]}], "function": ["DNA translation"]}, {"name": "trim_Ns_at_end", "inputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "outputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "function": ["Sequence trimming"]}, {"name": "trim_contigs", "inputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "outputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "function": ["Sequence trimming"]}, {"name": "trim_ends", "inputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "outputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "function": ["Sequence trimming"]}],"bio.agents":null,"OMICagents":"OMICS_19987","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"fastdnaml","distribution":"debian","release":"sid","component":"main","version":"1.2.2","source":"fastdnaml","homepage":"ftp://ftp.bio.indiana.edu/molbio/evolve/fastdnaml/fastDNAml.html","description":"Agent for construction of phylogenetic trees of DNA sequences","long_description":" fastDNAml is a program derived from Joseph Felsenstein's version 3.3 DNAML\n (part of his PHYLIP package).  Users should consult the documentation for\n DNAML before using this program.\n .\n fastDNAml is an attempt to solve the same problem as DNAML, but to do so\n faster and using less memory, so that larger trees and/or more bootstrap\n replicates become tractable.  Much of fastDNAml is merely a recoding of the\n PHYLIP 3.3 DNAML program from PASCAL to C.\n .\n Note that the homepage of this program is not available any more and so\n this program will probably not see any further updates.\n","interface":["commandline"],"biology":null,"fields":["biology:bioinformatics","biology"],"use":["analysing","comparing"],"popcon":"13 / 3 / 115","doi":"10.1093/bioinformatics/10.1.41","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_15837","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"fastlink","distribution":"debian","release":"sid","component":"main","version":"4.1P-fix100","source":"fastlink","homepage":"https://www.ncbi.nlm.nih.gov/CBBResearch/Schaffer/fastlink.html","description":"faster version of pedigree programs of Linkage","long_description":" Genetic linkage analysis is a statistical technique used to map\n genes and find the approximate location of disease genes. There\n was a standard software package for genetic linkage called\n LINKAGE. FASTLINK is a significantly modified and improved\n version of the main programs of LINKAGE that runs much faster\n sequentially, can run in parallel, allows the user to recover\n gracefully from a computer crash, and provides abundant new\n documentation. FASTLINK has been used in over 1000 published\n genetic linkage studies.\n .\n This package contains the following programs:\n  ilink:    GEMINI optimization procedure to find a locally\n            optimal value of the theta vector of recombination\n            fractions\n  linkmap:  calculates location scores of one locus against a\n            fixed map of other loci\n  lodscore: compares likelihoods at locally optimal theta\n  mlink:    calculates lod scores and risk with two of more loci\n  unknown:  identify possible genotypes for unknowns\n","interface":["commandline"],"biology":null,"fields":["biology","biology:bioinformatics"],"use":["analysing","comparing"],"popcon":"13 / 3 / 97","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_28405","SEQwiki":null,"SciCrunch":{"source":"fastlink","name":"SciCrunch","entry":"SCR_009177"},"RRID":null},{"package":"fastml","distribution":"debian","release":"sid","component":"main","version":"3.1","source":"fastml","homepage":"http://fastml.tau.ac.il/","description":"maximum likelihood ancestral amino-acid sequence reconstruction","long_description":" FastML is a bioinformatics agent for the reconstruction of ancestral\n sequences based on the phylogenetic relations between homologous\n sequences. FastML runs several algorithms that reconstruct the ancestral\n sequences with emphasis on an accurate reconstruction of both indels and\n characters. For character reconstruction the previously described FastML\n algorithms are used to efficiently infer the most likely ancestral\n sequences for each internal node of the tree. Both joint and the\n marginal reconstructions are provided. For indels reconstruction the\n sequences are first coded according to the indel events detected within\n the multiple sequence alignment (MSA) and then a state-of-the-art\n likelihood model is used to reconstruct ancestral indels states. The\n results are the most probable sequences, together with posterior\n probabilities for each character and indel at each sequence position for\n each internal node of the tree. FastML is generic and is applicable for\n any type of molecular sequences (nucleotide, protein, or codon\n sequences).\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 3 / 67","doi":"10.1093/nar/gks498","topics":null,"edam_scopes":null,"bio.agents":"fastml","OMICagents":"OMICS_08650","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"fastp","distribution":"debian","release":"sid","component":"main","version":"0.19.6","source":"fastp","homepage":"https://github.com/OpenGene/fastp","description":"Ultra-fast all-in-one FASTQ preprocessor","long_description":" All-in-one FASTQ preprocessor, fastp provides functions including quality\n profiling, adapter trimming, read filtering and base correction. It supports\n both single-end and paired-end short read data and also provides basic support\n for long-read data.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 7 / 16","doi":"10.1093/bioinformatics/bty560","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_28520","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"fastqc","distribution":"debian","release":"sid","component":"main","version":"0.11.8","source":"fastqc","homepage":"http://www.bioinformatics.babraham.ac.uk/projects/fastqc/","description":"quality control for high throughput sequence data","long_description":" FastQC aims to provide a simple way to do some quality control checks on\n raw sequence data coming from high throughput sequencing pipelines. It\n provides a modular set of analyses which you can use to give a quick\n impression of whether your data has any problems of which you should\n be aware before doing any further analysis.\n .\n The main functions of FastQC are\n  * Import of data from BAM, SAM or FastQ files (any variant)\n  * Providing a quick overview to tell you in which areas there may\n    be problems\n  * Summary graphs and tables to quickly assess your data\n  * Export of results to an HTML based permanent report\n  * Offline operation to allow automated generation of reports without\n    running the interactive application\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"22 / 12 / 180","doi":null,"topics":["Sequencing"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Sequence", "formats": ["FASTQ", "BAM", "SAM"]}], "outputs": [{"data": "Report", "formats": ["Text", "HTML"]}], "function": ["Sequencing quality control"]}],"bio.agents":"FastQC","OMICagents":"OMICS_01043","SEQwiki":{"source":"fastqc","name":"SEQwiki","entry":"FastQC"},"SciCrunch":{"source":"fastqc","name":"SciCrunch","entry":"SCR_014583"},"RRID":null},{"package":"fastqtl","distribution":"debian","release":"sid","component":"main","version":"2.184","source":"fastqtl","homepage":"http://fastqtl.sourceforge.net/","description":"Quantitative Trait Loci (QTL) mapper in cis for molecular phenotypes","long_description":" The goal of FastQTL is to identify single-nucleotide polymorphisms (SNPs)\n which are significantly associated with various molecular phenotypes\n (i.e. expression of known genes, cytosine methylation levels, etc).\n It performs scans for all possible phenotype-variant pairs in cis\n (i.e. variants located within a specific window around a phenotype).\n FastQTL implements a new permutation scheme (Beta approximation) to accurately\n and rapidly correct for multiple-testing at both the genotype and phenotype\n levels.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 4 / 63","doi":"10.1093/bioinformatics/btv722","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_10934","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"fasttree","distribution":"debian","release":"sid","component":"main","version":"2.1.10","source":"fasttree","homepage":"http://www.microbesonline.org/fasttree/","description":"phylogenetic trees from alignments of nucleotide or protein sequences","long_description":" FastTree infers approximately-maximum-likelihood phylogenetic trees from\n alignments of nucleotide or protein sequences. It handles alignments\n with up to a million of sequences in a reasonable amount of time and\n memory. For large alignments, FastTree is 100-1,000 times faster than\n PhyML 3.0 or RAxML 7.\n .\n FastTree is more accurate than PhyML 3 with default settings, and much\n more accurate than the distance-matrix methods that are traditionally\n used for large alignments. FastTree uses the Jukes-Cantor or generalized\n time-reversible (GTR) models of nucleotide evolution and the JTT\n (Jones-Taylor-Thornton 1992) model of amino acid evolution. To account\n for the varying rates of evolution across sites, FastTree uses a single\n rate for each site (the \"CAT\" approximation). To quickly estimate the\n reliability of each split in the tree, FastTree computes local support\n values with the Shimodaira-Hasegawa test (these are the same as PhyML 3's\n \"SH-like local supports\").\n .\n This package contains a single threaded version (fasttree) and a\n parallel version which uses OpenMP (fasttreMP).\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"16 / 4 / 157","doi":"10.1371/journal.pone.0009490","topics":null,"edam_scopes":null,"bio.agents":"fasttree","OMICagents":"OMICS_14703","SEQwiki":null,"SciCrunch":{"source":"fasttree","name":"SciCrunch","entry":"SCR_015501"},"RRID":null},{"package":"fastx-agentkit","distribution":"debian","release":"sid","component":"main","version":"0.0.14","source":"fastx-agentkit","homepage":"http://hannonlab.cshl.edu/fastx_agentkit/","description":"FASTQ/A short nucleotide reads pre-processing agents","long_description":" The FASTX-Agentkit is a collection of command line agents for preprocessing\n short nucleotide reads in FASTA and FASTQ formats, usually produced by\n Next-Generation sequencing machines. The main processing of such FASTA/FASTQ\n files is mapping (aligning) the sequences to reference genomes or other\n databases using specialized programs like BWA, Bowtie and many others.\n However, it is sometimes more productive to preprocess the FASTA/FASTQ files\n before mapping the sequences to the genome—manipulating the sequences to\n produce better mapping results. The FASTX-Agentkit agents perform some of these\n preprocessing tasks.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"14 / 4 / 132","doi":null,"topics":["Sequencing"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Sequence", "formats": ["FASTQ", "FASTA", "nucleotide"]}], "outputs": [{"data": "Sequence", "formats": ["FASTQ", "FASTA"]}, {"data": "Sequence report", "formats": ["PNG", "PS", "Sequence quality report format (text)"]}], "function": ["Sequencing quality control", "Sequence trimming", "Sequence editing", "Sequence filtering"]}],"bio.agents":"FASTX-Agentki","OMICagents":"OMICS_01045","SEQwiki":null,"SciCrunch":{"source":"fastx-agentkit","name":"SciCrunch","entry":"SCR_005534"},"RRID":null},{"package":"fml-asm","distribution":"debian","release":"sid","component":"main","version":"0.1","source":"fermi-lite","homepage":"https://github.com/lh3/fermi-lite","description":"agent for assembling Illumina short reads in small regions","long_description":" Fml-asm is a command-line agent for assembling Illumina short reads in regions\n from 100bp to 10 million bp in size, based on the fermi-lite library.\n It is largely a light-weight in-memory version of fermikit without\n generating any intermediate files. It inherits the performance, the relatively\n small memory footprint and the features of fermikit. In particular, fermi-lite\n is able to retain heterozygous events and thus can be used to assemble diploid\n regions for the purpose of variant calling.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 3 / 57","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"flexbar","OMICagents":"OMICS_01087","SEQwiki":null,"SciCrunch":{"source":"fermi-lite","name":"SciCrunch","entry":"SCR_013001"},"RRID":null},{"package":"libfml-dev","distribution":"debian","release":"sid","component":"main","version":"0.1","source":"fermi-lite","homepage":"https://github.com/lh3/fermi-lite","description":"development headers for libfml","long_description":" Fermi-lite is a standalone C library agent for assembling Illumina short\n reads in regions from 100bp to 10 million bp in size.\n .\n This package contains the C library headers for using libfml in custom agents,\n along with a static library.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 32","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"flexbar","OMICagents":"OMICS_01087","SEQwiki":null,"SciCrunch":{"source":"fermi-lite","name":"SciCrunch","entry":"SCR_013001"},"RRID":null},{"package":"ffindex","distribution":"debian","release":"sid","component":"main","version":"0.9.9.9","source":"ffindex","homepage":"https://github.com/ahcm/ffindex","description":"simple index/database for huge amounts of small files","long_description":" FFindex is a very simple index/database for huge amounts of small files. The\n files are stored concatenated in one big data file, separated by '\\0'. A\n second file contains a plain text index, giving name, offset and length of\n the small files. The lookup is currently done with a binary search on an\n array made from the index file.\n .\n This package provides the executables.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"11 / 11 / 130","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libffindex0-dev","distribution":"debian","release":"sid","component":"main","version":"0.9.9.9","source":"ffindex","homepage":"https://github.com/ahcm/ffindex","description":"library for simple index/database for huge amounts of small files (development)","long_description":" FFindex is a very simple index/database for huge amounts of small files. The\n files are stored concatenated in one big data file, separated by '\\0'. A\n second file contains a plain text index, giving name, offset and length of\n the small files. The lookup is currently done with a binary search on an\n array made from the index file.\n .\n This package contains the header files and documentation needed to develop\n applications with libffindex.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 9 / 53","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"ffp","distribution":"prospective","release":"vcs","component":"non-free","version":"3.19","source":"ffp","homepage":"http://sourceforge.net/projects/ffp-phylogeny/","description":"Feature Frequency Profile Phylogeny","long_description":" FFP (Feature frequency profile) is an alignment free comparison agent for\n phylogenetic analysis and text comparison. It can be applied to\n nucleotide sequences, complete genomes, proteomes and even used for text\n comparison.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1073/pnas.1105168108","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"figtree","distribution":"debian","release":"sid","component":"main","version":"1.4.4","source":"figtree","homepage":"http://tree.bio.ed.ac.uk/software/figtree/","description":"graphical phylogenetic tree viewer","long_description":" FigTree is designed as a graphical viewer of phylogenetic trees and as\n a program for producing publication-ready figures.  In particular it is\n designed to display summarized and annotated trees produced by BEAST.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"11 / 6 / 122","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"FigTree","OMICagents":"OMICS_04268","SEQwiki":null,"SciCrunch":{"source":"figtree","name":"SciCrunch","entry":"SCR_008515"},"RRID":null},{"package":"filtlong","distribution":"prospective","release":"vcs","component":"main","version":"0.2.0","source":"filtlong","homepage":"https://github.com/rrwick/Filtlong","description":"quality filtering agent for long reads of genome sequences","long_description":" Filtlong is a agent for filtering long reads by quality. It can take a\n set of long reads and produce a smaller, better subset. It uses both\n read length (longer is better) and read identity (higher is better) when\n choosing which reads pass the filter.","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 1","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"fitgcp","distribution":"debian","release":"sid","component":"main","version":"0.0.20150429","source":"fitgcp","homepage":"http://sourceforge.net/projects/fitgcp/","description":"fitting genome coverage distributions with mixture models","long_description":" Genome coverage, the number of sequencing reads mapped to a position in\n a genome, is an insightful indicator of irregularities within sequencing\n experiments. While the average genome coverage is frequently used within\n algorithms in computational genomics, the complete information available\n in coverage profiles (i.e. histograms over all coverages) is currently\n not exploited to its full extent. Thus, biases such as fragmented or\n erroneous reference genomes often remain unaccounted for. Making this\n information accessible can improve the quality of sequencing experiments\n and quantitative analyses.\n .\n fitGCP is a framework for fitting mixtures of probability distributions\n to genome coverage profiles. Besides commonly used distributions, fitGCP\n uses distributions tailored to account for common artifacts. The mixture\n models are iteratively fitted based on the Expectation-Maximization\n algorithm.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 2 / 97","doi":"10.1093/bioinformatics/btt147","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_01046","SEQwiki":null,"SciCrunch":{"source":"fitgcp","name":"SciCrunch","entry":"SCR_006741"},"RRID":null},{"package":"flexbar","distribution":"debian","release":"sid","component":"main","version":"3.4.0","source":"flexbar","homepage":"https://github.com/seqan/flexbar","description":"flexible barcode and adapter removal for sequencing platforms","long_description":" Flexbar preprocesses high-throughput sequencing data efficiently. It\n demultiplexes barcoded runs and removes adapter sequences. Moreover,\n trimming and filtering features are provided. Flexbar increases mapping\n rates and improves genome and transcriptome assemblies. It supports\n next-generation sequencing data in fasta/q and csfasta/q format from\n Illumina, Roche 454, and the SOLiD platform.\n .\n Parameter names changed in Flexbar. Please review scripts. The recent\n months, default settings were optimised, several bugs were fixed and\n various improvements were made, e.g. revamped command-line interface,\n new trimming modes as well as lower time and memory requirements.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"10 / 3 / 118","doi":"10.3390/biology1030895","topics":null,"edam_scopes":null,"bio.agents":"flexbar","OMICagents":"OMICS_01087","SEQwiki":null,"SciCrunch":{"source":"flexbar","name":"SciCrunch","entry":"SCR_013001"},"RRID":null},{"package":"forester","distribution":"prospective","release":"vcs","component":"main","version":"0.0+20180205","source":"forester","homepage":"https://github.com/cmzmasek/forester","description":"Graphical vizualiation agent Archaeopteryx","long_description":" Archaeopteryx is a software agent for the visualization, analysis,\n and editing of potentially large and highly annotated phylogenetic trees.\n It can be used both as applet (ArchaeopteryxA and ArchaeopteryxE) and\n as a standalone application.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libforester-java","distribution":"prospective","release":"vcs","component":"main","version":"0.0+20180205","source":"forester","homepage":"https://github.com/cmzmasek/forester","description":"Libraries for evolutionary biology and comparative genomics research","long_description":" Forester is a library of Java software for phylogenomics \n and evolutionary biology research. It can be used to read or\n write phylogenetic trees, export trees to graphics file,...","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"freebayes","distribution":"debian","release":"sid","component":"main","version":"1.2.0","source":"freebayes","homepage":"https://github.com/ekg/freebayes","description":"Bayesian haplotype-based polymorphism discovery and genotyping","long_description":" FreeBayes is a Bayesian genetic variant detector designed to find\n small polymorphisms, specifically SNPs (single-nucleotide\n polymorphisms), indels (insertions and deletions), MNPs\n (multi-nucleotide polymorphisms), and complex events (composite\n insertion and substitution events) smaller than the length of a\n short-read sequencing alignment.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 1 / 28","doi":"arXiv:1207.3907","topics":null,"edam_scopes":null,"bio.agents":"freebayes","OMICagents":"OMICS_00059","SEQwiki":null,"SciCrunch":{"source":"freebayes","name":"SciCrunch","entry":"SCR_010761"},"RRID":null},{"package":"freecontact","distribution":"debian","release":"sid","component":"main","version":"1.0.21","source":"freecontact","homepage":"http://rostlab.org/","description":"fast protein contact predictor","long_description":" FreeContact is a protein residue contact predictor optimized for speed.\n Its input is a multiple sequence alignment. FreeContact can function as an\n accelerated drop-in for the published contact predictors\n EVfold-mfDCA of DS. Marks (2011) and\n PSICOV of D. Jones (2011).\n .\n FreeContact is accelerated by a combination of vector instructions, multiple\n threads, and faster implementation of key parts.\n Depending on the alignment, 8-fold or higher speedups are possible.\n .\n A sufficiently large alignment is required for meaningful results.\n As a minimum, an alignment with an effective (after-weighting) sequence count\n bigger than the length of the query sequence should be used. Alignments with\n tens of thousands of (effective) sequences are considered good input.\n .\n jackhmmer(1) from the hmmer package, or hhblits(1) from hhsuite\n can be used to generate the alignments, for example.\n .\n This package contains the command line agent freecontact(1).\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"10 / 3 / 116","doi":"10.1186/1471-2105-15-85","topics":["Structure prediction","Sequence analysis"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Sequence alignment (protein)", "format": ["A2M"]}], "outputs": [{"data": "Protein contact map", "format": ["BioXSD (XML)", "Textual format"]}], "function": ["Residue interaction prediction", "Protein contact map calculation"]}],"bio.agents":null,"OMICagents":"OMICS_03520","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libfreecontact-dev","distribution":"debian","release":"sid","component":"main","version":"1.0.21","source":"freecontact","homepage":"http://rostlab.org/","description":"fast protein contact predictor library - development files","long_description":" FreeContact is a protein residue contact predictor optimized for speed.\n Its input is a multiple sequence alignment. FreeContact can function as an\n accelerated drop-in for the published contact predictors\n EVfold-mfDCA of DS. Marks (2011) and\n PSICOV of D. Jones (2011).\n .\n FreeContact is accelerated by a combination of vector instructions, multiple\n threads, and faster implementation of key parts.\n Depending on the alignment, 8-fold or higher speedups are possible.\n .\n A sufficiently large alignment is required for meaningful results.\n As a minimum, an alignment with an effective (after-weighting) sequence count\n bigger than the length of the query sequence should be used. Alignments with\n tens of thousands of (effective) sequences are considered good input.\n .\n jackhmmer(1) from the hmmer package, or hhblits(1) from hhsuite\n can be used to generate the alignments, for example.\n .\n This package contains files necessary for developing applications with\n libfreecontact.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 29","doi":"10.1186/1471-2105-15-85","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_03520","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libfreecontact-doc","distribution":"debian","release":"sid","component":"main","version":"1.0.21","source":"freecontact","homepage":"http://rostlab.org/","description":"documentation for libfreecontact","long_description":" FreeContact is a protein residue contact predictor optimized for speed.\n Its input is a multiple sequence alignment. FreeContact can function as an\n accelerated drop-in for the published contact predictors\n EVfold-mfDCA of DS. Marks (2011) and\n PSICOV of D. Jones (2011).\n .\n FreeContact is accelerated by a combination of vector instructions, multiple\n threads, and faster implementation of key parts.\n Depending on the alignment, 8-fold or higher speedups are possible.\n .\n A sufficiently large alignment is required for meaningful results.\n As a minimum, an alignment with an effective (after-weighting) sequence count\n bigger than the length of the query sequence should be used. Alignments with\n tens of thousands of (effective) sequences are considered good input.\n .\n jackhmmer(1) from the hmmer package, or hhblits(1) from hhsuite\n can be used to generate the alignments, for example.\n .\n This package contains HTML documentation for libfreecontact.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 4","doi":"10.1186/1471-2105-15-85","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_03520","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"fsa","distribution":"debian","release":"sid","component":"main","version":"1.15.9","source":"fsa","homepage":"http://fsa.sourceforge.net/","description":"Fast Statistical Alignment of protein, RNA or DNA sequences","long_description":" FSA is a probabilistic multiple sequence alignment algorithm which uses\n a \"distance-based\" approach to aligning homologous protein, RNA or DNA\n sequences. Much as distance-based phylogenetic reconstruction methods\n like Neighbor-Joining build a phylogeny using only pairwise divergence\n estimates, FSA builds a multiple alignment using only pairwise\n estimations of homology. This is made possible by the sequence annealing\n technique for constructing a multiple alignment from pairwise\n comparisons, developed by Ariel Schwartz.\n .\n FSA brings the high accuracies previously available only for\n small-scale analyses of proteins or RNAs to large-scale problems such as\n aligning thousands of sequences or megabase-long sequences. FSA\n introduces several novel methods for constructing better alignments:\n  * FSA uses machine-learning techniques to estimate gap and\n    substitution parameters on the fly for each set of input sequences.\n    This \"query-specific learning\" alignment method makes FSA very robust:\n    it can produce superior alignments of sets of homologous sequences\n    which are subject to very different evolutionary constraints.\n  * FSA is capable of aligning hundreds or even thousands of sequences\n    using a randomized inference algorithm to reduce the computational\n    cost of multiple alignment. This randomized inference can be over ten\n    times faster than a direct approach with little loss of accuracy.\n  * FSA can quickly align very long sequences using the \"anchor\n    annealing\" technique for resolving anchors and projecting them with\n    transitive anchoring. It then stitches together the alignment between\n    the anchors using the methods described above.\n  * The included GUI, MAD (Multiple Alignment Display), can display the\n    intermediate alignments produced by FSA, where each character is\n    colored according to the probability that it is correctly aligned\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"27 / 4 / 187","doi":"10.1371/journal.pcbi.1000392","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_01087","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"fsm-lite","distribution":"debian","release":"sid","component":"main","version":"1.0","source":"fsm-lite","homepage":"https://github.com/nvalimak/fsm-lite","description":"frequency-based string mining (lite)","long_description":" A singe-core implementation of frequency-based substring mining used in\n bioinformatics to extract substrings that discriminate two (or more)\n datasets inside high-throughput sequencing data.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 3 / 59","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_28406","SEQwiki":null,"SciCrunch":{"source":"fsm-lite","name":"SciCrunch","entry":"SCR_016115"},"RRID":null},{"package":"galaxy","distribution":"prospective","release":"vcs","component":"main","version":"16.10","source":"galaxy","homepage":"https://galaxyproject.org/","description":"scientific workflow and data integration platform for computational biology","long_description":" Galaxy is a scientific workflow, data integration, and data and analysis\n persistence and publishing platform that aims to make computational\n biology accessible to research scientists that do not have computer\n programming or systems administration experience. Although it was\n initially developed for genomics research, it is largely domain agnostic\n and is now used as a general bioinformatics workflow management system.","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 1","doi":"10.14806/ej.17.1.200","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"gamgi","distribution":"debian","release":"sid","component":"main","version":"0.17.3","source":"gamgi","homepage":"http://www.gamgi.org/","description":"General Atomistic Modelling Graphic Interface (GAMGI)","long_description":" The General Atomistic Modelling Graphic Interface (GAMGI) provides\n a graphical interface to build, view and analyze atomic structures.\n The program is aimed at the scientific community and provides a\n graphical interface to study atomic structures and to prepare images\n for presentations, and for teaching the atomic structure of matter.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"17 / 29 / 284","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_21302","SEQwiki":null,"SciCrunch":{"source":"gamgi","name":"SciCrunch","entry":"SCR_016116"},"RRID":null},{"package":"garli","distribution":"debian","release":"sid","component":"main","version":"2.1","source":"garli","homepage":"https://github.com/Ashod/garli","description":"phylogenetic analysis of molecular sequence data using maximum-likelihood","long_description":" GARLI, Genetic Algorithm for Rapid Likelihood Inference is a program for\n inferring phylogenetic trees. Using an approach similar to a classical\n genetic algorithm, it rapidly searches the space of evolutionary trees\n and model parameters to find the solution maximizing the likelihood\n score. It implements nucleotide, amino acid and codon-based models of\n sequence evolution, and runs on all platforms. The latest version adds\n support for partitioned models and morphology-like datatypes.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 3 / 63","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_04234","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"garlic","distribution":"debian","release":"sid","component":"main","version":"1.6","source":"garlic","homepage":"http://www.zucic.org/garlic/","description":"visualization program for biomolecules","long_description":" Garlic is written for the investigation of membrane proteins. It may be\n used to visualize other proteins, as well as some geometric objects.\n This version of garlic recognizes PDB format version 2.1. Garlic may\n also be used to analyze protein sequences.\n .\n It only depends on the X libraries, no other libraries are needed.\n .\n Features include:\n  - The slab position and thickness are visible in a small window.\n  - Atomic bonds as well as atoms are treated as independent drawable\n    objects.\n  - The atomic and bond colors depend on position. Five mapping modes\n    are available (as for slab).\n  - Capable to display stereo image.\n  - Capable to display other geometric objects, like membrane.\n  - Atomic information is available for atom covered by the mouse\n    pointer. No click required, just move the mouse pointer over the\n    structure!\n  - Capable to load more than one structure.\n  - Capable to draw Ramachandran plot, helical wheel, Venn diagram,\n    averaged hydrophobicity and hydrophobic moment plot.\n  - The command prompt is available at the bottom of the main window.\n    It is able to display one error message and one command string.\n","interface":["x11"],"biology":null,"fields":["biology","chemistry"],"use":["viewing"],"popcon":"17 / 12 / 389","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"Garlic","OMICagents":"OMICS_21303","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"gasic","distribution":"debian","release":"sid","component":"main","version":"0.0.r19","source":"gasic","homepage":"http://sourceforge.net/projects/gasic/","description":"genome abundance similarity correction","long_description":" One goal of sequencing based metagenomic analysis is the quantitative\n taxonomic assessment of microbial community compositions. However, the\n majority of approaches either quantify at low resolution (e.g. at phylum\n level) or have severe problems discerning highly similar species. Yet,\n accurate quantification on species level is desirable in applications\n such as metagenomic diagnostics or community comparison. GASiC is a\n method to correct read alignment results for the ambiguities imposed by\n similarities of genomes. It has superior performance over existing\n methods.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 2 / 90","doi":"10.1093/nar/gks803","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_01437","SEQwiki":null,"SciCrunch":{"source":"gasic","name":"SciCrunch","entry":"SCR_006765"},"RRID":null},{"package":"gatb-core","distribution":"debian","release":"sid","component":"main","version":"1.4.1+git20181225.44d5a44","source":"gatb-core","homepage":"https://github.com/GATB/gatb-core","description":"Genome Analysis Agentbox with de-Bruijn graph","long_description":" The GATB-CORE project provides a set of highly efficient\n algorithms to analyse NGS data sets. These methods enable\n the analysis of data sets of any size on multi-core desktop\n computers, including very huge amount of reads data coming\n from any kind of organisms such as bacteria, plants,\n animals and even complex samples (e.g. metagenomes).\n Read more about GATB at https://gatb.inria.fr/.\n By itself GATB-CORE is not an NGS data analysis agent.\n However, it can be used to create such agents. There already\n exist a set of ready-to-use agents relying on GATB-CORE\n library: see https://gatb.inria.fr/software/\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 8 / 16","doi":"10.1093/bioinformatics/btu406","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_04834","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libgatbcore-dev","distribution":"debian","release":"sid","component":"main","version":"1.4.1+git20181225.44d5a44","source":"gatb-core","homepage":"https://github.com/GATB/gatb-core","description":"development library of the Genome Analysis Agentbox","long_description":" The GATB-CORE project provides a set of highly efficient\n algorithms to analyse NGS data sets. These methods enable\n the analysis of data sets of any size on multi-core desktop\n computers, including very huge amount of reads data coming\n from any kind of organisms such as bacteria, plants,\n animals and even complex samples (e.g. metagenomes).\n Read more about GATB at https://gatb.inria.fr/.\n By itself GATB-CORE is not an NGS data analysis agent.\n However, it can be used to create such agents. There already\n exist a set of ready-to-use agents relying on GATB-CORE\n library: see https://gatb.inria.fr/software/\n .\n This package contains the static library and the header files\n of the gatb-core library.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 6 / 8","doi":"10.1093/bioinformatics/btu406","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_04834","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"gatk","distribution":"prospective","release":"vcs","component":"main","version":"4.0.8.1","source":"gatk","homepage":"https://www.broadinstitute.org/gatk/","description":"The Genome Analysis Agentkit","long_description":" The Genome Analysis Agentkit or GATK is a software package developed at\n the Broad Institute to analyze high-throughput sequencing data. The\n agentkit offers a wide variety of agents, with a primary focus on variant\n discovery and genotyping as well as strong emphasis on data quality\n assurance. Its robust architecture, powerful processing engine and\n high-performance computing features make it capable of taking on\n projects of any size.","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 1","doi":"10.1101/gr.107524.110","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"gbrowse","distribution":"debian","release":"sid","component":"main","version":"2.56","source":"gbrowse","homepage":"http://www.gbrowse.org/","description":"GMOD Generic Genome Browser","long_description":" Generic Genome Browser is a simple but highly\n configurable web-based genome browser. It is a component of the\n Generic Model Organism Systems Database project (GMOD).\n Some of its features:\n  * Simultaneous bird's eye and detailed views of the genome;\n  * Scroll, zoom, center;\n  * Attach arbitrary URLs to any annotation;\n  * Order and appearance of tracks are customizable by administrator and\n    end-user;\n  * Search by annotation ID, name, or comment;\n  * Supports third party annotation using GFF formats;\n  * Settings persist across sessions;\n  * DNA and GFF dumps;\n  * Connectivity to different databases, including BioSQL and Chado;\n  * Multi-language support;\n  * Third-party feature loading;\n  * Customizable plug-in architecture (e.g. run BLAST, dump & import many\n    formats, find oligonucleotides, design primers, create restriction maps,\n    edit features).\n","interface":["web"],"biology":null,"fields":["biology:bioinformatics","biology"],"use":["analysing","viewing"],"popcon":"59 / 0 / 73","doi":"10.1002/0471250953.bi0909s28","topics":null,"edam_scopes":null,"bio.agents":"gbrowse","OMICagents":"OMICS_00910","SEQwiki":null,"SciCrunch":{"source":"gbrowse","name":"SciCrunch","entry":"SCR_006829"},"RRID":null},{"package":"gdpc","distribution":"debian","release":"sid","component":"main","version":"2.2.5","source":"gdpc","homepage":"https://web.archive.org/web/20180212152753/http://www.frantz.fi/software/gdpc.php","description":"visualiser of molecular dynamic simulations","long_description":" gpdc is a graphical program for visualising output data from\n molecular dynamics simulations. It reads input in the standard xyz\n format, as well as other custom formats, and can output pictures of\n each frame in JPG or PNG format.\n","interface":["x11"],"biology":null,"fields":["biology","physics","biology:structural","chemistry"],"use":["viewing"],"popcon":"19 / 9 / 354","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_19946","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"gemma","distribution":"debian","release":"sid","component":"main","version":"0.98.1","source":"gemma","homepage":"http://www.xzlab.org/software.html","description":"Genome-wide Efficient Mixed Model Association","long_description":" GEMMA is the software implementing the Genome-wide Efficient Mixed\n Model Association algorithm for a standard linear mixed model and some\n of its close relatives for genome-wide association studies (GWAS):\n .\n  * It fits a univariate linear mixed model (LMM) for marker association\n    tests with a single phenotype to account for population stratification\n    and sample structure, and for estimating the proportion of variance in\n    phenotypes explained (PVE) by typed genotypes (i.e. \"chip heritability\").\n  * It fits a multivariate linear mixed model (mvLMM) for testing marker\n    associations with multiple phenotypes simultaneously while controlling\n    for population stratification, and for estimating genetic correlations\n    among complex phenotypes.\n  * It fits a Bayesian sparse linear mixed model (BSLMM) using Markov\n    chain Monte Carlo (MCMC) for estimating PVE by typed genotypes,\n    predicting phenotypes, and identifying associated markers by jointly\n    modeling all markers while controlling for population structure.\n  * It estimates variance component/chip heritability, and partitions\n    it by different SNP functional categories. In particular, it uses HE\n    regression or REML AI algorithm to estimate variance components when\n    individual-level data are available. It uses MQS to estimate variance\n    components when only summary statisics are available.\n .\n GEMMA is computationally efficient for large scale GWAS and uses freely\n available open-source numerical libraries.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 5 / 16","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"GEMMA7697","OMICagents":"OMICS_25985","SEQwiki":null,"SciCrunch":{"source":"gemma","name":"SciCrunch","entry":"SCR_008007"},"RRID":null},{"package":"genometester","distribution":"debian","release":"sid","component":"main","version":"4.0+git20180508.a9c14a6","source":"genometester","homepage":"https://github.com/bioinfo-ut/GenomeTester4","description":"agentkit for performing set operations on k-mer lists","long_description":" Agentkit for performing set operations - union, intersection and\n complement - on k-mer lists.\n .\n GenomeTester4 agentkit, which contains a novel agent GListCompare for\n performing union, intersection and complement (difference) set\n operations on k-mer lists. It contains examples of how these\n general operations can be combined to solve a variety of biological\n analysis tasks.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 7 / 16","doi":"10.1186/s13742-015-0097-y","topics":null,"edam_scopes":null,"bio.agents":"genometester","OMICagents":"OMICS_02363w","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"genomeagents","distribution":"debian","release":"sid","component":"main","version":"1.5.10+ds","source":"genomeagents","homepage":"http://genomeagents.org","description":"versatile genome analysis agentkit","long_description":" The GenomeAgents contains a collection of useful agents for biological\n sequence analysis and -presentation combined into a single binary.\n .\n The agentkit contains binaries for sequence and annotation handling, sequence\n compression, index structure generation and access, annotation visualization,\n and much more.\n","interface":["commandline"],"biology":["nuceleic-acids"],"fields":["biology:bioinformatics","biology"],"use":null,"popcon":"10 / 5 / 135","doi":"10.1109/TCBB.2013.68","topics":null,"edam_scopes":null,"bio.agents":"genomeagents","OMICagents":"OMICS_16119","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libgenomeagents0-dev","distribution":"debian","release":"sid","component":"main","version":"1.5.10+ds","source":"genomeagents","homepage":"http://genomeagents.org","description":"development files for GenomeAgents","long_description":" This package contains the GenomeAgents static library and necessary\n header files.\n .\n Besides basic bioinformatics data structures, the library contains components\n for sequence and annotation handling, sequence compression, index structure\n generation and access, efficient matching, annotation visualization and much\n more.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 39","doi":"10.1109/TCBB.2013.68","topics":null,"edam_scopes":null,"bio.agents":"genomeagents","OMICagents":"OMICS_16119","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"gentle","distribution":"debian","release":"sid","component":"main","version":"1.9+cvs20100605","source":"gentle","homepage":"http://gentle.magnusmanske.de","description":"suite to plan genetic cloning","long_description":" GENtle is a software for DNA and amino acid editing, database management,\n plasmid maps, restriction and ligation, alignments, sequencer data\n import, calculators, gel image display, PCR, and much more.\n","interface":["x11"],"biology":["nuceleic-acids","peptidic"],"fields":["biology","biology:bioinformatics"],"use":null,"popcon":"8 / 8 / 85","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_18307","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"getdata","distribution":"debian","release":"sid","component":"main","version":"0.2","source":"getdata","homepage":"http://debian-med.alioth.debian.org","description":"management of external databases","long_description":" Many scientific communities share the problem of regularly updating\n external databases. With every update, also various tasks need to\n be performed for the update of indices that need to be recreated.\n This work depends on the agents that are available locally and is\n not always completely simple.\n .\n This package provides the getData Perl script, which in some not\n so complicated manner performs the invocation to wget to download\n data and then knows how to perform the indexing. There is only\n a hash table to be filled with the commands to be executed.\n Maintainers of scientific packages that are strongly coupled to\n public datasets are invited to add a runtime dependency to this\n package and add instructions for getData to follow.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 1 / 28","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python3-gfapy","distribution":"debian","release":"sid","component":"main","version":"1.0.0","source":"gfapy","homepage":"https://github.com/ggonnella/gfapy","description":"flexible and extensible software library for handling sequence graphs","long_description":" The Graphical Fragment Assembly (GFA) are formats for the representation of\n sequence graphs, including assembly, variation and splicing graphs. Two\n versions of GFA have been defined (GFA1 and GFA2) and several sequence\n analysis programs have been adopting the formats as an interchange format,\n which allow the user to easily combine different sequence analysis agents.\n .\n This library implements the GFA1 and GFA2 specification. It is possible to\n create a Gfa object from a file in the GFA format or from scratch, to\n enumerate the graph elements (segments, links, containments, paths and header\n lines), to traverse the graph (by traversing all links outgoing from or\n incoming to a segment), to search for elements (e.g. which links connect two\n segments) and to manipulate the graph (e.g. to eliminate a link or a segment\n or to duplicate a segment distributing the read counts evenly on the copies).\n .\n The GFA format can be easily extended by users by defining own custom tags\n and record types. In Gfapy, it is easy to write extensions modules, which\n allow one to define custom record types and datatypes for the parsing and\n validation of custom fields. The custom lines can be connected, using\n references, to each other and to lines of the standard record types.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 1 / 7","doi":"10.1093/bioinformatics/btx398","topics":null,"edam_scopes":null,"bio.agents":"gfapy","OMICagents":"OMICS_19577","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"gff2aplot","distribution":"debian","release":"sid","component":"main","version":"2.0","source":"gff2aplot","homepage":"http://genome.imim.es/software/gffagents/GFF2APLOT.html","description":"pair-wise alignment-plots for genomic sequences in PostScript","long_description":" A program to visualize the alignment of two genomic sequences together with\n their annotations. From GFF-format input files it produces PostScript figures\n for that alignment.\n The following menu lists many features of gff2aplot:\n  * Comprehensive alignment plots for any GFF-feature. Attributes are defined\n    separately so you can modify only whatsoever attributes for a given file or\n    share same customization across different data-sets.\n  * All parameters are set by default within the program, but it can be also\n    fully configured via gff2ps-like flexible customization files. Program can\n    handle several of such files, summarizing all the settings before producing\n    the corresponding figure. Moreover, all customization parameters can be set\n    via command-line switches, which allows users to play with those parameters\n    before adding any to a customization file.\n  * Source order is taken from input files, if you swap file order you can\n    visualize alignment and its annotation with the new input arrangement.\n  * All alignment scores can be visualized in a PiP box below gff2aplot area,\n    using grey-color scale, user-defined color scale or score-dependent\n    gradients.\n  * Scalable fonts, which can also be chosen among the basic PostScript default\n    fonts. Feature and group labels can be rotated to improve readability in\n    both annotation axes.\n  * The program is still defined as a Unix filter so it can handle data from\n    files, redirections and pipes, writing output to standard-output and\n    warnings to standard error.\n  * gff2aplot is able to manage many physical page formats (from A0 to A10, and\n    more -see available page sizes in its manual-), including user-defined ones.\n    This allows, for instance, the generation of poster size genomic maps, or\n    the use of a continuous-paper supporting plotting device, either in portrait\n    or landscape.\n  * You can draw different alignments on same alignment plot and distinguish\n    them by using different colors for each.\n  * Shape dictionary has been expanded, so that further feature shapes are now\n    available (see manual).\n  * Annotation projections through alignment plots (so called ribbons) emulate\n    transparencies via complementary color fill patterns. This feature allows\n    one to show color pseudo-blending when horizontal and vertical ribbons\n    overlap.\n","interface":["commandline","shell"],"biology":null,"fields":["biology","biology:bioinformatics"],"use":["converting","viewing"],"popcon":"8 / 10 / 96","doi":"10.1093/bioinformatics/btg334","topics":null,"edam_scopes":null,"bio.agents":"gff2aplot","OMICagents":"OMICS_19949","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"gff2ps","distribution":"debian","release":"sid","component":"main","version":"0.98l","source":"gff2ps","homepage":"http://genome.imim.es/software/gffagents/GFF2PS.html","description":"produces PostScript graphical output from GFF-files","long_description":" gff2ps is a script program developed with the aim of converting gff-formatted\n records into high quality one-dimensional plots in PostScript. Such plots\n maybe useful for comparing genomic structures and to visualizing outputs from\n genome annotation programs.\n It can be used in a very simple way, because it assumes that the GFF file\n itself carries enough formatting information, but it also allows through a\n number of options and/or a configuration file, for a great degree of\n customization.\n","interface":["commandline"],"biology":null,"fields":["biology","biology:bioinformatics"],"use":["converting","viewing"],"popcon":"10 / 3 / 104","doi":"10.1093/bioinformatics/16.8.743","topics":null,"edam_scopes":null,"bio.agents":"gff2ps","OMICagents":"OMICS_17140","SEQwiki":null,"SciCrunch":{"source":"gff2ps","name":"SciCrunch","entry":"SCR_000462"},"RRID":null},{"package":"ghemical","distribution":"debian","release":"sid","component":"main","version":"3.0.0","source":"ghemical","homepage":"http://bioinformatics.org/ghemical/ghemical/","description":"GNOME molecular modelling environment","long_description":" Ghemical is a computational chemistry software package written in C++.\n It has a graphical user interface and it supports both quantum-\n mechanics (semi-empirical) models and molecular mechanics models.\n Geometry optimization, molecular dynamics and a large set of\n visualization agents using OpenGL are currently available.\n .\n Ghemical relies on external code to provide the quantum-mechanical\n calculations. Semi-empirical methods MNDO, MINDO/3, AM1 and PM3 come\n from the MOPAC7 package (Public Domain), and are included in the\n package. The MPQC package is used to provide ab initio methods: the\n methods based on Hartree-Fock theory are currently supported with\n basis sets ranging from STO-3G to 6-31G**.\n","interface":["3d","x11"],"biology":null,"fields":["chemistry"],"use":["editing","learning","viewing"],"popcon":"20 / 16 / 234","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"Ghemical","OMICagents":"OMICS_21304","SEQwiki":null,"SciCrunch":{"source":"ghemical","name":"SciCrunch","entry":"SCR_014899"},"RRID":null},{"package":"ghmm","distribution":"debian","release":"sid","component":"main","version":"0.9~rc3","source":"ghmm","homepage":"https://ghmm.org","description":"General Hidden-Markov-Model library - agents","long_description":" The General Hidden Markov Model Library (GHMM) is a C library with\n additional Python bindings implementing a wide range of types of\n Hidden Markov Models and algorithms: discrete, continuous emissions,\n basic training, HMM clustering, HMM mixtures.\n .\n This package contains some agents using the library.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 7 / 14","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_31014","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"giira","distribution":"debian","release":"sid","component":"main","version":"0.0.20140625","source":"giira","homepage":"http://sourceforge.net/projects/giira/","description":"RNA-Seq driven gene finding incorporating ambiguous reads","long_description":" GIIRA is a gene prediction method that identifies potential coding\n regions exclusively based on the mapping of reads from an RNA-Seq\n experiment.  It was foremost designed for prokaryotic gene prediction\n and is able to resolve genes within the expressed region of an operon.\n However, it is also applicable to eukaryotes and predicts exon intron\n structures as well as alternative isoforms.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 3 / 99","doi":"10.1093/bioinformatics/btt577","topics":null,"edam_scopes":null,"bio.agents":"GIIRA","OMICagents":"OMICS_07360","SEQwiki":null,"SciCrunch":{"source":"giira","name":"SciCrunch","entry":"SCR_015507"},"RRID":null},{"package":"glam2","distribution":"debian","release":"sid","component":"main","version":"1064","source":"glam2","homepage":"http://acb.qfab.org/acb/glam2/","description":"gapped protein motifs from unaligned sequences","long_description":" GLAM2 is a software package for finding motifs in sequences, typically\n amino-acid or nucleotide sequences. A motif is a re-occurring sequence\n pattern: typical examples are the TATA box and the CAAX prenylation motif. The\n main innovation of GLAM2 is that it allows insertions and deletions in motifs.\n .\n This package includes programs for discovering motifs shared by a set of\n sequences and finding matches to these motifs in a sequence database, as well\n as utilities for converting glam2 motifs to standard alignment formats,\n masking glam2 motifs out of sequences so that weaker motifs can be found, and\n removing highly similar members of a set of sequences.\n .\n The package includes these programs:\n  glam2:       discovering motifs shared by a set of sequences;\n  glam2scan:   finding matches, in a sequence database, to a motif discovered\n               by glam2;\n  glam2format: converting glam2 motifs to  standard alignment formats;\n  glam2mask:   masking glam2 motifs out of sequences, so that weaker motifs\n               can be found;\n  glam2-purge: removing highly similar members of a set of sequences.\n .\n In this binary package, the fast Fourier algorithm (FFT) was enabled for the\n glam2 program.\n","interface":["commandline"],"biology":null,"fields":["biology:bioinformatics","biology"],"use":["searching","analysing","comparing"],"popcon":"9 / 3 / 93","doi":"10.1371/journal.pcbi.1000071","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_06281","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"gmap","distribution":"debian","release":"sid","component":"non-free","version":"2019-01-24","source":"gmap","homepage":"http://research-pub.gene.com/gmap","description":"spliced and SNP-tolerant alignment for mRNA and short reads","long_description":" This package contains the programs GMAP and GSNAP as well as\n utilities to manage genome databases in GMAP/GSNAP format.\n GMAP (Genomic Mapping and Alignment Program) is a agent for aligning\n EST, mRNA and cDNA sequences.\n GSNAP (Genomic Short-read Nucleotide Alignment Program) is a agent for\n aligning single-end and paired-end transcriptome reads.\n Both agents can use a database of\n  * known splice sites and identify novel splice sites.\n  * known single-nucleotide polymorphisms (SNPs).\n GSNAP can align bisulfite-treated DNA.\n","interface":null,"biology":null,"fields":["biology","biology:bioinformatics","biology:structural"],"use":["analysing"],"popcon":"1 / 2 / 18","doi":"10.1093/bioinformatics/bti310","topics":null,"edam_scopes":null,"bio.agents":"gmap","OMICagents":"OMICS_15072","SEQwiki":null,"SciCrunch":{"source":"gmap","name":"SciCrunch","entry":"SCR_008992"},"RRID":null},{"package":"grabix","distribution":"debian","release":"sid","component":"main","version":"0.1.7","source":"grabix","homepage":"https://github.com/arq5x/grabix","description":"wee agent for random access into BGZF files","long_description":" In biomedical research it is increasing practice to study\n the genetic basis of disease. This now frequently comprises\n the sequencing of human sequences. The output of the machine\n however is redundant, and the real sequence is the best\n sequence to explain the redundancy. The exchange of data\n happens only with compressed files - to huge and redundant\n to perform otherwise. One should avoid uncompression whenever\n possible.\n .\n grabix leverages the fantastic BGZF library of the samagents\n package to provide random access into text files that have\n been compressed with bgzip. grabix creates it's own index\n (.gbi) of the bgzipped file. Once indexed, one can extract\n arbitrary lines from the file with the grab command. Or\n choose random lines with the, well, random command.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 1 / 19","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_29590","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"gramalign","distribution":"prospective","release":"vcs","component":"non-free","version":"3.0","source":"gramalign","homepage":"http://bioinfo.unl.edu/gramalign.php","description":"multiple alignment of biological sequences","long_description":" GramAlign is a time-efficient progressive Multiple Sequence Alignment\n (MSA) algorithm. The novelty of GramAlign comes from the sequence\n distance estimation step, whereby distances are determined by the\n natural grammar present in nucleotide and amino acid sequences.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1186/1471-2105-9-306","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_05314","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"graphlan","distribution":"debian","release":"sid","component":"main","version":"1.1.3","source":"graphlan","homepage":"https://bitbucket.org/nsegata/graphlan/wiki/Home","description":"circular representations of taxonomic and phylogenetic trees","long_description":" GraPhlAn is a software agent for producing high-quality circular\n representations of taxonomic and phylogenetic trees. It focuses on\n concise, integrative, informative, and publication-ready representations\n of phylogenetically- and taxonomically-driven investigation.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 3 / 63","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_11549","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"grinder","distribution":"debian","release":"sid","component":"main","version":"0.5.4","source":"grinder","homepage":"https://sourceforge.net/projects/biogrinder/","description":"Versatile omics shotgun and amplicon sequencing read simulator","long_description":" Grinder is a versatile program to create random shotgun and amplicon sequence\n libraries based on DNA, RNA or proteic reference sequences provided in a\n FASTA file.\n .\n Grinder can produce genomic, metagenomic, transcriptomic, metatranscriptomic,\n proteomic, metaproteomic shotgun and amplicon datasets from current\n sequencing technologies such as Sanger, 454, Illumina. These simulated\n datasets can be used to test the accuracy of bioinformatic agents under\n specific hypothesis, e.g. with or without sequencing errors, or with low or\n high community diversity. Grinder may also be used to help decide between\n alternative sequencing methods for a sequence-based project, e.g. should the\n library be paired-end or not, how many reads should be sequenced.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 3 / 87","doi":"10.1093/nar/gks251","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_01508","SEQwiki":null,"SciCrunch":{"source":"grinder","name":"SciCrunch","entry":"SCR_000168"},"RRID":null},{"package":"gromacs","distribution":"debian","release":"sid","component":"main","version":"2019.1","source":"gromacs","homepage":"http://www.gromacs.org/","description":"Molecular dynamics simulator, with building and analysis agents","long_description":" GROMACS is a versatile package to perform molecular dynamics, i.e. simulate\n the Newtonian equations of motion for systems with hundreds to millions of\n particles.\n .\n It is primarily designed for biochemical molecules like proteins and lipids\n that have a lot of complicated bonded interactions, but since GROMACS is\n extremely fast at calculating the nonbonded interactions (that usually\n dominate simulations) many groups are also using it for research on non-\n biological systems, e.g. polymers.\n","interface":["commandline","x11"],"biology":null,"fields":["biology","chemistry","biology:structural"],"use":null,"popcon":"29 / 51 / 491","doi":"10.1021/ct700301q","topics":null,"edam_scopes":null,"bio.agents":"gromacs","OMICagents":"OMICS_05081","SEQwiki":null,"SciCrunch":{"source":"gromacs","name":"SciCrunch","entry":"SCR_014565"},"RRID":null},{"package":"gubbins","distribution":"debian","release":"sid","component":"main","version":"2.3.4","source":"gubbins","homepage":"https://sanger-pathogens.github.io/gubbins/","description":"phylogenetic analysis of genome sequences","long_description":" Gubbins supports rapid phylogenetic analysis of large samples of\n recombinant bacterial whole genome sequences.\n .\n Gubbins (Genealogies Unbiased By recomBinations In Nucleotide\n Sequences) is an algorithm that iteratively identifies loci containing\n elevated densities of base substitutions while concurrently constructing\n a phylogeny based on the putative point mutations outside of these\n regions. Simulations demonstrate the algorithm generates highly accurate\n reconstructions under realistic models of short-term bacterial\n evolution, and can be run in only a few hours on alignments of hundreds\n of bacterial genome sequences.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"12 / 2 / 61","doi":"10.1093/nar/gku1196","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_14386","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"gwama","distribution":"debian","release":"sid","component":"main","version":"2.2.2","source":"gwama","homepage":"https://www.geenivaramu.ee/en/agents/gwama","description":"Genome-Wide Association Meta Analysis","long_description":" GWAMA (Genome-Wide Association Meta Analysis) software performs\n meta-analysis of the results of GWA studies of binary or\n quantitative phenotypes. Fixed- and random-effect meta-analyses are\n performed for both directly genotyped and imputed SNPs using\n estimates of the allelic odds ratio and 95% confidence interval for\n binary traits, and estimates of the allelic effect size and standard\n error for quantitative phenotypes. GWAMA can be used for analysing\n the results of all different genetic models (multiplicative,\n additive, dominant, recessive). The software incorporates error\n trapping facilities to identify strand alignment errors and allele\n flipping, and performs tests of heterogeneity of effects between studies.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 3 / 67","doi":"10.1186/1471-2105-11-288","topics":null,"edam_scopes":null,"bio.agents":"GWAMA","OMICagents":"OMICS_00235","SEQwiki":null,"SciCrunch":{"source":"gwama","name":"SciCrunch","entry":"SCR_006624"},"RRID":null},{"package":"haploview","distribution":"prospective","release":"vcs","component":"contrib","version":"4.1","source":"haploview","homepage":"https://www.broadinstitute.org/haploview/haploview","description":"Analysis and visualization of LD and haplotype maps","long_description":" This agents assists in the analysis of the nucleotide\n variation in a population. Such investigations are performed\n to determine genes and genetic pathways that are associated\n with diseases. This is an early stage in the quest for new drugs.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1101/pdb.ip71","topics":null,"edam_scopes":null,"bio.agents":"HaploView","OMICagents":"OMICS_09142","SEQwiki":null,"SciCrunch":{"source":"haploview","name":"SciCrunch","entry":"SCR_003076"},"RRID":null},{"package":"harvest-agents","distribution":"debian","release":"sid","component":"main","version":"1.3","source":"harvest-agents","homepage":"http://harvest.readthedocs.org/en/latest/content/harvest-agents.html","description":"archiving and postprocessing for reference-compressed genomic multi-alignments","long_description":" HarvestAgents is a utility for creating and interfacing with Gingr files,\n which are efficient archives that the Harvest Suite uses to store\n reference-compressed multi-alignments, phylogenetic trees, filtered\n variants and annotations. Though designed for use with Parsnp and Gingr,\n HarvestAgents can also be used for generic conversion between standard\n bioinformatics file formats.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 5 / 62","doi":"10.1101/007351","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_08468","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"hhsuite","distribution":"debian","release":"sid","component":"main","version":"3.0~beta3","source":"hhsuite","homepage":"https://agentkit.tuebingen.mpg.de/","description":"sensitive protein sequence searching based on HMM-HMM alignment","long_description":" HH-suite is an open-source software package for sensitive protein sequence\n searching based on the pairwise alignment of hidden Markov models (HMMs).\n .\n This package contains HHsearch and HHblits among other programs and utilities.\n .\n HHsearch takes as input a multiple sequence alignment (MSA) or profile HMM\n and searches a database of HMMs (e.g. PDB, Pfam, or InterPro) for homologous\n proteins. HHsearch is often used for protein structure prediction to detect\n homologous templates and to build highly accurate query-template pairwise\n alignments for homology modeling.\n .\n HHblits can build high-quality MSAs starting from single sequences or from\n MSAs. It transforms these into a query HMM and, using an iterative search\n strategy, adds significantly similar sequences from the previous search to\n the updated query HMM for the next search iteration. Compared to PSI-BLAST,\n HHblits is faster, up to twice as sensitive and produces more accurate\n alignments.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 17 / 109","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"hilive","distribution":"debian","release":"sid","component":"main","version":"1.1","source":"hilive","homepage":"https://gitlab.com/SimonHTausch/HiLive","description":"realtime alignment of Illumina reads","long_description":" HiLive is a read mapping agent that maps Illumina HiSeq (or comparable)\n reads to a reference genome right in the moment when they are produced.\n This means, read mapping is finished as soon as the sequencer is\n finished generating the data.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 5 / 62","doi":"10.1093/bioinformatics/btw659","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_13393","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"hinge","distribution":"debian","release":"sid","component":"main","version":"0.5.0","source":"hinge","homepage":"https://github.com/HingeAssembler/HINGE","description":"long read genome assembler based on hinging","long_description":" HINGE is a genome assembler that seeks to achieve optimal repeat resolution\n by distinguishing repeats that can be resolved given the data from those that\n cannot. This is accomplished by adding “hinges” to reads for constructing an\n overlap graph where only unresolvable repeats are merged. As a result, HINGE\n combines the error resilience of overlap-based assemblers with\n repeat-resolution capabilities of de Bruijn graph assemblers.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 1 / 9","doi":"10.1101/gr.216465.116","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_12339","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"hisat2","distribution":"debian","release":"sid","component":"main","version":"2.1.0","source":"hisat2","homepage":"https://ccb.jhu.edu/software/hisat2/index.shtml","description":"graph-based alignment of short nucleotide reads to many genomes","long_description":" HISAT2 is a fast and sensitive alignment program for mapping next-generation\n sequencing reads (both DNA and RNA) to a population of human genomes (as well\n as against a single reference genome). Based on an extension of BWT for graphs\n a graph FM index (GFM) was designed and implementd. In addition to using\n one global GFM index that represents a population of human genomes, HISAT2\n uses a large set of small GFM indexes that collectively cover the whole genome\n (each index representing a genomic region of 56 Kbp, with 55,000 indexes\n needed to cover the human population). These small indexes (called local\n indexes), combined with several alignment strategies, enable rapid and\n accurate alignment of sequencing reads. This new indexing scheme is called a\n Hierarchical Graph FM index (HGFM).\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 3 / 79","doi":"10.1038/nmeth.3317","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_07225","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"hmmer","distribution":"debian","release":"sid","component":"main","version":"3.2.1","source":"hmmer","homepage":"http://hmmer.org/","description":"profile hidden Markov models for protein sequence analysis","long_description":" HMMER is an implementation of profile hidden Markov model methods for\n sensitive searches of biological sequence databases using multiple sequence\n alignments as queries.\n .\n Given a multiple sequence alignment as input, HMMER builds a statistical\n model called a \"hidden Markov model\" which can then be used as a query into\n a sequence database to find (and/or align) additional homologues of the\n sequence family.\n","interface":["commandline"],"biology":["format:aln","peptidic"],"fields":["biology:bioinformatics","biology"],"use":["searching"],"popcon":"38 / 28 / 934","doi":"10.1093/bioinformatics/14.9.755","topics":null,"edam_scopes":null,"bio.agents":"HMMER","OMICagents":"OMICS_00996","SEQwiki":null,"SciCrunch":{"source":"hmmer","name":"SciCrunch","entry":"SCR_005305"},"RRID":null},{"package":"hmmer2","distribution":"debian","release":"sid","component":"main","version":"2.3.2","source":"hmmer2","homepage":"http://hmmer.janelia.org/","description":"profile hidden Markov models for protein sequence analysis","long_description":" HMMER is an implementation of profile hidden Markov model methods for\n sensitive searches of biological sequence databases using multiple sequence\n alignments as queries.\n .\n Given a multiple sequence alignment as input, HMMER builds a statistical\n model called a \"hidden Markov model\" which can then be used as a query into\n a sequence database to find (and/or align) additional homologues of the\n sequence family.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"14 / 3 / 131","doi":"10.1093/bioinformatics/14.9.755","topics":null,"edam_scopes":null,"bio.agents":"HMMER","OMICagents":"OMICS_00996","SEQwiki":null,"SciCrunch":{"source":"hmmer2","name":"SciCrunch","entry":"SCR_005305"},"RRID":null},{"package":"htqc","distribution":"prospective","release":"vcs","component":"main","version":"1.92.3","source":"htqc","homepage":"http://sourceforge.net/projects/htqc/","description":"Quality control and filtration for illumina sequencing data","long_description":" HTQC is a agentkit including statistics agent for illumina high-throughput\n sequencing data, and filtration agents for sequence quality, length, tail\n quality, etc..","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1186/1471-2105-14-33","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_01052","SEQwiki":null,"SciCrunch":{"source":"htqc","name":"SciCrunch","entry":"SCR_006448"},"RRID":null},{"package":"python-htseq","distribution":"debian","release":"sid","component":"main","version":"0.11.2","source":"htseq","homepage":"http://www-huber.embl.de/users/anders/HTSeq/doc/overview.html","description":"Python high-throughput genome sequencing read analysis utilities","long_description":" HTSeq can be used to performing a number of common analysis tasks\n when working with high-throughput genome sequencing reads:\n .\n   * Getting statistical summaries about the base-call quality scores to\n     study the data quality.\n   * Calculating a coverage vector and exporting it for visualization in\n     a genome browser.\n   * Reading in annotation data from a GFF file.\n   * Assigning aligned reads from an RNA-Seq experiments to exons and\n     genes.\n .\n This package contains the Python 2 module.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 5 / 120","doi":"10.1093/bioinformatics/btu638","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libhtsjdk-java","distribution":"debian","release":"sid","component":"main","version":"2.18.2","source":"htsjdk","homepage":"http://samagents.github.io/htsjdk/","description":"Java API for high-throughput sequencing data (HTS) formats","long_description":" HTSJDK is an implementation of a unified Java library for accessing common\n file formats, such as SAM (Sequence Alignment/Map) and VCF, used for\n high-throughput sequencing data. There are also an number of useful utilities\n for manipulating HTS data.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"27 / 37 / 244","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libhts-dev","distribution":"debian","release":"sid","component":"main","version":"1.9","source":"htslib","homepage":"https://github.com/samagents/htslib","description":"development files for the HTSlib","long_description":" HTSlib is an implementation of a unified C library for accessing common file\n formats, such as SAM (Sequence Alignment/Map), CRAM and VCF (Variant Call\n Format), used for high-throughput sequencing data, and is the core library\n used by samagents and bcfagents. HTSlib only depends on zlib. It is known to be\n compatible with gcc, g++ and clang.\n .\n HTSlib implements a generalized BAM (binary SAM) index, with file extension\n ‘csi’ (coordinate-sorted index). The HTSlib file reader first looks for the\n new index and then for the old if the new index is absent.\n .\n This package contains development files for the HTSlib: headers, static\n library, manual pages, etc.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 13 / 73","doi":"10.1093/bioinformatics/btq671","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_13459","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"tabix","distribution":"debian","release":"sid","component":"main","version":"1.9","source":"htslib","homepage":"https://github.com/samagents/htslib","description":"generic indexer for TAB-delimited genome position files","long_description":" Tabix indexes files where some columns indicate sequence coordinates: name\n (usually a chromosome), start and stop. The input data file must be position\n sorted and compressed by bgzip (provided in this package), which has a gzip\n like interface. After indexing, tabix is able to quickly retrieve data lines by\n chromosomal coordinates. Fast data retrieval also works over network if an URI\n is given as a file name.\n .\n This version of tabix is built from the HTSlib source.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"24 / 27 / 238","doi":"10.1093/bioinformatics/btq671","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_13459","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"hyphy-mpi","distribution":"debian","release":"sid","component":"main","version":"2.3.14","source":"hyphy","homepage":"http://hyphy.org/","description":"Hypothesis testing using Phylogenies (MPI version)","long_description":" HyPhy is an open-source software package for the analysis of genetic\n sequences using techniques in phylogenetics, molecular evolution, and\n machine learning. It features a complete graphical user interface (GUI)\n and a rich scripting language for limitless customization of analyses.\n Additionally, HyPhy features support for parallel computing environments\n (via message passing interface) and it can be compiled as a shared\n library and called from other programming environments such as Python or\n R.  Continued development of HyPhy is currently supported in part by an\n NIGMS R01 award 1R01GM093939.\n .\n This package provides an executable using MPI to do multiprocessing.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"14 / 4 / 161","doi":"10.1093/bioinformatics/bti079","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_04235","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"hyphy-pt","distribution":"debian","release":"sid","component":"main","version":"2.3.14","source":"hyphy","homepage":"http://hyphy.org/","description":"Hypothesis testing using Phylogenies (pthreads version)","long_description":" HyPhy is an open-source software package for the analysis of genetic\n sequences using techniques in phylogenetics, molecular evolution, and\n machine learning. It features a complete graphical user interface (GUI)\n and a rich scripting language for limitless customization of analyses.\n Additionally, HyPhy features support for parallel computing environments\n (via message passing interface) and it can be compiled as a shared\n library and called from other programming environments such as Python or\n R.  Continued development of HyPhy is currently supported in part by an\n NIGMS R01 award 1R01GM093939.\n .\n This package provides an executable using pthreads to do multiprocessing.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 1 / 7","doi":"10.1093/bioinformatics/bti079","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_04235","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"idba","distribution":"debian","release":"sid","component":"main","version":"1.1.3","source":"idba","homepage":"https://github.com/loneknightpy/idba","description":"iterative De Bruijn Graph short read assemblers","long_description":" IDBA stands for iterative de Bruijn graph assembler. In computational\n sequence biology, an assembler solves the puzzle coming from large\n sequencing machines that feature many gigabytes of short reads from a\n large genome.\n .\n This package provides several flavours of the IDBA assembler, as they all\n share the same source tree but serve different purposes and evolved over time.\n .\n IDBA is the basic iterative de Bruijn graph assembler for\n second-generation sequencing reads. IDBA-UD, an extension of IDBA,\n is designed to utilize paired-end reads to assemble low-depth regions\n and use progressive depth on contigs to reduce errors in high-depth\n regions. It is a generic purpose assembler and especially good for\n single-cell and metagenomic sequencing data. IDBA-Hybrid is another\n update version of IDBA-UD, which can make use of a similar reference\n genome to improve assembly result. IDBA-Tran is an iterative de Bruijn\n graph assembler for RNA-Seq data.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"11 / 3 / 114","doi":"10.1093/bioinformatics/bts174","topics":null,"edam_scopes":null,"bio.agents":"IDBA","OMICagents":"OMICS_01318","SEQwiki":null,"SciCrunch":{"source":"idba","name":"SciCrunch","entry":"SCR_011912"},"RRID":null},{"package":"idba","distribution":"debian","release":"sid","component":"main","version":"1.1.3","source":"idba","homepage":"https://github.com/loneknightpy/idba","description":"iterative De Bruijn Graph short read assemblers","long_description":" IDBA stands for iterative de Bruijn graph assembler. In computational\n sequence biology, an assembler solves the puzzle coming from large\n sequencing machines that feature many gigabytes of short reads from a\n large genome.\n .\n This package provides several flavours of the IDBA assembler, as they all\n share the same source tree but serve different purposes and evolved over time.\n .\n IDBA is the basic iterative de Bruijn graph assembler for\n second-generation sequencing reads. IDBA-UD, an extension of IDBA,\n is designed to utilize paired-end reads to assemble low-depth regions\n and use progressive depth on contigs to reduce errors in high-depth\n regions. It is a generic purpose assembler and especially good for\n single-cell and metagenomic sequencing data. IDBA-Hybrid is another\n update version of IDBA-UD, which can make use of a similar reference\n genome to improve assembly result. IDBA-Tran is an iterative de Bruijn\n graph assembler for RNA-Seq data.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"11 / 3 / 114","doi":"10.1093/bioinformatics/bts174","topics":null,"edam_scopes":null,"bio.agents":"IDBA","OMICagents":"OMICS_01423","SEQwiki":null,"SciCrunch":{"source":"idba","name":"SciCrunch","entry":"SCR_011912"},"RRID":null},{"package":"igor","distribution":"debian","release":"sid","component":"main","version":"1.3.0","source":"igor","homepage":"https://github.com/qmarcou/IGoR/","description":"infers V(D)J recombination processes from sequencing data","long_description":" IGoR (Inference and Generation of Repertoires) is a versatile software\n to analyze and model immune receptors generation, selection, mutation\n and all other processes.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1038/s41467-018-02832-w","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_18534","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"igv","distribution":"debian","release":"sid","component":"non-free","version":"2.4.17","source":"igv","homepage":"http://www.broadinstitute.org/igv/","description":"Integrative Genomics Viewer","long_description":" The Integrative Genomics Viewer (IGV) is a high-performance viewer that\n efficiently handles large heterogeneous data sets, while providing a\n smooth and intuitive user experience at all levels of genome resolution.\n A key characteristic of IGV is its focus on the integrative nature of\n genomic studies, with support for both array-based and next-generation\n sequencing data, and the integration of clinical and phenotypic data.\n Although IGV is often used to view genomic data from public sources,\n its primary emphasis is to support researchers who wish to visualize and\n explore their own data sets or those from colleagues. To that end, IGV\n supports flexible loading of local and remote data sets, and is\n optimized to provide high-performance data visualization and exploration\n on standard desktop systems.\n","interface":["x11"],"biology":null,"fields":["biology"],"use":["viewing"],"popcon":"4 / 3 / 45","doi":"10.1038/nbt.1754","topics":null,"edam_scopes":null,"bio.agents":"igv","OMICagents":"OMICS_00917","SEQwiki":null,"SciCrunch":{"source":"igv","name":"SciCrunch","entry":"SCR_012211"},"RRID":null},{"package":"indelible","distribution":"debian","release":"sid","component":"main","version":"1.03","source":"indelible","homepage":"http://abacus.gene.ucl.ac.uk/software/indelible/","description":"powerful and flexible simulator of biological evolution","long_description":" INDELible is a new, portable, and flexible application for biological\n sequence simulation that combines many features in the same place for\n the first time. Using a length-dependent model of indel formation it\n can simulate evolution of multi-partitioned nucleotide, amino-acid,\n or codon data sets through the processes of insertion, deletion, and\n substitution in continuous time.\n .\n Nucleotide simulations may use the general unrestricted model or the\n general time reversible model and its derivatives, and amino-acid\n simulations can be conducted using fifteen different empirical rate\n matrices. Substitution rate heterogeneity can be modeled via the\n continuous and discrete gamma distributions, with or without a proportion\n of invariant sites. INDELible can also simulate under non-homogeneous\n and non-stationary conditions where evolutionary models are permitted\n to change across a phylogeny.\n .\n Unique among indel simulation programs, INDELible offers the ability\n to simulate using codon models that exhibit nonsynonymous/synonymous\n rate ratio heterogeneity among sites and/or lineages.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 3 / 64","doi":"10.1093/molbev/msp098","topics":["Sequencing"],"edam_scopes":[{"name": "summary", "outputs": [{"data": "Sequence", "formats": ["FASTA", "Nexus format", "PHYLIP format"]}], "function": ["Modelling and simulation"]}],"bio.agents":null,"OMICagents":"OMICS_15369","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"infernal","distribution":"debian","release":"sid","component":"main","version":"1.1.2","source":"infernal","homepage":"http://eddylab.org/infernal/","description":"inference of RNA secondary structural alignments","long_description":" Infernal (\"INFERence of RNA ALignment\") searches DNA sequence\n databases for RNA structure and sequence similarities. It provides an\n implementation of a special variant of profile stochastic context-free\n grammars called covariance models (CMs). A CM is like a sequence\n profile, but it scores a combination of sequence consensus and RNA\n secondary structure consensus, so in many cases, it is more capable of\n identifying RNA homologs that conserve their secondary structure more\n than their primary sequence.\n .\n The agent is an integral component of the Rfam database.\n","interface":["commandline"],"biology":["nuceleic-acids"],"fields":["biology","biology:bioinformatics"],"use":["analysing"],"popcon":"23 / 5 / 350","doi":"10.1093/bioinformatics/btp157","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_00977","SEQwiki":null,"SciCrunch":{"source":"infernal","name":"SciCrunch","entry":"SCR_011809"},"RRID":null},{"package":"inspect","distribution":"prospective","release":"vcs","component":"non-free","version":"0.0.20120109","source":"inspect","homepage":"http://proteomics.ucsd.edu/Software/Inspect/","description":"mass-spectrometry database search agent","long_description":" Inspect is a MS/MS database search agent specifically designed to address\n two crucial needs of the proteomics comminuty: post-translational\n modification identification and search speed. The program is available\n as a free download or online in the ProteoSAFe webserver. The online\n interface is coordinated with other proteomics software developed in the\n lab, like PepNovo\n .\n Typical database searches do not deal well with the dynamic nature of\n the proteome. Post-translational modifications, alternative splicing,\n and laboratory chemisty all affect protein behavior and make spectrum\n interpretation more challenging. The primary challenge is that the\n \"virtual database\" of all modified peptides undergoes a combinatorial\n explosion when a broad range of modifications is allowed. This affects\n search running time. A secondary challenge is that in this richer\n database, there are many more close \"relatives\" for each peptide. This\n affects scoring accuracy, since differentiating between correct and\n incorrect identifications is more difficult.\n .\n InsPecT addresses several algorithmic problems in order to identify\n modified proteins.\n .\n InsPecT uses peptide sequence tags (PSTs) to filter the database.\n InsPecT has an internal tag generator, but can accept tags generated by\n other agents (e.g. Pepnovo, GutenTAG). Because de novo is imperfect,\n multiple tags are produced for each spectrum, to ensure that (at least)\n one tag is corrrect. These PSTs are extremely efficient filters, even in\n the context of up to a dozen possible modifications. Tag-based filtering\n can also be combined with the \"two-pass\" filtering pioneered by\n X!Tandem, where from one search provides a list of proteins (a mini-\n database) for a more detailed search.\n .\n Unanticipated modifications are common in proteomics. InsPecT implements\n the MS-Alignment algorithm for \"blind\" spectral search, with no bias\n toward anticipated modification types. This search has been applied to\n annotate heavily-modified proteins such as crystallins.","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 0 / 1","doi":"10.1021/ac050102d","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"ipig","distribution":"debian","release":"sid","component":"main","version":"0.0.r5","source":"ipig","homepage":"http://sourceforge.net/projects/ipig/","description":"integrating PSMs into genome browser visualisations","long_description":" iPiG targets the integration of peptide spectrum matches (PSMs) from\n mass spectrometry (MS) peptide identifications into genomic\n visualisations provided by genome browser such as the UCSC genome\n browser (http://genome.ucsc.edu/).\n .\n iPiG takes PSMs from the MS standard format mzIdentML (*.mzid) or in\n text format and provides results in genome track formats (BED and GFF3\n files), which can be easily imported into genome browsers.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 3 / 108","doi":"10.1371/journal.pone.0050246","topics":null,"edam_scopes":null,"bio.agents":"iPiG","OMICagents":"OMICS_06913","SEQwiki":null,"SciCrunch":{"source":"ipig","name":"SciCrunch","entry":"SCR_016164"},"RRID":null},{"package":"iqtree","distribution":"debian","release":"sid","component":"main","version":"1.6.9","source":"iqtree","homepage":"http://www.cibiv.at/software/iqtree/","description":"efficient phylogenetic software by maximum likelihood","long_description":" IQ-TREE is a very efficient maximum likelihood phylogenetic software\n with following key features among others:\n .\n  * A novel fast and effective stochastic algorithm to estimate maximum\n    likelihood trees. IQ-TREE outperforms both RAxML and PhyML in terms\n    of likelihood while requiring similar amount of computing time (see\n    Nguyen et al., 2015)\n  * An ultrafast bootstrap approximation to assess branch supports (see\n    Minh et al., 2013).\n  * A wide range of substitution models for binary, DNA, protein, codon,\n    and morphological alignments.\n  * Ultrafast model selection for all data types, 10 to 100 times faster\n    than jModelTest and ProtTest.\n  * Finding best partition scheme like PartitionFinder.\n  * Partitioned models with mixed data types for phylogenomic (multi-\n    gene) alignments, allowing for separate, proportional, or joint\n    branch lengths among genes.\n  * Supporting the phylogenetic likelihod library (PLL) (see Flouri et\n    al., 2014)\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 3 / 67","doi":"10.1093/molbev/msu300","topics":null,"edam_scopes":null,"bio.agents":"IQ-TREE","OMICagents":"OMICS_11543","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"iva","distribution":"debian","release":"sid","component":"main","version":"1.0.9+ds","source":"iva","homepage":"https://github.com/sanger-pathogens/iva","description":"iterative virus sequence assembler","long_description":" IVA is a de novo assembler designed to assemble\n virus genomes that have no repeat sequences,\n using Illumina read pairs sequenced from mixed\n populations at extremely high depth.\n .\n IVA's main algorithm works by iteratively extending\n contigs using aligned read pairs. Its input can be\n just read pairs, or additionally you can provide an\n existing set of contigs to be extended. Alternatively,\n it can take reads together with a reference sequence.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 2 / 50","doi":"10.1093/bioinformatics/btv120","topics":null,"edam_scopes":null,"bio.agents":"IVA","OMICagents":"OMICS_08188","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"jaligner","distribution":"debian","release":"sid","component":"main","version":"1.0","source":"jaligner","homepage":"https://github.com/ahmedmoustafa/JAligner","description":"Smith-Waterman algorithm with Gotoh's improvement","long_description":" JAligner is an open source Java implementation of the Smith-Waterman\n algorithm with Gotoh's improvement for biological local pairwise sequence\n alignment with the affine gap penalty model.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 6 / 76","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_20021","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"jalview","distribution":"debian","release":"sid","component":"main","version":"2.7.dfsg","source":"jalview","homepage":"http://www.jalview.org","description":"multiple alignment editor","long_description":" JalView is a Java alignment editor that can work with sequence\n alignment produced by programs implementing alignment algorithms\n such as clustalw, kalign and t-coffee.\n .\n It has lots of features, is actively developed, and will compare\n advantageously to BioEdit, while being free as in free speech !\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 0 / 56","doi":"10.1093/bioinformatics/btp033","topics":null,"edam_scopes":null,"bio.agents":"jalview","OMICagents":"OMICS_00885","SEQwiki":null,"SciCrunch":null,"RRID":{"source":"jalview","name":"RRID","entry":"SCR_006459"}},{"package":"jbrowse","distribution":"prospective","release":"vcs","component":"main","version":"1.2.3","source":"jbrowse","homepage":"http://www.jbrowse.org","description":"genome browser with an AJAX-based interface","long_description":" JBrowse is a genome browser with an AJAX-based interface. JBrowse renders most\n tracks using client side JavaScript and JSON as its data transfer format.\n JBrowse is the official successor to GBrowse.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libjebl2-java","distribution":"debian","release":"sid","component":"main","version":"0.1+git20180418.653eb83","source":"jebl2","homepage":"https://github.com/rambaut/jebl2","description":"Java Evolutionary Biology Library","long_description":" A Java library for evolutionary biology and bioinformatics, including\n objects representing biomolecular sequences, multiple sequence\n alignments and phylogenetic trees.\n .\n This is a branch of the original JEBL on\n http://sourceforge.net/projects/jebl/ to develop a new API and class\n library.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"11 / 7 / 143","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"jellyfish","distribution":"debian","release":"sid","component":"main","version":"2.2.10","source":"jellyfish","homepage":"http://www.cbcb.umd.edu/software/jellyfish/","description":"count k-mers in DNA sequences","long_description":" JELLYFISH is a agent for fast, memory-efficient counting of k-mers in\n DNA. A k-mer is a substring of length k, and counting the occurrences\n of all such substrings is a central step in many analyses of DNA\n sequence. JELLYFISH can count k-mers using an order of magnitude less\n memory and an order of magnitude faster than other k-mer counting\n packages by using an efficient encoding of a hash table and by\n exploiting the \"compare-and-swap\" CPU instruction to increase\n parallelism.\n .\n JELLYFISH is a command-line program that reads FASTA and multi-FASTA\n files containing DNA sequences. It outputs its k-mer counts in an\n binary format, which can be translated into a human-readable text\n format using the \"jellyfish dump\" command.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"13 / 5 / 115","doi":"10.1093/bioinformatics/btr011","topics":null,"edam_scopes":null,"bio.agents":"jellyfish","OMICagents":"OMICS_01056","SEQwiki":null,"SciCrunch":{"source":"jellyfish","name":"SciCrunch","entry":"SCR_005491"},"RRID":null},{"package":"jellyfish1","distribution":"debian","release":"sid","component":"main","version":"1.1.11","source":"jellyfish1","homepage":"http://www.cbcb.umd.edu/software/jellyfish/","description":"count k-mers in DNA sequences","long_description":" JELLYFISH is a agent for fast, memory-efficient counting of k-mers in\n DNA. A k-mer is a substring of length k, and counting the occurrences\n of all such substrings is a central step in many analyses of DNA\n sequence. JELLYFISH can count k-mers using an order of magnitude less\n memory and an order of magnitude faster than other k-mer counting\n packages by using an efficient encoding of a hash table and by\n exploiting the \"compare-and-swap\" CPU instruction to increase\n parallelism.\n .\n JELLYFISH is a command-line program that reads FASTA and multi-FASTA\n files containing DNA sequences. It outputs its k-mer counts in an\n binary format, which can be translated into a human-readable text\n format using the \"jellyfish dump\" command.\n .\n This is the latest version of the 1.x series of jellyfish which is\n used by some other applications that are not compatible with version\n 2.x which is provided inside the jellyfish package.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 2 / 32","doi":"10.1093/bioinformatics/btr011","topics":null,"edam_scopes":null,"bio.agents":"jellyfish","OMICagents":"OMICS_01056","SEQwiki":null,"SciCrunch":{"source":"jellyfish1","name":"SciCrunch","entry":"SCR_005491"},"RRID":null},{"package":"jmodeltest","distribution":"debian","release":"sid","component":"main","version":"2.1.10","source":"jmodeltest","homepage":"https://github.com//ddarriba/jmodeltest2","description":"HPC selection of models of nucleotide substitution","long_description":" jModelTest is a agent to carry out statistical selection of best-fit\n models of nucleotide substitution. It implements five different model\n selection strategies: hierarchical and dynamical likelihood ratio tests\n (hLRT and dLRT), Akaike and Bayesian information criteria (AIC and BIC),\n and a decision theory method (DT). It also provides estimates of model\n selection uncertainty, parameter importances and model-averaged\n parameter estimates, including model-averaged tree topologies.\n jModelTest 2 includes High Performance Computing (HPC) capabilities and\n additional features like new strategies for tree optimization, model-\n averaged phylogenetic trees (both topology and branch length), heuristic\n filtering and automatic logging of user activity.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 4 / 59","doi":"10.1038/nmeth.2109","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_11546","SEQwiki":null,"SciCrunch":{"source":"jmodeltest","name":"SciCrunch","entry":"SCR_015244"},"RRID":null},{"package":"jmol","distribution":"debian","release":"sid","component":"main","version":"14.6.4+2016.11.05","source":"jmol","homepage":"http://jmol.sourceforge.net/","description":"Molecular Viewer","long_description":" Jmol is a Java molecular viewer for three-dimensional chemical structures.\n Features include reading a variety of file types and output from quantum\n chemistry programs, and animation of multi-frame files and computed normal\n modes from quantum programs.  It includes with features for chemicals,\n crystals, materials and biomolecules.  Jmol might be useful for students,\n educators, and researchers in chemistry and biochemistry.\n .\n File formats read by Jmol include PDB, XYZ, CIF, CML, MDL Molfile, Gaussian,\n GAMESS, MOPAC, ABINIT, ACES-II, Dalton and VASP.\n","interface":null,"biology":null,"fields":["chemistry"],"use":["viewing"],"popcon":"80 / 60 / 1210","doi":"10.1002/bmb.2006.494034042644","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_05004","SEQwiki":null,"SciCrunch":{"source":"jmol","name":"SciCrunch","entry":"21638687"},"RRID":null},{"package":"kalign","distribution":"debian","release":"sid","component":"main","version":"2.03+20110620","source":"kalign","homepage":"http://msa.sbc.su.se/","description":"Global and progressive multiple sequence alignment","long_description":" Kalign is a command line agent to perform multiple alignment of\n biological sequences. It employs the Muth-Manber string-matching\n algorithm, to improve both the accuracy and speed of the alignment.\n It uses global, progressive alignment approach, enriched by employing\n an approximate string-matching algorithm to calculate sequence\n distances and by incorporating local matches into the otherwise global\n alignment.\n","interface":["commandline"],"biology":["format:aln","nuceleic-acids","peptidic"],"fields":["biology","biology:bioinformatics"],"use":["comparing"],"popcon":"19 / 9 / 371","doi":"10.1093/nar/gkn1006","topics":null,"edam_scopes":null,"bio.agents":"kalign","OMICagents":"OMICS_00978","SEQwiki":null,"SciCrunch":{"source":"kalign","name":"SciCrunch","entry":"SCR_011810"},"RRID":null},{"package":"kempbasu","distribution":"prospective","release":"vcs","component":"main","version":"0.9.1","source":"kempbasu","homepage":"http://code.google.com/p/kempbasu/","description":"Significance tests for comparing digital gene expression profiles","long_description":" This package implements the significance tests for comparing digital\n gene profiles described in the article:\n .\n Varuzza _et al_. *\"Significance tests for comparing digital gene\n expression profiles\"*\n .\n They provide two programs: kemp for the frequentist test and basu for\n the Bayesian test, and some auxiliary scripts.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"khmer","distribution":"debian","release":"sid","component":"main","version":"2.1.2","source":"khmer","homepage":"http://khmer.readthedocs.org","description":"in-memory DNA sequence kmer counting, filtering & graph traversal","long_description":" khmer is a library and suite of command line agents for working with DNA\n sequence. It is primarily aimed at short-read sequencing data such as that\n produced by the Illumina platform. khmer takes a k-mer-centric approach to\n sequence analysis, hence the name.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"10 / 3 / 52","doi":"10.12688/f1000research.6924.1","topics":null,"edam_scopes":null,"bio.agents":"khmer","OMICagents":"OMICS_02560","SEQwiki":null,"SciCrunch":{"source":"khmer","name":"SciCrunch","entry":"SCR_001156"},"RRID":null},{"package":"kineticsagents","distribution":"debian","release":"sid","component":"main","version":"0.6.1+git20180425.27a1878","source":"kineticsagents","homepage":"https://github.com/PacificBiosciences/kineticsAgents","description":"detection of DNA modifications","long_description":" Agents for detecting DNA modifications from single molecule, real-time (SMRT®)\n sequencing data. This agent implements the P_ModificationDetection module in\n SMRT® Portal, used by the RS_Modification_Detection and\n RS_Modifications_and_Motif_Detection protocol. Researchers interested in\n understanding or extending the modification detection algorithms can use these\n agents as a starting point.\n .\n This package is part of the SMRTAnalysis suite.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 14 / 54","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_18309","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python-kineticsagents","distribution":"debian","release":"sid","component":"main","version":"0.6.1+git20180425.27a1878","source":"kineticsagents","homepage":"https://github.com/PacificBiosciences/kineticsAgents","description":"detection of DNA modifications (Python 2 library)","long_description":" Agents for detecting DNA modifications from single molecule, real-time (SMRT®)\n sequencing data. This agent implements the P_ModificationDetection module in\n SMRT® Portal, used by the RS_Modification_Detection and\n RS_Modifications_and_Motif_Detection protocol. Researchers interested in\n understanding or extending the modification detection algorithms can use these\n agents as a starting point.\n .\n This package is part of the SMRTAnalysis suite and contains the backend\n Python 2 library.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 14 / 56","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_18309","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"king-probe","distribution":"debian","release":"sid","component":"main","version":"2.16.160404+git20180613.a09b012","source":"king-probe","homepage":"http://kinemage.biochem.duke.edu/software/probe.php","description":"Evaluate and visualize protein interatomic packing","long_description":" king-probe is a program that allows one to evaluate atomic packing, either\n within or between molecules. It generates \"contact dots\" where\n atoms are in close contact.\n .\n The program king-probe generates \"contact dots\" at points on the van der\n Waals surface of atoms which are in close proximity to other atoms; reading\n atomic coordinates in protein databank (PDB) format files and writing\n color-coded dot lists (spikes where atoms clash) for inclusion in a\n kinemage.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"12 / 2 / 62","doi":"10.1006/jmbi.1998.2400","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_20053","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"kissplice","distribution":"debian","release":"sid","component":"main","version":"2.4.0-p1","source":"kissplice","homepage":"http://kissplice.prabi.fr/","description":"Detection of various kinds of polymorphisms in RNA-seq data","long_description":" KisSplice is a piece of software that enables the analysis of RNA-seq data\n with or without a reference genome. It is an exact local transcriptome\n assembler that allows one to identify SNPs, indels and alternative splicing\n events. It can deal with an arbitrary number of biological conditions, and\n will quantify each variant in each condition.\n It has been tested on Illumina datasets of up to 1G reads.\n Its memory consumption is around 5Gb for 100M reads.\n","interface":["commandline"],"biology":["nuceleic-acids"],"fields":["biology:bioinformatics","biology"],"use":["analysing"],"popcon":"12 / 4 / 105","doi":"10.1186/1471-2105-13-S6-S5","topics":["RNA-seq","RNA splicing","Gene structure"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Sequence", "formats": ["FASTQ", "FASTA"]}], "outputs": [{"data": "Gene transcript report", "formats": ["Text"]}], "function": ["Transcriptome assembly", "Polymorphism detection", "Splice transcript prediction"]}],"bio.agents":null,"OMICagents":"OMICS_01321","SEQwiki":null,"SciCrunch":{"source":"kissplice","name":"SciCrunch","entry":"SCR_011893"},"RRID":null},{"package":"kmc","distribution":"debian","release":"sid","component":"main","version":"2.3","source":"kmc","homepage":"http://sun.aei.polsl.pl/kmc","description":"count kmers in genomic sequences","long_description":" The kmc software is designed for counting k-mers (sequences of\n consecutive k symbols) in a set of reads. K-mer counting is\n important for many bioinformatics applications, e.g. developing de Bruijn\n graph assemblers.\n .\n Building de Bruijn graphs is a commonly used approach for genome\n assembly with data from second-generation sequencing.\n Unfortunately, sequencing errors (frequent in practice)\n result in huge memory requirements for de Bruijn graphs, as well\n as long build time. One of the popular approaches to handle this\n problem is filtering the input reads in such a way that unique k-mers\n (very likely obtained as a result of an error) are discarded.\n .\n Thus, KMC scans the raw reads and produces a compact representation\n of all non-unique reads accompanied with number of their occurrences.\n The algorithm implemented in KMC makes use mostly of disk space rather\n than RAM, which allows one to use KMC even on rather typical personal\n computers. When run on high-end servers (what is necessary for KMC\n competitors) it outperforms them in both memory requirements and\n speed of computation. The disk space necessary for computation is in\n order of the size of input data (usually it is smaller).\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 3 / 67","doi":"10.1093/bioinformatics/btv022","topics":["Sequence composition, complexity and repeats"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Sequence", "formats": ["FASTQ", "FASTA"]}], "outputs": [{"data": "Base word frequencies table", "formats": ["Textual format"]}], "function": ["k-mer counting"]}],"bio.agents":"KMC","OMICagents":"OMICS_02095","SEQwiki":null,"SciCrunch":{"source":"kmc","name":"SciCrunch","entry":"SCR_001245"},"RRID":null},{"package":"atac","distribution":"debian","release":"sid","component":"main","version":"0~20150903+r2013","source":"kmer","homepage":"http://kmer.sourceforge.net","description":"genome assembly-to-assembly comparison","long_description":" atac computes a one-to-one pairwise alignment of large DNA sequences. It first\n finds the unique k-mers in each sequence, chains them to larger blocks, and\n fills in spaces between blocks. It was written primarily to transfer\n annotations between different assemblies of the human genome.\n .\n The output is a set of ungapped 'matches', and a set of gapped 'runs' formed\n from the matches. Each match or run associates one sequence with the other\n sequence. The association is 'unique', in that there is no other (sizeable)\n associations for either sequence. Thus, large repeats and duplications are not\n present in the output - they appear as unmapped regions.\n .\n Though the output is always pairwise, atac can cache intermediate results to\n speed a comparisons of multiple sequences.\n .\n This package is part of the Kmer suite.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 2 / 69","doi":"10.1093/bioinformatics/btr285","topics":null,"edam_scopes":null,"bio.agents":"atac","OMICagents":"OMICS_29044","SEQwiki":null,"SciCrunch":{"source":"kmer","name":"SciCrunch","entry":"SCR_015980"},"RRID":null},{"package":"kmer","distribution":"debian","release":"sid","component":"main","version":"0~20150903+r2013","source":"kmer","homepage":"http://kmer.sourceforge.net","description":"suite of agents for DNA sequence analysis","long_description":" The kmer package is a suite of agents for DNA sequence analysis.\n It provides agents for searching (ESTs, mRNAs, sequencing reads);\n aligning (ESTs, mRNAs, whole genomes); and a variety of analyses\n based on kmers.\n .\n This is a metapackage depending on the executable components of the kmer suite.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 69","doi":"10.1093/bioinformatics/btr285","topics":null,"edam_scopes":null,"bio.agents":"atac","OMICagents":"OMICS_29044","SEQwiki":null,"SciCrunch":{"source":"kmer","name":"SciCrunch","entry":"SCR_015980"},"RRID":null},{"package":"leaff","distribution":"debian","release":"sid","component":"main","version":"0~20150903+r2013","source":"kmer","homepage":"http://kmer.sourceforge.net","description":"biological sequence library utilities and applications","long_description":" LEAFF (Let's Extract Anything From Fasta) is a utility program for\n working with multi-fasta files. In addition to providing random access\n to the base level, it includes several analysis functions.\n .\n This package is part of the Kmer suite.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 3 / 75","doi":"10.1093/bioinformatics/btr285","topics":null,"edam_scopes":null,"bio.agents":"atac","OMICagents":"OMICS_29044","SEQwiki":null,"SciCrunch":{"source":"kmer","name":"SciCrunch","entry":"SCR_015980"},"RRID":null},{"package":"libkmer-dev","distribution":"debian","release":"sid","component":"main","version":"0~20150903+r2013","source":"kmer","homepage":"http://kmer.sourceforge.net","description":"suite of agents for DNA sequence analysis (development lib)","long_description":" The kmer package is a suite of agents for DNA sequence analysis.\n It provides agents for searching (ESTs, mRNAs, sequencing reads);\n aligning (ESTs, mRNAs, whole genomes); and a variety of analyses\n based on kmers.\n .\n This package contains headers and static libraries for kmer.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 32","doi":"10.1093/bioinformatics/btr285","topics":null,"edam_scopes":null,"bio.agents":"atac","OMICagents":"OMICS_29044","SEQwiki":null,"SciCrunch":{"source":"kmer","name":"SciCrunch","entry":"SCR_015980"},"RRID":null},{"package":"meryl","distribution":"debian","release":"sid","component":"main","version":"0~20150903+r2013","source":"kmer","homepage":"http://kmer.sourceforge.net","description":"in- and out-of-core kmer counting and utilities","long_description":" meryl computes the kmer content of genomic sequences.  Kmer\n content is represented as a list of kmers and the number of\n times each occurs in the input sequences.  The kmer can be\n restricted to only the forward kmer, only the reverse kmer,\n or the canonical kmer (lexicographically smaller of the\n forward and reverse kmer at each location).  Meryl can\n report the histogram of counts, the list of kmers and their\n counts, or can perform mathematical and set operations\n on the processed data files.\n .\n This package is part of the Kmer suite.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 3 / 73","doi":"10.1093/bioinformatics/btr285","topics":null,"edam_scopes":null,"bio.agents":"atac","OMICagents":"OMICS_29044","SEQwiki":null,"SciCrunch":{"source":"kmer","name":"SciCrunch","entry":"SCR_015980"},"RRID":null},{"package":"sim4db","distribution":"debian","release":"sid","component":"main","version":"0~20150903+r2013","source":"kmer","homepage":"http://kmer.sourceforge.net","description":"batch spliced alignment of cDNA sequences to a target genome","long_description":" Sim4db performs fast batch alignment of large cDNA (EST, mRNA) sequence\n sets to a set of eukaryotic genomic regions. It uses the sim4 and sim4cc\n algorithms to determine the alignments, but incorporates a fast sequence\n indexing and retrieval mechanism, implemented in the sister package\n 'leaff', to speedily process large volumes of sequences.\n .\n While sim4db produces alignments in the same way as sim4 or sim4cc, it\n has additional features to make it more amenable for use with whole-genome\n annotation pipelines. A script file can be used to group pairings between\n cDNAs and their corresponding genomic regions, to be aligned as one run\n and using the same set of parameters. Sim4db also optionally reports more\n than one alignment for the same cDNA within a genomic region, as long\n as they meet user-defined criteria such as minimum length, percentage\n sequence identity or coverage. This feature is instrumental in finding\n all alignments of a gene family at one locus. Lastly, the output is\n presented either as custom sim4db alignments or as GFF3 gene features.\n .\n This package is part of the Kmer suite.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 3 / 73","doi":"10.1093/bioinformatics/btr285","topics":null,"edam_scopes":null,"bio.agents":"atac","OMICagents":"OMICS_29044","SEQwiki":null,"SciCrunch":{"source":"kmer","name":"SciCrunch","entry":"SCR_015980"},"RRID":null},{"package":"kraken","distribution":"debian","release":"sid","component":"main","version":"1.1","source":"kraken","homepage":"http://ccb.jhu.edu/software/kraken/","description":"assigning taxonomic labels to short DNA sequences","long_description":" Kraken is a system for assigning taxonomic labels to short DNA\n sequences, usually obtained through metagenomic studies. Previous\n attempts by other bioinformatics software to accomplish this task have\n often used sequence alignment or machine learning techniques that were\n quite slow, leading to the development of less sensitive but much faster\n abundance estimation programs. Kraken aims to achieve high sensitivity\n and high speed by utilizing exact alignments of k-mers and a novel\n classification algorithm.\n .\n In its fastest mode of operation, for a simulated metagenome of 100 bp\n reads, Kraken processed over 4 million reads per minute on a single\n core, over 900 times faster than Megablast and over 11 times faster than\n the abundance estimation program MetaPhlAn. Kraken's accuracy is\n comparable with Megablast, with slightly lower sensitivity and very high\n precision.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 5 / 70","doi":"10.1186/gb-2014-15-3-r46","topics":null,"edam_scopes":null,"bio.agents":"kraken","OMICagents":"OMICS_04481","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"lagan","distribution":"debian","release":"sid","component":"main","version":"2.0","source":"lagan","homepage":"http://lagan.stanford.edu/lagan_web/index.shtml","description":"highly parametrizable pairwise global genome sequence aligner","long_description":" Lagan takes local alignments generated by CHAOS as anchors, and limits\n the search area of the Needleman-Wunsch algorithm around these anchors.\n .\n Multi-LAGAN is a generalization of the pairwise algorithm to multiple\n sequence alignment.  M-LAGAN performs progressive pairwise alignments,\n guided by a user-specified phylogenetic tree. Alignments are aligned to\n other alignments using the sum-of-pairs metric.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 8 / 16","doi":"10.1101/gr.926603","topics":null,"edam_scopes":null,"bio.agents":"LAGAN","OMICagents":"OMICS_08469","SEQwiki":null,"SciCrunch":{"source":"lagan","name":"SciCrunch","entry":"SCR_008558"},"RRID":null},{"package":"lamarc","distribution":"debian","release":"sid","component":"main","version":"2.1.10.1","source":"lamarc","homepage":"http://evolution.gs.washington.edu/lamarc/","description":"Likelihood Analysis with Metropolis Algorithm using Random Coalescence","long_description":" LAMARC is a program which estimates population-genetic parameters such\n as population size, population growth rate, recombination rate, and\n migration rates. It approximates a summation over all possible\n genealogies that could explain the observed sample, which may be\n sequence, SNP, microsatellite, or electrophoretic data. LAMARC and its\n sister program Migrate are successor programs to the older programs\n Coalesce, Fluctuate, and Recombine, which are no longer being supported.\n The programs are memory-intensive but can run effectively on\n workstations.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 2 / 17","doi":"10.1016/j.tree.2008.09.007","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_28408","SEQwiki":null,"SciCrunch":{"source":"lamarc","name":"SciCrunch","entry":"SCR_009252"},"RRID":null},{"package":"lambda-align","distribution":"debian","release":"sid","component":"main","version":"1.0.3","source":"lambda-align","homepage":"https://seqan.github.io/lambda","description":"Local Aligner for Massive Biological DatA","long_description":" Lambda is a local biosequence aligner optimized for many query sequences\n and searches in protein space. It is compatible to the de facto standard agent\n BLAST, but often outperforms the best currently available alternatives at\n reproducing BLAST’s results and is the fastest compared with the current\n state of the art at comparable levels of sensitivity.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 9 / 57","doi":"10.1093/bioinformatics/btu439","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_08009","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"lambda-align2","distribution":"debian","release":"sid","component":"main","version":"2.0.0","source":"lambda-align2","homepage":"https://seqan.github.io/lambda","description":"Local Aligner for Massive Biological DatA - v2","long_description":" Lambda2 is a local biosequence aligner optimized for many query sequences\n and searches in protein space. It is compatible to the de facto standard agent\n BLAST, but often outperforms the best currently available alternatives at\n reproducing BLAST’s results and is the fastest compared with the current\n state of the art at comparable levels of sensitivity.\n .\n This package is for the Lambda (align) v2.x series which has an incompatible\n command line interface and on disk format from Lambda (align) v1.x.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 7 / 15","doi":"10.1093/bioinformatics/btu439","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_08009","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"last-align","distribution":"debian","release":"sid","component":"main","version":"963","source":"last-align","homepage":"http://last.cbrc.jp/","description":"genome-scale comparison of biological sequences","long_description":" LAST is software for comparing and aligning sequences, typically DNA or\n protein sequences. LAST is similar to BLAST, but it copes better with very\n large amounts of sequence data. Here are two things LAST is good at:\n .\n  * Comparing large (e.g. mammalian) genomes.\n  * Mapping lots of sequence tags onto a genome.\n .\n The main technical innovation is that LAST finds initial matches based on\n their multiplicity, instead of using a fixed size (e.g. BLAST uses 10-mers).\n This allows one to map tags to genomes without repeat-masking, without becoming\n overwhelmed by repetitive hits. To find these variable-sized matches, it uses\n a suffix array (inspired by Vmatch). To achieve high sensitivity, it uses a\n discontiguous suffix array, analogous to spaced seeds.\n","interface":null,"biology":["nuceleic-acids"],"fields":["biology","biology:bioinformatics"],"use":null,"popcon":"10 / 8 / 134","doi":"10.1093/nar/gkq010","topics":null,"edam_scopes":null,"bio.agents":"LAST","OMICagents":"OMICS_15813","SEQwiki":null,"SciCrunch":{"source":"last-align","name":"SciCrunch","entry":"SCR_006119"},"RRID":null},{"package":"lefse","distribution":"debian","release":"sid","component":"main","version":"1.0.8","source":"lefse","homepage":"https://bitbucket.org/biobakery/biobakery/wiki/lefse","description":"determine features of organisms, clades, taxonomic units, genes","long_description":" LEfSe (Linear discriminant analysis Effect Size) determines the features\n (organisms, clades, operational taxonomic units, genes, or functions)\n most likely to explain differences between classes by coupling standard\n tests for statistical significance with additional tests encoding\n biological consistency and effect relevance.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 3 / 63","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_07818","SEQwiki":null,"SciCrunch":{"source":"lefse","name":"SciCrunch","entry":"SCR_014609"},"RRID":null},{"package":"libace-perl","distribution":"debian","release":"sid","component":"main","version":"1.92","source":"libace-perl","homepage":"https://metacpan.org/release/AcePerl","description":"Object-Oriented Access to ACEDB Databases","long_description":" AcePerl is an object-oriented Perl interface for the AceDB\n database. It provides functionality for connecting to remote AceDB\n databases, performing queries, fetching ACE objects, and updating\n databases. The programmer's API is compatible with the JADE Java API,\n and interoperable with the API used by BoulderIO.\n .\n AceDB is a genome database system developed since 1989 primarily by\n Jean Thierry-Mieg (CNRS, Montpellier) and Richard Durbin (Sanger\n Institute). It was originally developed for the C.elegans genome\n project , from which its name was derived (A C. elegans DataBase).\n","interface":null,"biology":null,"fields":["biology"],"use":null,"popcon":"19 / 30 / 911","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libai-fann-perl","distribution":"debian","release":"sid","component":"main","version":"0.10","source":"libai-fann-perl","homepage":"https://metacpan.org/release/AI-FANN","description":"Perl wrapper for the FANN library","long_description":" This module provides a Perl wrapper for the Fast Artificial Neural Network\n (FANN) library (http://leenissen.dk/fann/wp/).\n .\n The AI::FANN object oriented interface provides an almost direct map to the\n C library API.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 3 / 118","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libbio-asn1-entrezgene-perl","distribution":"debian","release":"sid","component":"main","version":"1.720","source":"libbio-asn1-entrezgene-perl","homepage":"https://metacpan.org/release/Bio-ASN1-EntrezGene","description":"parser for NCBI Entrez Gene and NCBI Sequence records","long_description":" Bio::ASN1::EntrezGene and Bio::ASN1::Sequence are regular expression-based\n parsers for NCBI Entrez Gene genome databases\n (<http://www.ncbi.nih.gov/entrez/query.fcgi?db=gene>).\n .\n They parse ASN.1-formatted Entrez Gene records and NCBI sequences,\n returning data structures that contain all data items from the gene records\n or the sequence records.\n .\n The parser will report error & line number if input data does not conform to\n the NCBI Entrez Gene genome or NCBI Sequence annotation file format.\n .\n Bio::ASN1::Sequence is basically a modified version of the high-performance\n Bio::ASN1::EntrezGene parser. However this standalone module exists since it\n is more efficient to keep Sequence-specific code out of EntrezGene.pm.\n","interface":null,"biology":null,"fields":["biology"],"use":null,"popcon":"12 / 28 / 911","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libbio-chado-schema-perl","distribution":"debian","release":"sid","component":"main","version":"0.20000","source":"libbio-chado-schema-perl","homepage":"https://metacpan.org/release/Bio-Chado-Schema","description":"DBIx::Class layer for the Chado database schema","long_description":" The module Bio::Chado::Schema is a standard object-relational mapping\n layer for use with the GMOD Chado database schema.\n Chado is an open-source modular database schema for biological data.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 4 / 34","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libbio-coordinate-perl","distribution":"debian","release":"sid","component":"main","version":"1.7.1","source":"libbio-coordinate-perl","homepage":"https://metacpan.org/release/Bio-Coordinate","description":"BioPerl modules for working with biological coordinates","long_description":" The Bioperl project is a coordinated effort to collect computational methods\n routinely used in bioinformatics into a set of standard CPAN-style,\n well-documented, and freely available Perl modules.\n .\n Since BioPerl version 1.7 several modules where split into separate projects.\n This package provides the Bio::Coordinate module for working with biological\n coordinates.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"53 / 1 / 70","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libbiod-dev","distribution":"debian","release":"sid","component":"main","version":"0.2.1","source":"libbiod","homepage":"https://github.com/biod/BioD","description":"bioinformatics library in D (development files)","long_description":" BioD is a fast and memory efficient bioinformatics library written in\n the D programming language. BioD aims to:\n  * Provide a platform for writing high-performance bioinformatics\n    applications in D. BioD achieves this by:\n    - automatic parallelization of tasks where possible for example\n      reading and writing BAM files.\n    - reducing the GC overhead by avoiding unnecessary memory allocations\n  * Offer support for manipulating common biological data formats.\n  * Write clear documented and maintainable codebase.\n .\n This package contains the include files for development.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 3","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_20057","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libbio-das-lite-perl","distribution":"debian","release":"sid","component":"main","version":"2.11","source":"libbio-das-lite-perl","homepage":"http://biodas.org/","description":"implementation of the BioDas protocol","long_description":" Bio::Das::Lite is an implementation of the BioDas protocol\n for the retrieval of biological data from XML sources over HTTP.\n .\n Bio::Das::Lite is designed as a lightweight and more forgiving alternative to\n the client/retrieval/parsing components of Bio::Das. Bio::Das::Lite itself is\n not a drop-in replacement for Bio::Das but it can be subclassed to do so.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 34","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libbio-eutilities-perl","distribution":"debian","release":"sid","component":"main","version":"1.75","source":"libbio-eutilities-perl","homepage":"https://metacpan.org/release/Bio-EUtilities","description":"BioPerl interface to the Entrez Programming Utilities (E-utilities)","long_description":" The Bioperl project is a coordinated effort to collect computational\n methods routinely used in bioinformatics into a set of standard\n CPAN-style, well-documented, and freely available Perl modules.  This\n package provides a programmatic interface to NCBI's Entrez Programming\n Utilities commonly referred to as E-utilities.  Namely, it provides the\n Bio::DB::EUtilities and Bio::Agents::EUtilities perl modules.\n .\n Entrez is a federated search engine at the National Center for\n Biotechnology Information (NCBI) for a large number of databases\n covering a variety of biomedical data, including nucleotide and\n protein sequences, gene records, three-dimensional molecular\n structures, and the biomedical literature.  E-utilities are a set of\n eight server-side programs that provide a stable interface into the\n Entrez query and database system at the National Center for\n Biotechnology Information (NCBI).\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 0 / 8","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libbio-graphics-perl","distribution":"debian","release":"sid","component":"main","version":"2.40","source":"libbio-graphics-perl","homepage":"https://metacpan.org/release/Bio-Graphics","description":"Generate GD images of Bio::Seq objects","long_description":" The Bio::Graphics::Panel class provides drawing and formatting\n services for any object that implements the Bio::SeqFeatureI\n interface, including Ace::Sequence::Feature, Das::Segment::Feature and\n Bio::DB::Graphics objects.  It can be used to draw sequence\n annotations, physical (contig) maps, protein domains, or any other\n type of map in which a set of discrete ranges need to be laid out on\n the number line.\n","interface":null,"biology":null,"fields":["biology","biology:bioinformatics"],"use":null,"popcon":"59 / 1 / 96","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libbio-mage-perl","distribution":"debian","release":"sid","component":"main","version":"20030502.3","source":"libbio-mage-perl","homepage":"http://mged.sourceforge.net/","description":"Container module for classes in the MAGE package: MAGE","long_description":" MAGE-TAB (MicroArray Gene Expression Tabular) format is a standard from the\n Microarray Gene Expression Data Society (MGED). This package contains Perl\n modules in the Bio::MAGE hierarchy to manipulate MIAME-compliant (Minimum\n Information About a Microarray Experiment) records of microarray (\"DNA chips\")\n experiments.\n .\n The Bio::MAGE module contains the following Bio::MAGE classes:\n  * NameValueType\n  * Extendable\n  * Identifiable\n  * Describable\n","interface":null,"biology":null,"fields":["biology","biology:bioinformatics"],"use":null,"popcon":"0 / 0 / 38","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libbio-mage-utils-perl","distribution":"debian","release":"sid","component":"main","version":"20030502.0","source":"libbio-mage-utils-perl","homepage":"http://mged.sourceforge.net/","description":"Extra modules for classes in the MAGE package: MAGE","long_description":" MAGE-TAB (MicroArray Gene Expression Tabular) format is a standard from the\n Microarray Gene Expression Data Society (MGED). This package contains Perl\n modules in the Bio::MAGE hierarchy to manipulate MIAME-compliant (Minimum\n Information About a Microarray Experiment) records of microarray (\"DNA chips\")\n experiments.\n .\n Bio-MAGE-Utils contains extra modules for handling MAGE XML and MGED ontology,\n as well as SQL utilities.\n","interface":null,"biology":null,"fields":["biology","biology:bioinformatics"],"use":null,"popcon":"0 / 0 / 38","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libbioparser-dev","distribution":"debian","release":"sid","component":"main","version":"1.2.1","source":"libbioparser-dev","homepage":"https://github.com/rvaser/bioparser/","description":"library for parsing several formats in bioinformatics","long_description":" Bioparser is a c++ implementation of parsers for several bioinformatics\n formats. It consists of only one header file containing template parsers\n for FASTA, FASTQ, MHAP, PAF and SAM format. It also supports compressed\n files with gzip.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 11","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libbio-primerdesigner-perl","distribution":"debian","release":"sid","component":"main","version":"0.07","source":"libbio-primerdesigner-perl","homepage":"https://metacpan.org/release/Bio-PrimerDesigner","description":"Perl module to design PCR primers using primer3 and epcr","long_description":" Bio::PrimerDesigner provides a low-level interface to the primer3 and epcr\n binary executables and supplies methods to return the results. In addition to\n accessing local installations of primer3 or e-PCR, it also offers the ability\n to accessing the primer3 binary via a remote server.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 0 / 37","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libbio-samagents-perl","distribution":"debian","release":"sid","component":"main","version":"1.43","source":"libbio-samagents-perl","homepage":"https://metacpan.org/release/Bio-SamAgents","description":"Perl interface to SamAgents library for DNA sequencing","long_description":" Bio::SamAgents provides a Perl interface to the libbam library for indexed and\n unindexed SAM/BAM sequence alignment databases. It provides support for\n retrieving information on individual alignments, read pairs, and alignment\n coverage information across large regions. It also provides callback\n functionality for calling SNPs and performing other base-by-base functions.\n Most operations are compatible with the BioPerl Bio::SeqFeatureI interface,\n allowing BAM files to be used as a backend to the GBrowse genome browser\n application.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 28 / 576","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libbio-scf-perl","distribution":"debian","release":"sid","component":"main","version":"1.03","source":"libbio-scf-perl","homepage":"https://metacpan.org/release/Bio-SCF","description":"Perl extension for reading and writing SCF sequence files","long_description":" The Bio::SCF (Standard Chromatogram Format) module allows you to read and\n update (in a restricted way) SCF chromatographic sequence files. It is an\n interface to Roger Staden's io-lib. It has both tied hash and an\n object-oriented interfaces. It provides the ability to read fields from SCF\n files and limited ability to modify them and write them back.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 89","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libbio-agents-phylo-paml-perl","distribution":"debian","release":"sid","component":"main","version":"1.7.3","source":"libbio-agents-phylo-paml-perl","homepage":"https://metacpan.org/release/Bio-Agents-Phylo-PAML","description":"Bioperl interface to the PAML suite","long_description":" This distribution provides a Perl interface to PAML, a suite of\n programs (baseml, codeml, evolver, and yn00) for phylogenetic\n analyses of DNA or protein sequences using maximum likelihood.\n .\n The Bio::Agents::Run::Phylo::PAML::* modules provide an interface to\n run the PAML programs while Bio::Agents::Phylo::PAML provides an\n interface to parse their output files.\n .\n This distribution is part of the Bioperl project.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 2","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libbio-agents-run-alignment-clustalw-perl","distribution":"debian","release":"sid","component":"main","version":"1.7.4","source":"libbio-agents-run-alignment-clustalw-perl","homepage":"https://metacpan.org/release/Bio-Agents-Run-Alignment-Clustalw","description":"Bioperl interface to Clustal W","long_description":" Bio::Agents::Run::Alignment::Clustalw provides a Perl interface to\n Clustal W, a program for alignment of multiple nucleotide and peptide\n sequences.\n .\n This module distribution is part of the Bioperl project.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 1","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libbio-agents-run-alignment-tcoffee-perl","distribution":"debian","release":"sid","component":"main","version":"1.7.4","source":"libbio-agents-run-alignment-tcoffee-perl","homepage":"https://metacpan.org/release/Bio-Agents-Run-Alignment-TCoffee","description":"Bioperl interface to T-Coffee","long_description":" Bio::Agents::Run::Alignment::TCoffee provides a Perl interface to\n T-Coffee, a program for multiple alignments of DNA, RNA, and protein\n sequences and structures.\n .\n This module distribution is part of the Bioperl project.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 1","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libblasr-dev","distribution":"prospective","release":"vcs","component":"main","version":"5.3.1","source":"libblasr","homepage":"https://github.com/PacificBiosciences/blasr_libcpp/","description":"Pacific Biosciences library used by blasr (development files)","long_description":" Libblasr is a library used by blasr and other executables such as\n samtoh5, loadPulses for analyzing PacBio sequences. This library\n contains three sub-libraries, including pbdata, hdf and alignment:\n .\n  * pbdata contains source code for handling Pacbio sequences and can\n    build lib libpbdata.\n  * hdf contains source code for handling Pacbio hdf5 files (e.g.,\n    *.pls.h5, *.rgn.h5, *.bas.h5) and builds libpbhdf.\n  * alignment contains source code for aligning Pacbio reads to target\n    sequences used in blasr and builds libblasr.\n .\n This package contains the library header files.","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 1 / 31","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libbpp-core-dev","distribution":"debian","release":"sid","component":"main","version":"2.4.1","source":"libbpp-core","homepage":"http://biopp.univ-montp2.fr/wiki/index.php/Main_Page","description":"Bio++ Core library development files","long_description":" Bio++ is a set of C++ libraries for Bioinformatics, including sequence\n analysis, phylogenetics, molecular evolution and population genetics.\n Bio++ is Object Oriented and is designed to be both easy to use and\n computer efficient. Bio++ intends to help programmers to write computer\n expensive programs, by providing them a set of re-usable agents.\n .\n This package contains the static library and the header files of the\n Bio++ core classes.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 5 / 40","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libbpp-phyl-dev","distribution":"debian","release":"sid","component":"main","version":"2.4.1","source":"libbpp-phyl","homepage":"http://biopp.univ-montp2.fr/wiki/index.php/Main_Page","description":"Bio++ Phylogenetic library development files","long_description":" Bio++ is a set of C++ libraries for Bioinformatics, including sequence\n analysis, phylogenetics, molecular evolution and population genetics.\n Bio++ is Object Oriented and is designed to be both easy to use and\n computer efficient. Bio++ intends to help programmers to write computer\n expensive programs, by providing them a set of re-usable agents.\n .\n This package contains the static library and the header files of the\n Bio++ classes for phylogenetics.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 2 / 39","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libbpp-phyl-omics-dev","distribution":"debian","release":"sid","component":"main","version":"2.4.1","source":"libbpp-phyl-omics","homepage":"http://biopp.univ-montp2.fr/wiki/index.php/Main_Page","description":"Bio++ Phylogenetics library: genomics components (development files)","long_description":" Bio++ is a set of C++ libraries for Bioinformatics, including sequence\n analysis, phylogenetics, molecular evolution and population genetics.\n Bio++ is Object Oriented and is designed to be both easy to use and\n computer efficient. Bio++ intends to help programmers to write computer\n expensive programs, by providing them a set of re-usable agents.\n .\n This package contains the static library and the header files of the\n Bio++ classes dedicated to genomic phylogeny.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 35","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libbpp-popgen-dev","distribution":"debian","release":"sid","component":"main","version":"2.4.1","source":"libbpp-popgen","homepage":"http://biopp.univ-montp2.fr/wiki/index.php/Main_Page","description":"Bio++ Population Genetics library development files","long_description":" Bio++ is a set of C++ libraries for Bioinformatics, including sequence\n analysis, phylogenetics, molecular evolution and population genetics.\n Bio++ is Object Oriented and is designed to be both easy to use and\n computer efficient. Bio++ intends to help programmers to write computer\n expensive programs, by providing them a set of re-usable agents.\n .\n This package contains the static library and the header files of the\n Bio++ Population Genetics classes.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 37","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libbpp-qt-dev","distribution":"debian","release":"sid","component":"main","version":"2.4.1","source":"libbpp-qt","homepage":"http://biopp.univ-montp2.fr/wiki/index.php/Main_Page","description":"Bio++ Qt Graphic classes library development files","long_description":" Bio++ is a set of C++ libraries for Bioinformatics, including sequence\n analysis, phylogenetics, molecular evolution and population genetics.\n Bio++ is Object Oriented and is designed to be both easy to use and\n computer efficient. Bio++ intends to help programmers to write computer\n expensive programs, by providing them a set of re-usable agents.\n .\n Contains development files of the Bio++ graphical classes developed\n with Qt.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 33","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libbpp-raa-dev","distribution":"debian","release":"sid","component":"main","version":"2.4.1","source":"libbpp-raa","homepage":"http://biopp.univ-montp2.fr/wiki/index.php/Main_Page","description":"Bio++ Remote Acnuc Access library development files","long_description":" This library contains utilitary and classes to query public databases\n (GenBank, EMBL, SwissProt, etc) using acnuc.\n It is part of the Bio++ project.\n .\n This package contains header files and static library.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 35","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libbpp-seq-dev","distribution":"debian","release":"sid","component":"main","version":"2.4.1","source":"libbpp-seq","homepage":"http://biopp.univ-montp2.fr/wiki/index.php/Main_Page","description":"Bio++ Sequence library development files","long_description":" Bio++ is a set of C++ libraries for Bioinformatics, including sequence\n analysis, phylogenetics, molecular evolution and population genetics.\n Bio++ is Object Oriented and is designed to be both easy to use and\n computer efficient. Bio++ intends to help programmers to write computer\n expensive programs, by providing them a set of re-usable agents.\n .\n This package contains the static library and the header files of Bio++\n classes for sequence analysis classes.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 4 / 40","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libbpp-seq-omics-dev","distribution":"debian","release":"sid","component":"main","version":"2.4.1","source":"libbpp-seq-omics","homepage":"http://biopp.univ-montp2.fr/wiki/index.php/Main_Page","description":"Bio++ Sequence library: genomics components (development files)","long_description":" Bio++ is a set of C++ libraries for Bioinformatics, including sequence\n analysis, phylogenetics, molecular evolution and population genetics.\n Bio++ is Object Oriented and is designed to be both easy to use and\n computer efficient. Bio++ intends to help programmers to write computer\n expensive programs, by providing them a set of re-usable agents.\n .\n This package contains the static library and the header files of the\n Bio++ classes dedicated to genomic sequencing.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 2 / 35","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libchado-perl","distribution":"debian","release":"sid","component":"main","version":"1.31","source":"libchado-perl","homepage":"http://gmod.org/wiki/Chado","description":"database schema and agents for genomic data","long_description":" Chado is a relational database schema that underlies many GMOD\n installations. It is capable of representing many of the general\n classes of data frequently encountered in modern biology such as\n sequence, sequence comparisons, phenotypes, genotypes, ontologies,\n publications, and phylogeny. It has been designed to handle complex\n representations of biological knowledge and should be considered one\n of the most sophisticated relational schemas currently available in\n molecular biology. The price of this capability is that the new user\n must spend some time becoming familiar with its fundamentals.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 31","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libdisorder-dev","distribution":"debian","release":"sid","component":"main","version":"0.0.2+git20130809.8062ee1","source":"libdisorder","homepage":"https://github.com/locasto/libdisorder","description":"library for entropy measurement of byte streams (devel)","long_description":" This library provides a function to calculate the Shannon index (H)\n of byte streams.\n .\n This is the development package containing the statically linked\n library and the header files.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 33","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libdivsufsort-dev","distribution":"debian","release":"sid","component":"main","version":"2.0.1","source":"libdivsufsort","homepage":"https://github.com/y-256/libdivsufsort","description":"libdivsufsort header files","long_description":" The libdivsufsort project provides a fast, lightweight, and robust\n C API library to construct the suffix array and the Burrows-Wheeler\n transformed string for any input string of a constant-size alphabet.\n .\n This package installs files needed for development.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 2 / 74","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libedlib-dev","distribution":"debian","release":"sid","component":"main","version":"1.2.4","source":"libedlib","homepage":"https://github.com/Martinsos/edlib","description":"library for sequence alignment using edit distance (devel)","long_description":" A lightweight and super fast C/C++ library for sequence alignment using\n edit distance.\n .\n Calculating edit distance of two strings is as simple as:\n .\n  edlibAlign(\"hello\", 5, \"world!\", 6,\n             edlibDefaultAlignConfig()).editDistance;\n Features\n .\n  * Calculates edit distance (Levehnstein distance).\n  * It can find optimal alignment path (instructions how to transform\n    first sequence into the second sequence).\n  * It can find just the start and/or end locations of alignment path -\n    can be useful when speed is more important than having exact\n    alignment path.\n  * Supports multiple alignment methods: global(NW), prefix(SHW) and\n    infix(HW), each of them useful for different scenarios.\n  * You can extend character equality definition, enabling you to e.g.\n    have wildcard characters, to have case insensitive alignment or to\n    work with degenerate nucleotides.\n  * It can easily handle small or very large sequences, even when finding\n    alignment path, while consuming very little memory.\n  * Super fast thanks to Myers's bit-vector algorithm.\n .\n This package contains the static library and the header files.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 7 / 10","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"fastahack","distribution":"debian","release":"sid","component":"main","version":"0.0+git20160702.bbc645f","source":"libfastahack","homepage":"https://github.com/ekg/fastahack","description":"utility for indexing and sequence extraction from FASTA files","long_description":" fastahack is a small application for indexing and extracting sequences and\n subsequences from FASTA files.  The included Fasta.cpp library provides a FASTA\n reader and indexer that can be embedded into applications which would benefit\n from directly reading subsequences from FASTA files.  The library automatically\n handles index file generation and use.\n .\n Features:\n  * FASTA index (.fai) generation for FASTA files\n  * Sequence extraction\n  * Subsequence extraction\n  * Sequence statistics (currently only entropy is provided)\n .\n Sequence and subsequence extraction use fseek64 to provide fastest-possible\n extraction without RAM-intensive file loading operations.  This makes fastahack\n a useful agent for bioinformaticists who need to quickly extract many\n subsequences from a reference FASTA sequence.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 3 / 65","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_20516","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libfastahack-dev","distribution":"debian","release":"sid","component":"main","version":"0.0+git20160702.bbc645f","source":"libfastahack","homepage":"https://github.com/ekg/fastahack","description":"library for indexing and sequence extraction from FASTA files (devel)","long_description":" fastahack is a small application for indexing and extracting sequences and\n subsequences from FASTA files.  The included Fasta.cpp library provides a FASTA\n reader and indexer that can be embedded into applications which would benefit\n from directly reading subsequences from FASTA files.  The library automatically\n handles index file generation and use.\n .\n Features:\n  * FASTA index (.fai) generation for FASTA files\n  * Sequence extraction\n  * Subsequence extraction\n  * Sequence statistics (currently only entropy is provided)\n .\n Sequence and subsequence extraction use fseek64 to provide fastest-possible\n extraction without RAM-intensive file loading operations.  This makes fastahack\n a useful agent for bioinformaticists who need to quickly extract many\n subsequences from a reference FASTA sequence.\n .\n This is the development package containing the statically linked\n library and the header files.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 38","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_20516","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libfreecontact-perl","distribution":"debian","release":"sid","component":"main","version":"0.08","source":"libfreecontact-perl","homepage":"https://rostlab.org/owiki/index.php/FreeContact","description":"fast protein contact predictor - binding for Perl","long_description":" FreeContact is a protein residue contact predictor optimized for speed.\n Its input is a multiple sequence alignment. FreeContact can function as an\n accelerated drop-in for the published contact predictors\n EVfold-mfDCA of DS. Marks (2011) and\n PSICOV of D. Jones (2011).\n .\n FreeContact is accelerated by a combination of vector instructions, multiple\n threads, and faster implementation of key parts.\n Depending on the alignment, 8-fold or higher speedups are possible.\n .\n A sufficiently large alignment is required for meaningful results.\n As a minimum, an alignment with an effective (after-weighting) sequence count\n bigger than the length of the query sequence should be used. Alignments with\n tens of thousands of (effective) sequences are considered good input.\n .\n jackhmmer(1) from the hmmer package, or hhblits(1) from hhsuite\n can be used to generate the alignments, for example.\n .\n This package contains the Perl binding.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 34","doi":"10.1186/1471-2105-15-85","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_03520","SEQwiki":null,"SciCrunch":{"source":"libfreecontact-perl","name":"SciCrunch","entry":"SCR_016113"},"RRID":null},{"package":"libgenome-dev","distribution":"debian","release":"sid","component":"main","version":"1.3.11+svn20110227.4616","source":"libgenome","homepage":"https://sourceforge.net/projects/libgenome/","description":"agentkit for developing bioinformatic related software (devel)","long_description":" libGenome is a freely available agentkit for developing bioinformatic related\n software in C++.  It is intended to take the hassle out of performing common\n tasks on genetic sequence and annotation data.\n .\n Among other things, libGenome can help you:\n .\n  * Read and write Multi-FastA format files\n  * Read and write GenBank flat file database entries\n  * Append, chop, truncate, reverse, complement, translate, and otherwise\n    mangle sequence data\n  * Access annotation in GenBank flat files\n .\n This is the development package containing the statically linked\n library and the header files.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 3 / 8","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libgenome-model-agents-music-perl","distribution":"debian","release":"sid","component":"main","version":"0.04","source":"libgenome-model-agents-music-perl","homepage":"https://metacpan.org/release/Genome-Model-Agents-Music","description":"module for finding mutations of significance in cancer","long_description":" The MuSiC suite is a set of agents aimed at discovering the significance of\n somatic mutations found within a given cohort of cancer samples, and with\n respect to a variety of external data sources.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 33","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libgenome-perl","distribution":"debian","release":"sid","component":"main","version":"0.06","source":"libgenome-perl","homepage":"https://metacpan.org/release/Genome","description":"pipelines, agents, and data management for genomics","long_description":" This is the base namespace module for the Genome software tree.\n .\n That tree has several primary components:\n .\n Genome::Model: a data modeling pipeline management system for genomics\n .\n Genome::Model::Agents a tree of >1000 agents and agent wrappers for genomics\n .\n Genome::* a variety of sample tracking classes with an RDBMS back-end\n .\n Only the agents system is currently released.\n .\n See genome for a complete inventory of all agent packages, and for\n command-line access to those agents.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 0 / 40","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libgff-dev","distribution":"debian","release":"sid","component":"main","version":"1.0","source":"libgff","homepage":"https://github.com/Kingsford-Group/libgff","description":"GFF/GTF parsing from cufflinks as a library","long_description":" This is a simple \"libraryfication\" of the GFF/GTF parsing code that is used in\n the Cufflinks codebase.  There are not many (any?) relatively lightweight\n GTF/GFF parsers exposing a C++ interface, and the goal of this library is to\n provide this functionality without the necessity of drawing in a heavy-weight\n dependency like SeqAn.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 0 / 36","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libgkarrays-dev","distribution":"debian","release":"sid","component":"main","version":"2.1.0","source":"libgkarrays","homepage":"http://crac.gforge.inria.fr/gkarrays/","description":"library to query large collection of NGS sequences (development)","long_description":" Gk-arrays are provided as a simple-to-use C++ library dedicated to\n queries on large collection of sequences as produced by high-throughput\n sequencers (e.g. HiSeq 2000 from Illumina, 454 from Roche).\n .\n Gk-arrays index k-mers of reads and allows one to answer different queries\n on that read collection (e.g. how many reads share this k-mer? where does\n this k-mer occur in the read collection?).\n .\n Gk-arrays consist of a space-efficient alternative to hash tables while\n being similar in terms of query times.\n .\n This is the development library for libgkarrays.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 29","doi":"10.1186/1471-2105-12-242","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libgoby-java","distribution":"prospective","release":"vcs","component":"main","version":"3.3.0","source":"libgoby-java","homepage":"http://campagnelab.org/software/goby/","description":"store next-generation sequencing data and intermediary analysis results","long_description":" Goby is a next-gen data management framework designed to facilitate the\n implementation of efficient data analysis pipelines.\n .\n Goby provides very efficient file formats to store next-generation\n sequencing data and intermediary analysis results. Goby 1.x files were\n compressed with GZip. In Goby 2.0, we introduced novel compression\n approaches that result in state of the art compression of alignment\n data. Goby 2.0 files can compress to a few percent of a BAM file and are\n often smaller than CRAM files.  \n .\n Goby also provides utilities that implement common next-gen data\n computations. We design these utilities to make them relatively easy to\n use, yet very efficient.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libgo-perl","distribution":"debian","release":"sid","component":"main","version":"0.15","source":"libgo-perl","homepage":"http://geneontology.sourceforge.net/","description":"perl modules for GO and other OBO ontologies","long_description":" This is a collection of perl code for dealing with Gene Ontologies (GO) and\n Open Biomedical Ontologies (OBO) style ontologies. It is part of the ‘go-dev’\n distribution, but this Debian package is made from the CPAN archive. This\n package contains both scripts (which can be used with no knowledge of perl),\n and libraries which will be of use to perl programmers using GO or OBO.\n","interface":["commandline"],"biology":null,"fields":["biology","biology:bioinformatics"],"use":["analysing","converting"],"popcon":"9 / 3 / 126","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libgtextutils-dev","distribution":"debian","release":"sid","component":"main","version":"0.7","source":"libgtextutils","homepage":"http://hannonlab.cshl.edu/fastx_agentkit/","description":"Gordon Text_utils library (development files)","long_description":" The Gordon Text_utils (gtextutils) library is a text utilities library used by\n the FASTX-Agentkit, a suite of programs for biological sequence analysis.\n .\n Development files for the Gordon Text_utils (gtextutils) library.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 17","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libhmsbeagle-dev","distribution":"debian","release":"sid","component":"main","version":"3.1.2","source":"libhmsbeagle","homepage":"https://github.com/beagle-dev/beagle-lib","description":"High-performance lib for Bayesian and Maximum Likelihood phylogenetics (devel)","long_description":" BEAGLE is a high-performance library that can perform the core calculations at\n the heart of most Bayesian and Maximum Likelihood phylogenetics packages. It\n can make use of highly-parallel processors such as those in graphics cards\n (GPUs) found in many PCs.\n .\n The project involves an open API and fast implementations of a library for\n evaluating phylogenetic likelihoods (continuous time Markov processes) of\n biomolecular sequence evolution.\n .\n The aim is to provide high performance evaluation 'services' to a wide range\n of phylogenetic software, both Bayesian samplers and Maximum Likelihood\n optimizers.  This allows these packages to make use of implementations that\n make use of optimized hardware such as graphics processing units.\n .\n This package contains development files needed to build against Beagle library.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 8 / 39","doi":"10.1093/sysbio/syr100","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libjloda-java","distribution":"debian","release":"sid","component":"main","version":"0.0+git20180523.cbaf6d1","source":"libjloda-java","homepage":"https://github.com/danielhuson/jloda","description":"Java library of data structures and algorithms for bioinformatics","long_description":" The jloda Java library provides some basic data structures and\n algorithms used by bioinformatics applications like SplitsTree,\n Dendroscope and MEGAN.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 30","doi":"10.1101/050559","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libmems-dev","distribution":"debian","release":"sid","component":"main","version":"1.6.0+4725","source":"libmems","homepage":"http://sourceforge.net/p/mauve/code/HEAD/tree/libMems/trunk/","description":"development library to support DNA string matching and comparative genomics","long_description":" libMems is a freely available software development library to support DNA\n string matching and comparative genomics. Among other things, libMems\n implements an algorithm to perform approximate multi-MUM and multi-MEM\n identification. The algorithm uses spaced seed patterns in conjunction\n with a seed-and-extend style hashing method to identify matches. The method\n is efficient, requiring a maximum of only 16 bytes per base of the largest\n input sequence, and this data can be stored externally (i.e. on disk) to\n further reduce memory requirements.\n .\n This is the development package containing the statically linked\n library and the header files.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 3 / 5","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libmuscle-dev","distribution":"debian","release":"sid","component":"main","version":"3.7+4565","source":"libmuscle","homepage":"http://sourceforge.net/p/mauve/code/HEAD/tree/muscle/trunk/","description":"multiple alignment development library for protein sequences","long_description":" MUSCLE is a multiple alignment program for protein sequences. MUSCLE\n stands for multiple sequence comparison by log-expectation. In the\n authors tests, MUSCLE achieved the highest scores of all tested\n programs on several alignment accuracy benchmarks, and is also one of\n the fastest programs out there.\n .\n This library was derived from the original MUSCLE and turned into\n a library.\n .\n This package contains the static library and header files.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 5 / 10","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libncl-dev","distribution":"debian","release":"sid","component":"main","version":"2.1.21+git20180827.c71b264","source":"libncl","homepage":"https://github.com/mtholder/ncl","description":"NEXUS Class Library (static lib and header files)","long_description":" The NEXUS Class Library is a C++ library for parsing NEXUS files.\n .\n The NEXUS file format is widely used in bioinformatics. Several popular\n phylogenetic programs such as Paup, MrBayes, Mesquite, and MacClade use\n this format.\n .\n This package contains the static library and header files of the NEXUS\n library.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 33","doi":"10.1093/bioinformatics/btg319","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_20523","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"ncl-agents","distribution":"debian","release":"sid","component":"main","version":"2.1.21+git20180827.c71b264","source":"libncl","homepage":"https://github.com/mtholder/ncl","description":"agents to deal with NEXUS files","long_description":" The NEXUS Class Library is a C++ library for parsing NEXUS files.\n .\n The NEXUS file format is widely used in bioinformatics. Several popular\n phylogenetic programs such as Paup, MrBayes, Mesquite, and MacClade use\n this format.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 3 / 73","doi":"10.1093/bioinformatics/btg319","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_20523","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libnhgri-blastall-perl","distribution":"debian","release":"sid","component":"main","version":"0.66","source":"libnhgri-blastall-perl","homepage":"ftp://ftp.nhgri.nih.gov/pub/software/blastall/","description":"Perl extension for running and parsing NCBI's BLAST 2.x","long_description":" NHGRI::Blastall will enable usage of BLAST out of a Perl script, if BLAST2\n or WU-BLAST are installed locally. Main features are:\n  * run BLAST (also via network, which requires blastcl3)\n  * BLAST single sequences against each other or against a given library\n  * format databases\n  * mask out repetitive DNA\n  * read, parse and filter existing BLAST reports\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 47","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libpal-java","distribution":"debian","release":"sid","component":"main","version":"1.5.1","source":"libpal-java","homepage":"http://www.cebl.auckland.ac.nz/pal-project/","description":"Phylogenetic Analysis Library","long_description":" The PAL project is a collaborative effort to provide a high quality Java\n library for use in molecular evolution and phylogenetics. At present PAL\n consists of approximately 200 public classes/interfaces in 16 packages\n Please refer to the API documentation for a detailed description of all\n classes and methods available, and to the release history for an\n overview of the development history of PAL.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 4 / 75","doi":"10.1093/bioinformatics/17.7.662","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libpll-dev","distribution":"debian","release":"sid","component":"main","version":"0.3.2","source":"libpll","homepage":"http://www.libpll.org/","description":"Phylogenetic Likelihood Library (development)","long_description":" PLL is a highly optimized, parallelized software library to ease the\n development of new software agents dealing with phylogenetic inference.\n .\n Among the functions included in PLL are parsing multiple sequence\n alignments (MSA) from PHYLIP and FASTA files, reading Newick trees,\n performing topological moves such as SPR and NNI, model optimization,\n likelihood evaluation and partitioned analysis by assigning different\n substitution models to each partition of the MSA. PLL fully implements\n the GTR nucleotide substitution model for DNA data and a number of\n models for aminoacid data.\n .\n This package contains the static library and the header file.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 7 / 9","doi":"10.1109/IPDPSW.2013.103","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libmodhmm-dev","distribution":"debian","release":"sid","component":"main","version":"1.0","source":"libpsortb","homepage":"http://www.psort.org/","description":"library for constructing, training and scoring hidden Markov models (dev)","long_description":" Library for constructing, training and scoring hidden Markov models.  It\n is provided with PSORTb but might be used separately.\n .\n PSORTb enables prediction of bacterial protein subcellular localization\n (SCL) and provides a quick and inexpensive means for gaining insight\n into protein function, verifying experimental results, annotating newly\n sequenced bacterial genomes, detecting potential cell surface/secreted\n drug targets, as well as identifying biomarkers for microbes.\n .\n This library needed by PSORTb is distributed separately by upstream.\n .\n This package contains the static library which is needed to link PSORTb.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 2","doi":"10.1093/bioinformatics/btq249","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libsvmloc-dev","distribution":"debian","release":"sid","component":"main","version":"1.0","source":"libpsortb","homepage":"http://www.psort.org/","description":"PSORTb adapted library for svm machine-learning library (dev)","long_description":" Libsvm is a machine-learning library which is an easy-to-use package\n for support vector classification, regression and one-class SVM. It\n supports multi-class classification, probability outputs, and\n parameter selection.\n .\n PSORTb was featuring a code copy plus some local additions.  This\n library is linked against the Debian packaged libsvn and just contains\n the PSORTb extensions.\n .\n PSORTb enables prediction of bacterial protein subcellular localization\n (SCL) and provides a quick and inexpensive means for gaining insight\n into protein function, verifying experimental results, annotating newly\n sequenced bacterial genomes, detecting potential cell surface/secreted\n drug targets, as well as identifying biomarkers for microbes.\n .\n This library needed by PSORTb is distributed separately by upstream.\n .\n This package contains the static library which is needed to link PSORTb.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 3","doi":"10.1093/bioinformatics/btq249","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libqcpp-dev","distribution":"prospective","release":"vcs","component":"main","version":"0.1.9","source":"libqcpp","homepage":"https://github.com/kdmurray91/libqcpp","description":"C++11 library for NGS data quality control -- headers","long_description":" A C++ library for next-gen sequencing data quality control.\n .\n QC++ implements adaptor trimming, windowed quality trimming, length filtering\n and trimming, format conversion, and basic read manipulation. It also provides\n classes for impelementation of new measures and easy creation of bespoke\n filtering agents.\n .\n This package provides the development headers and static archive.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libqes-dev","distribution":"debian","release":"sid","component":"main","version":"0.2.8","source":"libqes","homepage":"https://github.com/kdmurray91/libqes","description":"DNA sequence parsing library -- development","long_description":" A small C library, with a bioinformatic focus. Optimised for speed and a clean\n API. Handles sequence parsing and miscellaneous manipulation of DNA sequences.\n .\n These are the development headers required to use libqes in your own\n applications.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 34","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_20524","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"librcsb-core-wrapper0-dev","distribution":"debian","release":"sid","component":"main","version":"1.005","source":"librcsb-core-wrapper","homepage":"http://sw-agents.rcsb.org/apps/CORE-WRAPPER/index.html","description":"development files for librcsb-core-wrapper0","long_description":" The RCSB Core Wrapper library was developed to provide an object-oriented\n application interface to information in mmCIF format. It includes several\n classes for accessing data dictionaries and mmCIF format data files.\n .\n This package contains files necessary for developing applications with\n the library.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 5 / 36","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python-corepywrap","distribution":"debian","release":"sid","component":"main","version":"1.005","source":"librcsb-core-wrapper","homepage":"http://sw-agents.rcsb.org/apps/CORE-WRAPPER/index.html","description":"library that exports C++ mmCIF accessors to Python","long_description":" The RCSB Core Wrapper library was developed to provide an object-oriented\n application interface to information in mmCIF format. It includes several\n classes for accessing data dictionaries and mmCIF format data files.\n .\n This library provides Python bindings for librcsb-core-wrapper.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 5 / 36","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"librdp-taxonomy-tree-java","distribution":"debian","release":"sid","component":"main","version":"1.2.0","source":"librdp-taxonomy-tree-java","homepage":"https://github.com/rdpstaff/TaxonomyTree","description":"taxonomy tree library from Ribosomal Database Project (RDP)","long_description":" The TaxonomyTree project is a library used by other  Ribosomal Database\n Project (RDP) agents.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 4 / 74","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"librg-blast-parser-perl","distribution":"debian","release":"sid","component":"main","version":"0.03","source":"librg-blast-parser-perl","homepage":"http://rostlab.org/","description":"very fast NCBI BLAST parser - binding for Perl","long_description":" This package contains Perl binding for a very fast C++ library that parses\n the default output of NCBI BLAST programs.  BLAST results are returned in a\n convenient hash structure.\n .\n Evaluated on a very small test set, this parser is considerably faster\n than Zerg::Report from libzerg-perl.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 43","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"librg-utils-perl","distribution":"debian","release":"sid","component":"main","version":"1.0.43","source":"librg-utils-perl","homepage":"http://predictprotein.org/","description":"parsers and format conversion utilities used by (e.g.) profphd","long_description":" This package contributes to the PredictProtein server for the automated\n structural annotation of protein sequences. It features as series of conversion\n agents like:\n .\n  * blast2saf.pl\n  * blastpgp_to_saf.pl\n  * conv_hssp2saf.pl\n  * copf.pl\n  * hssp_filter.pl\n  * safFilterRed.pl\n .\n which are supported by the modules:\n .\n  * RG:Utils::Conv_hssp2saf\n  * RG:Utils::Copf\n  * RG:Utils::Hssp_filter\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"11 / 3 / 129","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libroadrunner-dev","distribution":"prospective","release":"vcs","component":"main","version":"1.5.1","source":"libroadrunner","homepage":"http://libroadrunner.org/","description":"simulation engine for systems and synthetic biology (development)","long_description":" LibRoadRunner is a high performance and portable simulation engine for\n systems and synthetic biology. I can run on many platforms including\n Windows, Mac OS, and Linux. libRoadRunner is major rewrite of the\n original C# roadRunner developed by Frank Bergmann and Herbert Sauro.\n The same original functionality however remains, including the\n original C API, the structural analysis code, sensitivity and steady\n state analyses, but with significant improvements to performance, back-\n end design, better event handling, new C++ API and stochastic\n simulation support.\n .\n This package contains the header files for libroadrunner.","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 1 / 1","doi":"10.1093/bioinformatics/btv363","topics":null,"edam_scopes":null,"bio.agents":"libRoadRunner","OMICagents":"OMICS_09368","SEQwiki":null,"SciCrunch":{"source":"libroadrunner","name":"SciCrunch","entry":"SCR_014763"},"RRID":null},{"package":"python-roadrunner","distribution":"prospective","release":"vcs","component":"main","version":"1.5.1","source":"libroadrunner","homepage":"http://libroadrunner.org/","description":"Python bindings for libroadrunner","long_description":" LibRoadRunner is a high performance and portable simulation engine for\n systems and synthetic biology. I can run on many platforms including\n Windows, Mac OS, and Linux. libRoadRunner is major rewrite of the\n original C# roadRunner developed by Frank Bergmann and Herbert Sauro.\n The same original functionality however remains, including the\n original C API, the structural analysis code, sensitivity and steady\n state analyses, but with significant improvements to performance, back-\n end design, better event handling, new C++ API and stochastic\n simulation support.\n .\n This package contains the Python bindings for libroadrunner.","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 0 / 1","doi":"10.1093/bioinformatics/btv363","topics":null,"edam_scopes":null,"bio.agents":"libRoadRunner","OMICagents":"OMICS_09368","SEQwiki":null,"SciCrunch":{"source":"libroadrunner","name":"SciCrunch","entry":"SCR_014763"},"RRID":null},{"package":"librostlab3-dev","distribution":"debian","release":"sid","component":"main","version":"1.0.20","source":"librostlab","homepage":"http://rostlab.org/","description":"C++ library for computational biology (development)","long_description":" This library was developed by the Rost Lab.  The lab's research is\n driven by a conviction that protein and DNA sequences encode a\n significant core of information about the ultimate structure and\n function of genetic material and its gene products.\n .\n The library provides the following facilities:\n  * current working directory resource\n  * exception with stack backtrace\n  * file lock resource\n  * passwd and group structures for C++\n  * effective uid and gid resource\n  * rostlab::bio::seq class with stream input operator for FASTA format\n  * umask resource\n .\n This package contains files necessary for developing applications with\n librostlab.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 42","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"librostlab-doc","distribution":"debian","release":"sid","component":"main","version":"1.0.20","source":"librostlab","homepage":"http://rostlab.org/","description":"C++ library for computational biology (documentation)","long_description":" This library was developed by the Rost Lab.  The lab's research is\n driven by a conviction that protein and DNA sequences encode a\n significant core of information about the ultimate structure and\n function of genetic material and its gene products.\n .\n The library provides the following facilities:\n  * current working directory resource\n  * exception with stack backtrace\n  * file lock resource\n  * passwd and group structures for C++\n  * effective uid and gid resource\n  * rostlab::bio::seq class with stream input operator for FASTA format\n  * umask resource\n .\n This package contains html documentation.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 13","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"librostlab-blast0-dev","distribution":"debian","release":"sid","component":"main","version":"1.0.1","source":"librostlab-blast","homepage":"http://rostlab.org/","description":"very fast C++ library for parsing the output of NCBI BLAST programs (devel)","long_description":" This package provides a very fast library for parsing the default output of\n NCBI BLAST programs into a C++ structure.\n .\n libzerg is faster, but it provides only lexing (i.e. it only returns pairs\n of token identifiers and token string values).  librostlab-blast uses a\n parser generated with bison on top of a flex-generated lexer very similar to\n that of libzerg.\n .\n This package contains files necessary for developing applications with\n librostlab-blast.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 0 / 44","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"librostlab-blast-doc","distribution":"debian","release":"sid","component":"main","version":"1.0.1","source":"librostlab-blast","homepage":"http://rostlab.org/","description":"very fast C++ library for parsing the output of NCBI BLAST programs (doc)","long_description":" This package provides a very fast library for parsing the default output of\n NCBI BLAST programs into a C++ structure.\n .\n libzerg is faster, but it provides only lexing (i.e. it only returns pairs\n of token identifiers and token string values).  librostlab-blast uses a\n parser generated with bison on top of a flex-generated lexer very similar to\n that of libzerg.\n .\n This package contains html and pdf documentation.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 13","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libsbml5-dev","distribution":"debian","release":"sid","component":"main","version":"5.17.2","source":"libsbml","homepage":"http://www.sbml.org/","description":"System Biology Markup Language library - development files","long_description":" LibSBML is a library designed to help you read, write, manipulate,\n translate, and validate SBML files and data streams. It is not an\n application itself (though it does come with many example programs),\n but rather a library you can embed in your own applications.\n .\n This package contains files necessary for development with libsbml.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 8 / 57","doi":"10.1093/bioinformatics/btn051","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libseqlib-dev","distribution":"debian","release":"sid","component":"main","version":"1.1.2","source":"libseqlib","homepage":"https://github.com/walaj/SeqLib","description":"C++ htslib/bwa-mem/fermi interface for interrogating sequence data (dev)","long_description":" C++ API and command line agent that provides a rapid and user-friendly\n interface to BAM/SAM/CRAM files, global sequence alignment operations\n and sequence assembly. Four C libraries perform core operations in\n SeqLib: HTSlib for BAM access, BWA-MEM and BLAT for sequence alignment\n and Fermi for error correction and sequence assembly. Benchmarking\n indicates that SeqLib has lower CPU and memory requirements than leading\n C++ sequence analysis APIs. Minimal SeqLib code can extract, error-correct\n and assemble reads from a CRAM file and then align with BWA-MEM.\n SeqLib also provides additional capabilities, including chromosome-aware\n interval queries and read plotting. Command line agents are available for\n performing integrated error correction, micro-assemblies and alignment.\n .\n This package contains the header files and static library.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 2 / 7","doi":"10.1093/bioinformatics/btw741","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_14682","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libsmithwaterman-dev","distribution":"debian","release":"sid","component":"main","version":"0.0+git20160702.2610e25","source":"libsmithwaterman","homepage":"https://github.com/ekg/smithwaterman","description":"determine similar regions between two strings or genomic sequences (devel)","long_description":" The Smith–Waterman algorithm performs local sequence alignment; that is,\n for determining similar regions between two strings or nucleotide or\n protein sequences. Instead of looking at the total sequence, the\n Smith–Waterman algorithm compares segments of all possible lengths and\n optimizes the similarity measure.\n .\n This is the development package containing the statically linked\n library and the header files.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 39","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"smithwaterman","distribution":"debian","release":"sid","component":"main","version":"0.0+git20160702.2610e25","source":"libsmithwaterman","homepage":"https://github.com/ekg/smithwaterman","description":"determine similar regions between two strings or genomic sequences","long_description":" The Smith–Waterman algorithm performs local sequence alignment; that is,\n for determining similar regions between two strings or nucleotide or\n protein sequences. Instead of looking at the total sequence, the\n Smith–Waterman algorithm compares segments of all possible lengths and\n optimizes the similarity measure.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 3 / 61","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libsort-key-top-perl","distribution":"debian","release":"sid","component":"main","version":"0.08","source":"libsort-key-top-perl","homepage":"https://metacpan.org/release/Sort-Key-Top","description":"Perl module to select and sort top n elements of a list","long_description":" The functions available from this module select the top n elements from a\n list using several common orderings and custom key extraction procedures.\n .\n They are all variations around 'keytopsort { CALC_KEY($_) } $n => @data;'.\n .\n In array context, this function calculates the ordering key for every element\n in @data using the expression inside the block. Then it selects and orders\n the $n elements with the lower keys when compared lexicographically.\n .\n In scalar context, the value returned by the functions on this module is the\n cutoff value allowing to select nth element from the array.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 0 / 50","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libssw-dev","distribution":"debian","release":"sid","component":"main","version":"1.1","source":"libssw","homepage":"https://github.com/mengyao/Complete-Striped-Smith-Waterman-Library","description":"Development headers and static libraries for libssw","long_description":" This package provides development headers and static libraries for libssw,\n a fast implementation of the Smith-Waterman algorithm using\n Single-Instruction Multiple-Data (SIMD) instructions to parallelize the\n algorithm at the instruction level.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 1 / 35","doi":"10.1371/journal.pone.0082138","topics":null,"edam_scopes":null,"bio.agents":"SSW","OMICagents":"OMICS_20525","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libssw-java","distribution":"debian","release":"sid","component":"main","version":"1.1","source":"libssw","homepage":"https://github.com/mengyao/Complete-Striped-Smith-Waterman-Library","description":"Java bindings for libssw","long_description":" This package provides JNI based Java bindings for libssw, a fast\n implementation of the Smith-Waterman algorithm using Single-Instruction\n Multiple-Data (SIMD) instructions to parallelize the algorithm at the\n instruction level.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 3 / 68","doi":"10.1371/journal.pone.0082138","topics":null,"edam_scopes":null,"bio.agents":"SSW","OMICagents":"OMICS_20525","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"ssw-align","distribution":"debian","release":"sid","component":"main","version":"1.1","source":"libssw","homepage":"https://github.com/mengyao/Complete-Striped-Smith-Waterman-Library","description":"Smith-Waterman aligner based on libssw","long_description":" This package provides a command-line aligner based on the libssw library,\n a fast SIMD accelerated implementation of the Smith-Waterman algorithm.\n The input files can be in FASTA or FASTQ format. Both target and query files\n can contain multiple sequences. Each sequence in the query file will be\n aligned with all sequences in the target file. Output is provided in SAM or\n BLAST-like text format.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 3 / 57","doi":"10.1371/journal.pone.0082138","topics":null,"edam_scopes":null,"bio.agents":"SSW","OMICagents":"OMICS_20525","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libstatgen-dev","distribution":"debian","release":"sid","component":"main","version":"1.0.14","source":"libstatgen","homepage":"https://genome.sph.umich.edu/wiki/C++_Library:_libStatGen","description":"development files for the libStatGen","long_description":" libStatGen is a library for statistical genetic programs. It includes some:\n A. General Operation Classes including: File/Stream I/O, String processing\n  and Parameter Parsing.\n B. Statistical Genetic Specific Classes including: Handling Common file\n  formats (Accessors to get/set values, Indexed access to BAM files) and\n  some utility classes, including: 1. Cigar: interpretation and mapping\n  between query and reference. 2. Pileup: structured access to data by\n  individual reference position.\n .\n This package provides the development files for libstatgen.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 7 / 9","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libswarm2-dev","distribution":"prospective","release":"vcs","component":"main","version":"2.4.1","source":"libswarm","homepage":"http://www.swarm.org/","description":"agent-based modeling to education, biomedical research and others","long_description":" The Swarm conceptual framework for agent-based model (ABMs) and\n provides many agents for implementing, observing and conducting\n experiments on ABMs.  Users write their own software but (a) follow\n Swarm's conceptual framework and conventions to design the software, and\n (b) use the Swarm libraries to do much of the work.  The library is\n written in Objective-C.\n .\n This package contains the development files and documentation for\n developing agent-based models using Swarm.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libtabixpp-dev","distribution":"debian","release":"sid","component":"main","version":"1.0.0","source":"libtabixpp","homepage":"https://github.com/ekg/tabixpp","description":"C++ wrapper to tabix indexer (development files)","long_description":" This package provides development headers and static libraries for libtabixpp,\n a C++ interface wrapper for Tabix. Tabix is a part of htslib to index tabular\n files in which some columns indicate sequence coordinates.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 36","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libtfbs-perl","distribution":"debian","release":"sid","component":"main","version":"0.7.1","source":"libtfbs-perl","homepage":"http://tfbs.genereg.net","description":"scanning DNA sequence with a position weight matrix","long_description":" The TFBS perl modules comprise a set of routines to interact with the\n Transfac and Jaspar databases that describe a special family of proteins,\n the transcription factors. These bind to genomic DNA to initiate (or\n prevent) the readout of a gene.  Once multiple binding sites are known\n for a transcription factor, these are gathered in a single file and are\n aligned in order to find position-specific characteristica that might\n be used to predict such binding events in novel DNA sequences.\n .\n If you use TFBS in your work, please cite \"Lenhard B., Wasserman W.W. (2002)\n TFBS: Computational framework for transcription factor binding site analysis.\n Bioinformatics 18:1135-1136\".\n .\n Note: the TFBS perl module is no longer under active development.  All the\n functionality can be found in the TFBSAgents Bioconductor package; users are\n highly encouraged to switch.  <http://bioconductor.org/packages/TFBSAgents/>\n","interface":null,"biology":null,"fields":["biology:bioinformatics","biology"],"use":null,"popcon":"0 / 0 / 32","doi":"10.1093/bioinformatics/18.8.1135","topics":null,"edam_scopes":null,"bio.agents":"TFBS","OMICagents":"OMICS_20526","SEQwiki":null,"SciCrunch":{"source":"libtfbs-perl","name":"SciCrunch","entry":"SCR_015774"},"RRID":null},{"package":"libthread-pool-dev","distribution":"debian","release":"sid","component":"main","version":"1.0.0","source":"libthread-pool","homepage":"https://github.com/rvaser/libthread-pool","description":"C++ thread pool library (devel)","long_description":" A thread pool is a software design pattern for achieving concurrency of\n execution in a computer program. Often also called a replicated workers\n or worker-crew model,[1] a thread pool maintains multiple threads\n waiting for tasks to be allocated for concurrent execution by the\n supervising program.\n .\n This package contains the static library and the header files.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 12","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libvcflib-dev","distribution":"debian","release":"sid","component":"main","version":"1.0.0~rc2","source":"libvcflib","homepage":"https://github.com/ekg/vcflib","description":"C++ library for parsing and manipulating VCF files (development)","long_description":" The Variant Call Format (VCF) is a flat-file, tab-delimited textual format\n intended to concisely describe reference-indexed variations between\n individuals. VCF provides a common interchange format for the description of\n variation in individuals and populations of samples, and has become the defacto\n standard reporting format for a wide array of genomic variant detectors.\n .\n vcflib provides methods to manipulate and interpret sequence variation as it\n can be described by VCF. It is both:\n .\n  * an API for parsing and operating on records of genomic variation as it can\n    be described by the VCF format,\n  * and a collection of command-line utilities for executing complex\n    manipulations on VCF files.\n .\n This package contains the static library and the header files.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 29","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"vcflib","OMICagents":"OMICS_02112","SEQwiki":null,"SciCrunch":{"source":"libvcflib","name":"SciCrunch","entry":"SCR_001231"},"RRID":null},{"package":"libvcflib-agents","distribution":"debian","release":"sid","component":"main","version":"1.0.0~rc2","source":"libvcflib","homepage":"https://github.com/ekg/vcflib","description":"C++ library for parsing and manipulating VCF files (agents)","long_description":" The Variant Call Format (VCF) is a flat-file, tab-delimited textual format\n intended to concisely describe reference-indexed variations between\n individuals. VCF provides a common interchange format for the description of\n variation in individuals and populations of samples, and has become the defacto\n standard reporting format for a wide array of genomic variant detectors.\n .\n vcflib provides methods to manipulate and interpret sequence variation as it\n can be described by VCF. It is both:\n .\n  * an API for parsing and operating on records of genomic variation as it can\n    be described by the VCF format,\n  * and a collection of command-line utilities for executing complex\n    manipulations on VCF files.\n .\n This package contains several agents using the library.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 4 / 58","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"vcflib","OMICagents":"OMICS_02112","SEQwiki":null,"SciCrunch":{"source":"libvcflib","name":"SciCrunch","entry":"SCR_001231"},"RRID":null},{"package":"libzerg0-dev","distribution":"debian","release":"sid","component":"main","version":"1.0.7","source":"libzerg","homepage":"https://sourceforge.net/projects/libzerg/","description":"development libraries and header files for libzerg","long_description":" Zerg is a C library for lexing - lexically scanning - the output of NCBI\n BLAST programs.\n .\n Based on a\n GNU Flex-generated lexical scanner, it runs extremely fast, being especially\n useful for processing large volumes of data. Benchmark tests show that Zerg\n is over two orders of magnitude faster than some widely used BLAST parsers.\n .\n If you need a parser and not only a lexer, check out librostlab-blast.\n .\n This package contains the header files and documentation\n needed to develop applications with libzerg.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 38","doi":"10.1093/bioinformatics/btg122","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libzerg-perl","distribution":"debian","release":"sid","component":"main","version":"1.0.4","source":"libzerg-perl","homepage":"https://tracker.debian.org/libzerg-perl","description":"fast perl module for parsing the output of NCBI BLAST programs","long_description":" The Zerg library contains a C/flex lexical scanner for BLAST reports\n and a set of supporting functions. It is centered on a \"get_token\"\n function that scans the input for specified lexical elements and, when\n one is found, returns its code and value to the user.\n .\n It is intended to be fast: for that the authors used flex, which provides\n simple regular expression matching and input buffering in the\n generated C scanner. And it is intended to be simple in the sense of\n providing just a lexical scanner, with no features whose support could\n slow down its main function.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 39","doi":"10.1093/bioinformatics/btg122","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"lofreq","distribution":"prospective","release":"vcs","component":"main","version":"2.1.3.1","source":"lofreq","homepage":"http://csb5.github.io/lofreq/","description":"sensitive variant calling from sequencing data","long_description":" LoFreq* (i.e. LoFreq version 2) is a fast and sensitive\n variant-caller for inferring SNVs and indels from next-generation\n sequencing data. It makes full use of base-call qualities and other\n sources of errors inherent in sequencing (e.g. mapping or base/indel\n alignment uncertainty), which are usually ignored by other methods or\n only used for filtering.\n .\n LoFreq* can run on almost any type of aligned sequencing data\n (e.g. Illumina, IonTorrent or Pacbio) since no machine- or\n sequencing-technology dependent thresholds are used. It automatically\n adapts to changes in coverage and sequencing quality and can\n therefore be applied to a variety of data-sets e.g.\n viral/quasispecies, bacterial, metagenomics or somatic data.\n .\n LoFreq* is very sensitive; most notably, it is able to predict\n variants below the average base-call quality (i.e. sequencing error\n rate). Each variant call is assigned a p-value which allows for\n rigorous false positive control. Even though it uses no\n approximations or heuristics, it is very efficient due to several\n runtime optimizations and also provides a (pseudo-)parallel\n implementation. LoFreq* is generic and fast enough to be applied to\n high-coverage data and large genomes. On a single processor it takes\n a minute to analyze Dengue genome sequencing data with nearly 4000X\n coverage, roughly one hour to call SNVs on a 600X coverage E.coli\n genome and also roughly an hour to run on a 100X coverage human exome\n dataset.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1093/nar/gks918","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_00063","SEQwiki":null,"SciCrunch":{"source":"lofreq","name":"SciCrunch","entry":"SCR_013054"},"RRID":null},{"package":"logol","distribution":"debian","release":"sid","component":"main","version":"1.7.9","source":"logol","homepage":"http://logol.genouest.org","description":"Pattern matching agent using Logol language","long_description":" Logol is a pattern matching agent using the Logol language.\n It searches with a specific grammar for a pattern in small\n or large sequences (DNA, RNA, protein). It provides complete\n result matching with the original grammar in the results.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 2 / 20","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"logol","OMICagents":"OMICS_20118","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"loki","distribution":"debian","release":"sid","component":"main","version":"2.4.7.4","source":"loki","homepage":null,"description":"MCMC linkage analysis on general pedigrees","long_description":" Performs Markov chain Monte Carlo multipoint linkage analysis on large,\n complex pedigrees.  The current package supports analyses on quantitative\n traits only, although this restriction will be lifted in later versions.\n Joint estimation of QTL number, position and effects uses Reversible Jump\n MCMC. It is also possible to perform affected only IBD sharing analyses.\n","interface":["commandline"],"biology":null,"fields":["biology"],"use":["TODO","analysing"],"popcon":"10 / 4 / 106","doi":"10.1086/515506","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_09402","SEQwiki":null,"SciCrunch":{"source":"loki","name":"SciCrunch","entry":"SCR_013119"},"RRID":null},{"package":"ltrsift","distribution":"debian","release":"sid","component":"main","version":"1.0.2","source":"ltrsift","homepage":"http://www.zbh.uni-hamburg.de/LTRsift","description":"postprocessing and classification of LTR retrotransposons","long_description":" LTRsift is a graphical desktop agent for semi-automatic postprocessing of de\n novo predicted LTR retrotransposon annotations, such as the ones generated by\n LTRharvest and LTRdigest. Its user-friendly interface displays LTR\n retrotransposon candidates, their putative families and their internal\n structure in a hierarchical fashion, allowing the user to \"sift\" through the\n sometimes large results of de novo prediction software. It also offers\n customizable filtering and classification functionality.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 3 / 107","doi":"10.1186/1759-8753-3-18","topics":["Mobile genetic elements"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Sequence", "formats": ["Binary format"]}, {"data": "Sequence features", "formats": ["GFF3"]}], "outputs": [{"data": "Sequence", "formats": ["FASTA"]}, {"data": "Sequence features", "formats": ["GFF3"]}], "function": ["Sequence classification", "Visualisation", "Genome annotation"]}],"bio.agents":null,"OMICagents":"OMICS_11266","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"lucy","distribution":"debian","release":"sid","component":"main","version":"1.20","source":"lucy","homepage":"https://lucy.sourceforge.net","description":"DNA sequence quality and vector trimming agent","long_description":" Lucy is a utility that prepares raw DNA sequence fragments for sequence\n assembly, possibly using the TIGR Assembler. The cleanup process includes\n quality assessment, confidence reassurance, vector trimming and vector\n removal. The primary advantage of Lucy over other similar utilities is\n that it is a fully integrated, stand alone program.\n .\n Lucy was designed and written at The Institute for Genomic Research\n (TIGR, now the J. Craig Venter Institute), and it has been used here for\n several years to clean sequence data from automated DNA sequencers prior\n to sequence assembly and other downstream uses. The quality trimming\n portion of lucy makes use of phred quality scores, such as those produced\n by many automated sequencers based on the Sanger sequencing method. As\n such, lucy’s quality trimming may not be appropriate for sequence\n data produced by some of the new “next-generation” sequencers.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 7 / 14","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"lucy","OMICagents":"OMICS_14823","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"mach-haplotyper","distribution":"prospective","release":"vcs","component":"non-free","version":"1.0.18","source":"mach-haplotyper","homepage":"http://www.sph.umich.edu/csg/abecasis/MACH/","description":"Markov Chain based SNP haplotyper","long_description":" Recent advancements in chip-based DNA genotyping allow to infer DNA\n variants that are not part of the chip but known to be associated\n with a combination of SNPs that are measured.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1002/gepi.20533","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"macs","distribution":"debian","release":"sid","component":"main","version":"2.1.2.1","source":"macs","homepage":"https://github.com/taoliu/MACS/","description":"Model-based Analysis of ChIP-Seq on short reads sequencers","long_description":" MACS empirically models the length of the sequenced ChIP fragments, which\n tends to be shorter than sonication or library construction size estimates,\n and uses it to improve the spatial resolution of predicted binding sites.\n MACS also uses a dynamic Poisson distribution to effectively capture local\n biases in the genome sequence, allowing for more sensitive and robust\n prediction. MACS compares favorably to existing ChIP-Seq peak-finding\n algorithms, is publicly available open source, and can be used for ChIP-Seq\n with or without control samples.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"14 / 3 / 121","doi":"10.1186/gb-2008-9-9-r137","topics":null,"edam_scopes":null,"bio.agents":"macs","OMICagents":"OMICS_00446","SEQwiki":null,"SciCrunch":{"source":"macs","name":"SciCrunch","entry":"SCR_013291"},"RRID":null},{"package":"macsyfinder","distribution":"debian","release":"sid","component":"main","version":"1.0.5","source":"macsyfinder","homepage":"https://github.com/gem-pasteur/macsyfinder","description":"detection of macromolecular systems in protein datasets","long_description":" MacSyFinder is a program to model and detect macromolecular systems,\n genetic pathways... in protein datasets. In prokaryotes, these systems\n have often evolutionarily conserved properties: they are made of conserved\n components, and are encoded in compact loci (conserved genetic architecture).\n The user models these systems with MacSyFinder to reflect these conserved\n features, and to allow their efficient detection\n .\n This package presents the Open Source Java API to biological databases\n and a series of mostly sequence-based algorithms.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"22 / 1 / 64","doi":"10.1371/journal.pone.0110726","topics":null,"edam_scopes":null,"bio.agents":"macsyfinder","OMICagents":"OMICS_20116","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"maffilter","distribution":"debian","release":"sid","component":"main","version":"1.3.1","source":"maffilter","homepage":"https://jydu.github.io/maffilter/","description":"process genome alignment in the Multiple Alignment Format","long_description":" MafFilter applies a series of \"filters\" to a MAF file, in order to\n clean it, extract data and computer statistics while keeping track of\n the associated meta-data such as genome coordinates and quality scores.\n .\n  * It can process the alignment to remove low-quality / ambiguous /\n    masked regions.\n  * It can export data into a single or multiple alignment file in\n    format such as Fasta or Clustal.\n  * It can read annotation data in GFF or GTF format, and extract the\n    corresponding alignment.\n  * It can perform sliding windows calculations.\n  * It can reconstruct phylogeny/genealogy along the genome alignment.\n  * It can compute population genetics statistics, such as site\n    frequency spectrum, number of fixed/polymorphic sites, etc.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 3 / 63","doi":"10.1186/1471-2164-15-53","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_06743","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"mafft","distribution":"debian","release":"sid","component":"main","version":"7.407","source":"mafft","homepage":"http://mafft.cbrc.jp/alignment/software/","description":"Multiple alignment program for amino acid or nucleotide sequences","long_description":" MAFFT is a multiple sequence alignment program which offers three\n accuracy-oriented methods:\n  * L-INS-i (probably most accurate; recommended for <200 sequences;\n    iterative refinement method incorporating local pairwise alignment\n    information),\n  * G-INS-i (suitable for sequences of similar lengths; recommended for\n    <200 sequences; iterative refinement method incorporating global\n    pairwise alignment information),\n  * E-INS-i (suitable for sequences containing large unalignable regions;\n    recommended for <200 sequences),\n and five speed-oriented methods:\n  * FFT-NS-i (iterative refinement method; two cycles only),\n  * FFT-NS-i (iterative refinement method; max. 1000 iterations),\n  * FFT-NS-2 (fast; progressive method),\n  * FFT-NS-1 (very fast; recommended for >2000 sequences; progressive\n    method with a rough guide tree),\n  * NW-NS-PartTree-1 (recommended for ∼50,000 sequences; progressive\n    method with the PartTree algorithm).\n","interface":["commandline"],"biology":["format:aln","nuceleic-acids","peptidic"],"fields":["biology","biology:bioinformatics"],"use":["comparing"],"popcon":"32 / 5 / 409","doi":"10.1093/bib/bbn013","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_00979","SEQwiki":null,"SciCrunch":{"source":"mafft","name":"SciCrunch","entry":"SCR_011811"},"RRID":null},{"package":"mage2tab","distribution":"prospective","release":"vcs","component":"main","version":"0.9","source":"mage2tab","homepage":"http://sourceforge.net/projects/tab2mage/","description":"MAGE-MLv1 converter and visualiser","long_description":" This agent-kit is part of MR_T, a framework for import or export various of\n MAGE (MicroArray Gene Expression) documents (MAGE-MLv1, MAGE-TAB, SOFT,\n MINiML) from or into databases like GUS (the Genomics Unified Schema,\n www.gusdb.org). \n .\n This package provides the following programs:\n  mage2tab     — MAGE-MLv1 to MAGE-TAB converter\n  mage2graph   — GraphViz-based mage data visualisation agent\n  mage-checker — Validation agent","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"malt","distribution":"prospective","release":"vcs","component":"main","version":"0.0+git20180707.42b5cfd","source":"malt","homepage":"https://github.com/danielhuson/malt","description":"MEGAN alignment agent","long_description":" MALT, an acronym for MEGAN alignment agent, is a sequence alignment and\n analysis agent designed for processing high-throughput sequencing data,\n especially in the context of metagenomics. It is an extension of MEGAN6,\n the MEGenome Analyzer and is designed to provide the input for MEGAN6,\n but can also be used independently of MEGAN6.\n .\n The core of the program is a sequence alignment engine that aligns DNA\n or protein sequences to a DNA or protein reference database in either\n BLASTN (DNA queries and DNA references), BLASTX (DNA queries and protein\n references) or BLASTP (protein queries and protein references) mode. The\n engine uses a banded-alignment algorithm with ane gap scores and BLOSUM\n substitution matrices (in the case of protein alignments). The program\n can compute both local alignments (Smith-Waterman) or semi-global\n alignments (in which reads are aligned end-to-end into reference\n sequences), the latter being more appropriate for aligning metagenomic\n reads to references.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1101/050559","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_18003","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"manta","distribution":"prospective","release":"vcs","component":"main","version":"1.4.0","source":"manta","homepage":"https://github.com/Illumina/manta","description":"structural variant and indel caller for mapped sequencing data","long_description":" Manta calls structural variants (SVs) and indels from mapped paired-end\n sequencing reads. It is optimized for analysis of germline variation in\n small sets of individuals and somatic variation in tumor/normal sample\n pairs. Manta discovers, assembles and scores large-scale SVs, medium-\n sized indels and large insertions within a single efficient workflow.\n The method is designed for rapid analysis on standard compute hardware:\n NA12878 at 50x genomic coverage is analyzed in less than 20 minutes on a\n 20 core server, and most WGS tumor/normal analyses can be completed\n within 2 hours. Manta combines paired and split-read evidence during SV\n discovery and scoring to improve accuracy, but does not require split-\n reads or successful breakpoint assemblies to report a variant in cases\n where there is strong evidence otherwise. It provides scoring models for\n germline variants in small sets of diploid samples and somatic variants\n in matched tumor/normal sample pairs. There is experimental support for\n analysis of unmatched tumor samples as well. Manta accepts input read\n mappings from BAM or CRAM files and reports all SV and indel inferences\n in VCF 4.1 format.","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 1","doi":"10.1093/bioinformatics/btv710","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_09180","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"mapdamage","distribution":"debian","release":"sid","component":"main","version":"2.0.9","source":"mapdamage","homepage":"https://ginolhac.github.io/mapDamage/","description":"tracking and quantifying damage patterns in ancient DNA sequences","long_description":" MapDamage is a computational framework written in Python and R, which\n tracks and quantifies DNA damage patterns among ancient DNA sequencing\n reads generated by Next-Generation Sequencing platforms.\n .\n MapDamage is developed at the Centre for GeoGenetics by the\n Orlando Group.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"21 / 0 / 54","doi":"10.1093/bioinformatics/btt193","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_02099","SEQwiki":null,"SciCrunch":{"source":"mapdamage","name":"SciCrunch","entry":"SCR_001240"},"RRID":null},{"package":"mapsembler2","distribution":"debian","release":"sid","component":"main","version":"2.2.4","source":"mapsembler2","homepage":"http://colibread.inria.fr/mapsembler2/","description":"bioinformatics targeted assembly software","long_description":" Mapsembler2 is a targeted assembly software.\n It takes as input a set of NGS raw reads (fasta or fastq, gzipped or not)\n and a set of input sequences (starters).\n .\n It first determines if each starter is read-coherent, e.g. whether reads\n confirm the presence of each starter in the original sequence.\n Then for each read-coherent starter, Mapsembler2 outputs its sequence\n neighborhood as a linear sequence or as a graph, depending on the user choice.\n .\n Mapsembler2 may be used for (not limited to):\n  - Validate an assembled sequence (input as starter), e.g. from a de\n    Bruijn graph assembly where read-coherence was not enforced.\n  - Checks if a gene (input as starter) has an homolog in a set of reads\n  - Checks if a known enzyme is present in a metagenomic NGS read set.\n  - Enrich unmappable reads by extending them, possibly making them mappable\n  - Checks what happens at the extremities of a contig\n  - Remove contaminants or symbiont reads from a read set\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 4 / 104","doi":"10.1186/1471-2105-13-48","topics":null,"edam_scopes":null,"bio.agents":"mapsembler","OMICagents":"OMICS_18310","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"maq","distribution":"debian","release":"sid","component":"main","version":"0.7.1","source":"maq","homepage":"http://maq.sourceforge.net/","description":"maps short fixed-length polymorphic DNA sequence reads to reference sequences","long_description":" Maq (short for Mapping and Assembly with Quality) builds mapping assemblies\n from short reads generated by the next-generation sequencing machines. It was\n particularly designed for Illumina-Solexa 1G Genetic Analyzer, and has a\n preliminary functionality to handle ABI SOLiD data. Maq is previously known as\n mapass2.\n .\n Developmemt of Maq stopped in 2008. Its successors are BWA and SAMagents.\n","interface":["commandline"],"biology":["nuceleic-acids"],"fields":["biology","biology:bioinformatics"],"use":["TODO","analysing","comparing","searching"],"popcon":"17 / 5 / 348","doi":"10.1101/gr.078212.108","topics":null,"edam_scopes":null,"bio.agents":"MAQ","OMICagents":"OMICS_00668","SEQwiki":null,"SciCrunch":{"source":"maq","name":"SciCrunch","entry":"SCR_005485"},"RRID":null},{"package":"maqview","distribution":"debian","release":"sid","component":"main","version":"0.2.5","source":"maqview","homepage":"http://maq.sourceforge.net/maqview.shtml","description":"graphical read alignment viewer for short gene sequences","long_description":" Maqview is graphical read alignment viewer. It is specifically designed\n for the Maq alignment file and allows you to see the mismatches, base\n qualities and mapping qualities. Maqview is nothing fancy as Consed or\n GAP, but just a simple viewer for you to see what happens in a\n particular region.\n .\n In comparison to tgap-maq, the text-based read alignment viewer written\n by James Bonfield, Maqview is faster and takes up much less memory and\n disk space in indexing. This is possibly because tgap aims to be a\n general-purpose viewer but Maqview fully makes use of the fact that a\n Maq alignment file has already been sorted. Maqview is also efficient in\n viewing and provides a command-line agent to quickly retrieve any region\n in an Maq alignment file.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 3 / 87","doi":"10.1101/gr.078212.108","topics":null,"edam_scopes":null,"bio.agents":"Maqview","OMICagents":"OMICS_00889","SEQwiki":null,"SciCrunch":{"source":"maqview","name":"SciCrunch","entry":"SCR_005632"},"RRID":null},{"package":"martj","distribution":"prospective","release":"vcs","component":"main","version":"0.9","source":"martj","homepage":"http://www.biomart.org/","description":"distributed data integration system for biological data","long_description":" BioMart is a simple, distributed data integration system with powerful\n query capabilities. The BioMart data model has been applied\n to the following data sources: UniProt Proteomes, Macromolecular\n Structure Database (MSD), Ensembl, Vega, and dbSNP.\n .\n It has been designed to provide researchers with an easy and interactive\n access to both the wealth of data available on the Internet and for\n in house data integration. BioMart is a successor to the generic\n query system originally developed for the Ensembl genome database\n (EnsMart). Building on its success, BioMart, has now been applied to\n other biological databases.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"mash","distribution":"debian","release":"sid","component":"main","version":"2.1","source":"mash","homepage":"https://mash.readthedocs.io","description":"fast genome and metagenome distance estimation using MinHash","long_description":" Mash uses MinHash locality-sensitive hashing to reduce large biosequences to\n a representative sketch and rapidly estimate pairwise distances between\n genomes or metagenomes. Mash sketch databases effectively delineate known\n species boundaries, allow construction of approximate phylogenies, and can be\n searched in seconds using assembled genomes or raw sequencing runs from\n Illumina, Pacific Biosciences, and Oxford Nanopore.\n For metagenomics, Mash scales to thousands of samples and can replicate Human\n Microbiome Project and Global Ocean Survey results in a fraction of the time.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 14 / 59","doi":"10.1186/s13059-016-0997-x","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_10468","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"maude","distribution":"debian","release":"sid","component":"main","version":"2.7","source":"maude","homepage":"http://maude.cs.uiuc.edu","description":"high-performance logical framework","long_description":" Maude is a high-performance reflective language and system supporting\n both equational and rewriting logic specification and programming for\n a wide range of applications. Maude has been influenced in important\n ways by the OBJ3 language, which can be regarded as an equational\n logic sublanguage. Besides supporting equational specification and\n programming, Maude also supports rewriting logic computation.\n .\n Rewriting logic is a logic of concurrent change that can naturally\n deal with state and with concurrent computations. It has good\n properties as a general semantic framework for giving executable\n semantics to a wide range of languages and models of concurrency. In\n particular, it supports very well concurrent object-oriented\n computation. The same reasons making rewriting logic a good semantic\n framework make it also a good logical framework, that is, a metalogic\n in which many other logics can be naturally represented and executed.\n .\n Maude supports in a systematic and efficient way logical\n reflection. This makes Maude remarkably extensible and powerful,\n supports an extensible algebra of module composition operations, and\n allows many advanced metaprogramming and metalanguage\n applications. Indeed, some of the most interesting applications of\n Maude are metalanguage applications, in which Maude is used to create\n executable environments for different logics, theorem provers,\n languages, and models of computation.\n .\n Maude is of interest to the biomedical community for modeling and\n analysis of biological systems.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 3 / 53","doi":"10.1145/272991.272995","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"mauve-aligner","distribution":"debian","release":"sid","component":"main","version":"2.4.0+4736","source":"mauve-aligner","homepage":"http://darlinglab.org/mauve/","description":"multiple genome alignment","long_description":" Mauve is a system for efficiently constructing multiple genome alignments\n in the presence of large-scale evolutionary events such as rearrangement\n and inversion. Multiple genome alignment provides a basis for research\n into comparative genomics and the study of evolutionary dynamics.  Aligning\n whole genomes is a fundamentally different problem than aligning short\n sequences.\n .\n Mauve has been developed with the idea that a multiple genome aligner\n should require only modest computational resources. It employs algorithmic\n techniques that scale well in the amount of sequence being aligned. For\n example, a pair of Y. pestis genomes can be aligned in under a minute,\n while a group of 9 divergent Enterobacterial genomes can be aligned in\n a few hours.\n .\n Mauve computes and interactively visualizes genome sequence comparisons.\n Using FastA or GenBank sequence data, Mauve constructs multiple genome\n alignments that identify large-scale rearrangement, gene gain, gene loss,\n indels, and nucleotide substutition.\n .\n Mauve is developed at the University of Wisconsin.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 3 / 64","doi":"10.1101/gr.2289704","topics":null,"edam_scopes":null,"bio.agents":"mauve","OMICagents":"OMICS_00940","SEQwiki":null,"SciCrunch":{"source":"mauve-aligner","name":"SciCrunch","entry":"SCR_012852"},"RRID":null},{"package":"mcl","distribution":"debian","release":"sid","component":"main","version":"14-137+ds","source":"mcl","homepage":"http://micans.org/mcl/","description":"Markov Cluster algorithm","long_description":" The MCL package is an implementation of the MCL algorithm, and offers\n utilities for manipulating sparse matrices (the essential data\n structure in the MCL algorithm) and conducting cluster experiments.\n .\n MCL is currently being used in sciences like biology (protein family\n detection, genomics), computer science (node clustering in\n Peer-to-Peer networks), and linguistics (text analysis).\n","interface":null,"biology":null,"fields":["mathematics"],"use":null,"popcon":"27 / 16 / 373","doi":"10.1007/978-1-61779-361-5_15","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"melting","distribution":"debian","release":"sid","component":"main","version":"5.2.0","source":"melting","homepage":"http://www.ebi.ac.uk/compneur-srv/melting/","description":"compute the melting temperature of nucleic acid duplex","long_description":" This program computes, for a nucleic acid duplex, the enthalpy, the\n entropy and the melting temperature of the helix-coil\n transitions. Three types of hybridisation are possible: DNA/DNA,\n DNA/RNA, and RNA/RNA. The program first computes the hybridisation\n enthalpy and entropy from the elementary parameters of each Crick's\n pair by the nearest-neighbor method. Then the melting temperature is\n computed. The set of thermodynamic parameters can be easily changed,\n for instance following an experimental breakthrough.\n","interface":["commandline"],"biology":["nuceleic-acids"],"fields":["biology","biology:molecular"],"use":["analysing"],"popcon":"8 / 3 / 100","doi":"10.1093/bioinformatics/17.12.1226","topics":null,"edam_scopes":null,"bio.agents":"Melting","OMICagents":"OMICS_02350","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"glam2","distribution":"prospective","release":"vcs","component":"non-free","version":"4.12.0","source":"meme","homepage":"http://meme-suite.org/agents/meme","description":"gapped protein motifs from unaligned sequences","long_description":" GLAM2 is a software package for finding motifs in sequences, typically\n amino-acid or nucleotide sequences. A motif is a re-occurring sequence\n pattern: typical examples are the TATA box and the CAAX prenylation motif. The\n main innovation of GLAM2 is that it allows insertions and deletions in motifs.\n .\n This package includes programs for discovering motifs shared by a set of\n sequences and finding matches to these motifs in a sequence database, as well\n as utilities for converting glam2 motifs to standard alignment formats,\n masking glam2 motifs out of sequences so that weaker motifs can be found, and\n removing highly similar members of a set of sequences.\n .\n In this binary package, the fast Fourier algorithm (FFT) was enabled for the\n glam2 program.","interface":["commandline"],"biology":null,"fields":["biology:bioinformatics","biology"],"use":["searching","analysing","comparing"],"popcon":"9 / 3 / 93","doi":"10.1093/nar/gkl198","topics":null,"edam_scopes":null,"bio.agents":"MEME","OMICagents":"OMICS_08103","SEQwiki":null,"SciCrunch":{"source":"meme","name":"SciCrunch","entry":"SCR_001783"},"RRID":null},{"package":"meme","distribution":"prospective","release":"vcs","component":"non-free","version":"4.12.0","source":"meme","homepage":"http://meme-suite.org/agents/meme","description":"search for common motifs in DNA or protein sequences","long_description":" MEME (Multiple EM for Motif Elicitation) is a agent for discovering\n motifs in a group of related DNA or protein sequences.  A motif is a\n sequence pattern that occurs repeatedly in a group of related protein or\n DNA sequences. MEME represents motifs as position-dependent\n letter-probability matrices which describe the probability of each\n possible letter at each position in the pattern. Individual MEME motifs\n do not contain gaps. Patterns with variable-length gaps are split by\n MEME into two or more separate motifs.\n .\n MEME takes as input a group of DNA or protein sequences (the training set)\n and outputs as many motifs as requested. MEME uses statistical modeling\n techniques to automatically choose the best width, number of occurrences,\n and description for each motif.","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 0 / 2","doi":"10.1093/nar/gkl198","topics":null,"edam_scopes":null,"bio.agents":"MEME","OMICagents":"OMICS_08103","SEQwiki":null,"SciCrunch":{"source":"meme","name":"SciCrunch","entry":"SCR_001783"},"RRID":null},{"package":"mesquite","distribution":"prospective","release":"vcs","component":"main","version":"3.04","source":"mesquite","homepage":"https://github.com/MesquiteProject/MesquiteCore","description":"modular system for evolutionary analysis","long_description":" Mesquite is modular, extendible software for evolutionary biology,\n designed to help biologists organize and analyze comparative data about\n organisms. Its emphasis is on phylogenetic analysis, but some of its\n modules concern population genetics, while others do non-phylogenetic\n multivariate analysis. Because it is modular, the analyses available\n depend on the modules installed.\n .\n Mesquite also has many features for managing and processing data,\n including processing of chromatograms, sequence alignment, editing of\n morphometric data, and others.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"metabit","distribution":"prospective","release":"vcs","component":"main","version":"0.0+20170220","source":"metabit","homepage":"https://bitbucket.org/Glouvel/metabit/wiki/","description":"analysing microbial profiles from high-throughput sequencing shotgun data","long_description":" MetaBIT is an integrative and automated metagenomic pipeline for\n analysing microbial profiles from high-throughput sequencing\n shotgun data.\n .\n The metaBIT pipeline proposes agents for visualising microbial profiles\n (barplots, heatmaps) and performing a range of statistical analyses\n (diversity indices, hierarchical clustering and principal coordinate\n analysis). It uses as input fastq files containing trimmed reads from\n shotgun high through-put sequencing.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1111/1755-0998.12546","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"metaphlan2","distribution":"debian","release":"sid","component":"main","version":"2.7.8","source":"metaphlan2","homepage":"https://bitbucket.org/biobakery/metaphlan2","description":"Metagenomic Phylogenetic Analysis","long_description":" MetaPhlAn is a computational agent for profiling the composition of\n microbial communities (Bacteria, Archaea, Eukaryotes and Viruses) from\n metagenomic shotgun sequencing data with species level resolution. From\n version 2.0, MetaPhlAn is also able to identify specific strains (in the\n not-so-frequent cases in which the sample contains a previously\n sequenced strains) and to track strains across samples for all species.\n .\n MetaPhlAn 2.0 relies on ~1M unique clade-specific marker genes (the\n marker information file can be found at\n usr/share/metaphlan2/utils/markers_info.txt.bz2) identified from\n ~17,000 reference genomes (~13,500 bacterial and archaeal, ~3,500 viral,\n and ~110 eukaryotic), allowing:\n .\n  * unambiguous taxonomic assignments;\n  * accurate estimation of organismal relative abundance;\n  * species-level resolution for bacteria, archaea, eukaryotes and\n    viruses;\n  * strain identification and tracking\n  * orders of magnitude speedups compared to existing methods.\n  * metagenomic strain-level population genomics\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 3 / 36","doi":"10.1038/nmeth.3589","topics":null,"edam_scopes":null,"bio.agents":"SCR_004915","OMICagents":"OMICS_02286","SEQwiki":null,"SciCrunch":{"source":"metaphlan2","name":"SciCrunch","entry":"MetaPhlAn"},"RRID":null},{"package":"metastudent","distribution":"debian","release":"sid","component":"main","version":"2.0.1","source":"metastudent","homepage":"https://rostlab.org/owiki/index.php/Metastudent","description":"predictor of Gene Ontology terms from protein sequence","long_description":" Often, only the sequence of a protein is known, but\n not its functions. Metastudent will try to predict\n missing functional annotations through homology searches (BLAST).\n .\n All predicted functions correspond to Gene Ontology (GO)\n terms from the Molecular Function (MFO), the Biological Process\n (BPO) and the Cellular Component Ontology (CCO) and are associated\n with a reliability score.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"28 / 0 / 73","doi":"10.1186/1471-2105-14-S3-S7","topics":null,"edam_scopes":null,"bio.agents":"metastudent","OMICagents":"OMICS_20187","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"metastudent-data","distribution":"debian","release":"sid","component":"main","version":"2.0.1","source":"metastudent-data","homepage":"https://rostlab.org/owiki/index.php/Metastudent","description":"predictor of Gene Ontology terms from protein sequence - data files","long_description":" Often, only the sequence of a protein is known, but\n not its functions. Metastudent will try to predict\n missing functional annotations through homology searches (BLAST).\n .\n All predicted functions correspond to Gene Ontology (GO)\n terms from the Molecular Function Ontology (MFO) and the Biological Process\n Ontology (BPO) and are associated with a reliability score.\n .\n This package contains data files for metastudent.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 113","doi":"10.1186/1471-2105-14-S3-S7","topics":null,"edam_scopes":null,"bio.agents":"metastudent","OMICagents":"OMICS_20187","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"metastudent-data-2","distribution":"debian","release":"sid","component":"main","version":"1.0.0","source":"metastudent-data-2","homepage":"https://rostlab.org/owiki/index.php/Metastudent","description":"predictor of Gene Ontology terms from protein sequence - data #2","long_description":" Often, only the sequence of a protein is known, but\n not its functions. Metastudent will try to predict\n missing functional annotations through homology searches (BLAST).\n .\n All predicted functions correspond to Gene Ontology (GO)\n terms from the Molecular Function Ontology (MFO) and the Biological Process\n Ontology (BPO) and are associated with a reliability score.\n .\n This package contains additional data files for metastudent.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 50","doi":"10.1186/1471-2105-14-S3-S7","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"mglagents-cadd","distribution":"debian","release":"sid","component":"non-free","version":"1.5.7","source":"mglagents-cadd","homepage":"http://mglagents.scripps.edu/","description":"Computer Aided Drug Discovery (CADD) Pipeline","long_description":" This package is part of the mglagents set of Python libraries which\n provide an infrastructure for the analysis of protein structures and\n their docking of chemical compounds.\n .\n The Computer Aided Drug Discovery (CADD) Pipeline is a workflow\n environment designed to support molecular dyanmics simulations\n and virtual screening experiments for in silico drug discovery,\n with a special focus on supporting the use of the Relaxed\n Complex Scheme. It includes web based access to applications\n such as NAMD, AutoDock, PDB2PQR, APBS, MGLToos and couples them\n in a flexible and scalable fashion through cloud computing.\n It is developed as a standalone application, using Vision\n (https://www.nbcr.net/pub/wiki/index.php?title=MGLAgents#Vision) as\n the backend engine for visual programming and workflow execution.\n The scientific applications are made accessible through CADD using\n Opal Web services (https://www.nbcr.net/pub/wiki/index.php?title=Opal)\n for scalable and distributed computation.\n .\n The workflow components of the CADD pipeline are currently released\n as Vision networks packaged for specific processes in a modular\n fashion. These modules may be coupled at ease for more complex\n processes. In the future, they may also be accessible from workflow\n repositories such as MyExperiment.org, and from AutoDockAgents.  The Opal\n services used in the CADD workflow may be accessed using programmatic\n access, the Opal Server Dashboard or other workflow clients such as\n Kepler, VisTrails or Taverna through Opal plugins available at Opal\n Sourceforge website (http://opal.nbcr.net).\n .\n Features\n .\n  * Automatic launching of NAMD simulation on TeraGrid and NBCR resources,\n    including experimental support for migration of simulation between\n    resources.\n  * Selection of representative snapshots/conformations from MD simulations\n    using clustering agents such as QR factorization from VMD and Ptraj from\n    Amber.\n  * Support of Virtual Screening using AutoDock, AutoDock Vina\n  * Support of Relaxed Complex Scheme based Virtual Screening and Rescoring\n  * Visualization and analysis of Virtual Screening hits\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 0 / 8","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_05509","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"mglagents-networkeditor","distribution":"debian","release":"sid","component":"non-free","version":"1.5.7","source":"mglagents-networkeditor","homepage":"http://mglagents.scripps.edu/","description":"Python GUI library for the editing of networks","long_description":" This package is part of the mglagents set of Python libraries which\n provide an infrastructure for the analysis of protein structures and\n their docking of chemical compounds.\n .\n It provides a graphics user interface to edit networks and is used\n by the Vision packages that formulates workflows.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 0 / 16","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"mglagents-pmv","distribution":"debian","release":"sid","component":"non-free","version":"1.5.7","source":"mglagents-pmv","homepage":"http://mglagents.scripps.edu/","description":"Python-based Molecular Viewer","long_description":" This package is part of the mglagents set of Python libraries which\n provide an infrastructure for the analysis of protein structures and\n their docking of chemical compounds.\n .\n It provides a complete molecular viewer of protein structures and their\n ligands.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 0 / 12","doi":"10.1016/j.str.2005.01.009","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_05070","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"mglagents-pybabel","distribution":"debian","release":"sid","component":"non-free","version":"1.5.7","source":"mglagents-pybabel","homepage":"http://mglagents.scripps.edu/","description":"molecular structure file access and interpretation","long_description":" This package is part of the mglagents set of Python libraries which\n provide an infrastructure for the analysis of protein structures and\n their docking of chemical compounds.\n .\n The library reimplements routines of Babel v1.6 from Pat Walters and Math\n Stahl in Python for reading and interpreting molecular structures.  It is\n needed by mglagents-autodockagents at runtime.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 2 / 24","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"mglagents-vision","distribution":"debian","release":"sid","component":"non-free","version":"1.5.7","source":"mglagents-vision","homepage":"http://mglagents.scripps.edu/","description":"Python-based Visual Programming Environment","long_description":" This package is part of the mglagents set of Python libraries which\n provide an infrastructure for the analysis of protein structures and\n their docking of chemical compounds.\n .\n Vision is a visual-programming environment in which a user can\n interactively build networks describing novel combinations of\n computational methods, and yielding new visualizations of their data\n without actually writing code.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 0 / 12","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"mhap","distribution":"debian","release":"sid","component":"main","version":"2.1.3","source":"mhap","homepage":"http://mhap.readthedocs.org/en/stable/","description":"locality-sensitive hashing to detect long-read overlaps","long_description":" The MinHash Alignment Process (MHAP--pronounced MAP) is a\n reference implementation of a probabilistic sequence overlapping\n algorithm. Designed to efficiently detect all overlaps between noisy\n long-read sequence data. It efficiently estimates Jaccard similarity\n by compressing sequences to their representative fingerprints\n composed on min-mers (minimum k-mer).\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 3 / 61","doi":"10.1038/nbt.3238","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_13515","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"microbegps","distribution":"debian","release":"sid","component":"main","version":"1.0.0","source":"microbegps","homepage":"http://sourceforge.net/projects/microbegps/","description":"explorative taxonomic profiling agent for metagenomic data","long_description":" MicrobeGPS is a bioinformatics agent for the analysis of metagenomic\n sequencing data. The goal is to profile the composition of metagenomic\n communities as accurately as possible and present the results to the\n user in a convenient manner. One main focus is reliability: the agent\n calculates quality metrics for the estimated candidates and allows the\n user to identify false candidates easily.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 2 / 59","doi":"10.1371/journal.pone.0117711","topics":null,"edam_scopes":null,"bio.agents":"MicrobeGPS","OMICagents":"OMICS_17085","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"chimeraslayer","distribution":"debian","release":"sid","component":"main","version":"20101212","source":"microbiomeutil","homepage":"http://microbiomeutil.sourceforge.net/","description":"detects likely chimeras in PCR amplified DNA","long_description":" ChimeraSlayer is a chimeric sequence detection utility, compatible with\n near-full length Sanger sequences and shorter 454-FLX sequences (~500bp).\n .\n Chimera Slayer involves the following series of steps that operate to\n flag chimeric 16S rRNA sequences:\n .\n  1. the ends of a query sequence are searched against an included\n     database of reference chimera-free 16S sequences to identify potential\n     parents of a chimera\n  2. candidate parents of a chimera are selected as those that form a\n     branched best scoring alignment to the NAST-formatted query sequence\n  3. the NAST alignment of the query sequence is improved in a\n     ‘chimera-aware’ profile-based NAST realignment to the selected\n     reference parent sequences\n  4. an evolutionary framework is used to flag query sequences found to\n     exhibit greater sequence homology to an in silico chimera formed\n     between any two of the selected reference parent sequences.\n .\n To run Chimera Slayer, you need NAST-formatted sequences generated by\n the nast-ier utility.\n .\n ChimeraSlayer is part of the microbiomeutil suite.\n","interface":null,"biology":["format:aln","nuceleic-acids"],"fields":["biology","biology:molecular"],"use":null,"popcon":"9 / 3 / 114","doi":"10.1101/gr.112730.110","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_16932","SEQwiki":null,"SciCrunch":{"source":"microbiomeutil","name":"SciCrunch","entry":"SCR_014611"},"RRID":null},{"package":"microbiomeutil","distribution":"debian","release":"sid","component":"main","version":"20101212","source":"microbiomeutil","homepage":"http://microbiomeutil.sourceforge.net/","description":"Microbiome Analysis Utilities","long_description":" The microbiomeutil package comes with the following utilities:\n  * ChimeraSlayer:  ChimeraSlayer for chimera detection.\n  * NAST-iEr:       NAST-based alignment agent.\n  * WigeoN:         A reimplementation of the Pintail 16S anomaly\n                    detection utility\n  * RESOURCES:      Reference 16S sequences and NAST-alignments that\n                    the agents above leverage.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 3 / 106","doi":"10.1101/gr.112730.110","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_16932","SEQwiki":null,"SciCrunch":{"source":"microbiomeutil","name":"SciCrunch","entry":"SCR_014611"},"RRID":null},{"package":"nast-ier","distribution":"debian","release":"sid","component":"main","version":"20101212","source":"microbiomeutil","homepage":"http://microbiomeutil.sourceforge.net/","description":"NAST-based DNA alignment agent","long_description":" The NAST-iEr alignment utility aligns a single raw nucleotide sequence\n against one or more NAST formatted sequences.\n .\n The alignment algorithm involves global dynamic programming profile\n alignment to fixed (NAST-formatted) multiply aligned template sequences\n without any end-gap penalty.\n .\n NAST-iEr is part of the microbiomeutil suite.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"10 / 3 / 118","doi":"10.1101/gr.112730.110","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_16932","SEQwiki":null,"SciCrunch":{"source":"microbiomeutil","name":"SciCrunch","entry":"SCR_014611"},"RRID":null},{"package":"wigeon","distribution":"debian","release":"sid","component":"main","version":"20101212","source":"microbiomeutil","homepage":"http://microbiomeutil.sourceforge.net/","description":"reimplementation of the Pintail 16S DNA anomaly detection utility","long_description":" WigeoN examines the sequence conservation between a query and a trusted\n reference sequence, both in NAST alignment format. Based on the sequence\n identity between the query and the reference sequence, there is an\n expected amount of variation among the alignment. If the observed\n variation is greater than the 95% quantile of the distribution of\n variation observed between non-anomalous sequences, then it is flagged\n as an anomaly.\n .\n WigeoN is a flexible command-line based reimplementation of the Pintail\n algorithm Appl Environ Microbiol. 2005 Dec;7112:7724-36.\n .\n WigeoN is useful for flagging chimeras and anomalies only in near\n full-length 16S rRNA sequences. WigeoN lacks sensitivity with sequences\n less than 1000 bp.\n .\n To run WigeoN, you need NAST-formatted sequences generated by the\n nast-ier utility.\n .\n WigeoN is  part of the microbiomeutil suite.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 3 / 111","doi":"10.1101/gr.112730.110","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_16932","SEQwiki":null,"SciCrunch":{"source":"microbiomeutil","name":"SciCrunch","entry":"SCR_014611"},"RRID":null},{"package":"libmilib-java","distribution":"debian","release":"sid","component":"main","version":"1.10","source":"milib","homepage":"https://milaboratory.com/","description":"library for Next Generation Sequencing (NGS) data processing","long_description":" A helping Java package adopted by a range of Open Source agents for the\n analysis of B and T cell repertoires.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 1","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"minia","distribution":"debian","release":"sid","component":"main","version":"3.2.0","source":"minia","homepage":"http://minia.genouest.org/","description":"short-read biological sequence assembler","long_description":" Short-read DNA sequence assembler based on a de Bruijn graph,\n capable of assembling a human genome on a desktop computer in a day.\n .\n The output of Minia is a set of contigs.\n Minia produces results of similar contiguity and accuracy to other\n de Bruijn assemblers (e.g. Velvet).\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 4 / 111","doi":"10.1186/1748-7188-8-22","topics":["Sequence assembly"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Sequence", "formats": ["FASTQ", "FASTA"]}, {"data": "Alignment", "formats": ["TSV"]}], "outputs": [{"data": "Sequence assembly", "formats": ["Sequence assembly format (text)"]}], "function": ["De-novo assembly"]}],"bio.agents":"minia","OMICagents":"OMICS_00022","SEQwiki":null,"SciCrunch":{"source":"minia","name":"SciCrunch","entry":"SCR_004986"},"RRID":null},{"package":"miniasm","distribution":"debian","release":"sid","component":"main","version":"0.3","source":"miniasm","homepage":"https://github.com/lh3/miniasm","description":"ultrafast de novo assembler for long noisy DNA sequencing reads","long_description":" Miniasm is an experimental very fast OLC-based de novo assembler for noisy\n long reads. It takes all-vs-all read self-mappings (typically by minimap)\n as input and outputs an assembly graph in the GFA format. Different from\n mainstream assemblers, miniasm does not have a consensus step. It simply\n concatenates pieces of read sequences to generate the final unitig sequences.\n Thus the per-base error rate is similar to the raw input reads.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 4 / 66","doi":null,"topics":["Sequence assembly"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Sequence", "formats": ["FASTQ", "FASTA"]}, {"data": "Alignment", "formats": ["TSV"]}], "outputs": [{"data": "Sequence assembly", "formats": ["Sequence assembly format (text)"]}], "function": ["De-novo assembly"]}],"bio.agents":null,"OMICagents":"OMICS_11366","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"minimac4","distribution":"debian","release":"sid","component":"main","version":"1.0.0","source":"minimac4","homepage":"https://genome.sph.umich.edu/wiki/Minimac4","description":"Fast Imputation Based on State Space Reduction HMM","long_description":" Minimac4 is a lower memory and more computationally efficient implementation\n of \"minimac2/3\". It is an algorithm for genotypic imputation that works on\n phased genotypes (say from MaCH).\n .\n Minimac4 is designed to handle very large reference panels in a more\n computationally efficient way with no loss of accuracy. This algorithm\n analyzes only the unique sets of haplotypes in small genomic segments, thereby\n saving on time\\-complexity, computational memory but no loss in degree of\n accuracy.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 7 / 15","doi":"10.1038/ng.3656","topics":null,"edam_scopes":null,"bio.agents":"Minimac3","OMICagents":"OMICS_08953","SEQwiki":null,"SciCrunch":{"source":"minimac4","name":"SciCrunch","entry":"SCR_009292"},"RRID":null},{"package":"libminimap-dev","distribution":"debian","release":"sid","component":"main","version":"0.2","source":"minimap","homepage":"https://github.com/lh3/minimap","description":"development headers for libminimap","long_description":" Minimap is an experimental agent to efficiently find multiple approximate\n mapping positions between two sets of long sequences, such as between\n DNA reads and reference genomes, between genomes and between long noisy reads.\n .\n This package contains the C library headers for using minimap in custom agents,\n along with a static library.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 35","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_29235","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"minimap","distribution":"debian","release":"sid","component":"main","version":"0.2","source":"minimap","homepage":"https://github.com/lh3/minimap","description":"agent for approximate mapping of long biosequences such as DNA reads","long_description":" Minimap is an experimental agent to efficiently find multiple approximate\n mapping positions between two sets of long biological sequences, such as\n between DNA reads and reference genomes, between genomes and between long\n noisy reads.\n Minimap does not generate alignments as of now and because of this, it is\n usually tens of times faster than mainstream aligners.\n It does not replace mainstream aligners, but it can be useful when you\n want to quickly identify long approximate matches at moderate divergence among\n a huge collection of sequences. For this task, it is much faster than most\n existing agents.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 4 / 68","doi":null,"topics":["Mapping"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Sequence", "formats": ["FASTA"]}], "outputs": [{"data": "Alignment", "formats": ["TSV"]}], "function": ["Read mapping"]}],"bio.agents":null,"OMICagents":"OMICS_29235","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"minimap2","distribution":"debian","release":"sid","component":"main","version":"2.15","source":"minimap2","homepage":"https://github.com/lh3/minimap2","description":"versatile pairwise aligner for genomic and spliced nucleotide sequences","long_description":" Minimap2 is a versatile sequence alignment program that aligns DNA or\n mRNA sequences against a large reference database. Typical use cases\n include: (1) mapping PacBio or Oxford Nanopore genomic reads to the\n human genome; (2) finding overlaps between long reads with error rate up\n to ~15%; (3) splice-aware alignment of PacBio Iso-Seq or Nanopore cDNA\n or Direct RNA reads against a reference genome; (4) aligning Illumina\n single- or paired-end reads; (5) assembly-to-assembly alignment; (6) full-\n genome alignment between two closely related species with divergence\n below ~15%.\n .\n For ~10kb noisy reads sequences, minimap2 is tens of times faster than\n mainstream long-read mappers such as BLASR, BWA-MEM, NGMLR and GMAP. It\n is more accurate on simulated long reads and produces biologically\n meaningful alignment ready for downstream analyses. For >100bp Illumina\n short reads, minimap2 is three times as fast as BWA-MEM and Bowtie2, and\n as accurate on simulated data. Detailed evaluations are available from\n the minimap2 paper or the preprint.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 7 / 18","doi":"https://doi.org/10.1093/bioinformatics/bty191","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_31658","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"mipe","distribution":"debian","release":"sid","component":"main","version":"1.1","source":"mipe","homepage":"http://mipe.sourceforge.net","description":"Agents to store PCR-derived data","long_description":" MIPE provides a standard format to exchange and/or storage of all\n information associated with PCR experiments using a flat text file. This will:\n  * allow for exchange of PCR data between researchers/laboratories\n  * enable traceability of the data\n  * prevent problems when submitting data to dbSTS or dbSNP\n  * enable the writing of standard scripts to extract data (e.g. a\n    list of PCR primers, SNP positions or haplotypes for different animals)\n .\n Although this agent can be used for data storage, it's primary focus\n should be data exchange. For larger repositories, relational databases\n are more appropriate for storage of these data. The MIPE format could\n then be used as a standard format to import into and/or export from\n these databases.\n","interface":["commandline"],"biology":null,"fields":["biology","biology:bioinformatics","biology:molecular"],"use":["organizing"],"popcon":"7 / 3 / 90","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_02358","SEQwiki":null,"SciCrunch":{"source":"mipe","name":"SciCrunch","entry":"SCR_003065"},"RRID":null},{"package":"mira-assembler","distribution":"debian","release":"sid","component":"main","version":"4.9.6","source":"mira","homepage":"http://chevreux.org/projects_mira.html","description":"Whole Genome Shotgun and EST Sequence Assembler","long_description":" The mira genome fragment assembler is a specialised assembler for\n sequencing projects classified as 'hard' due to high number of similar\n repeats. For expressed sequence tags (ESTs) transcripts, miraEST is\n specialised on reconstructing pristine mRNA transcripts while\n detecting and classifying single nucleotide polymorphisms (SNP)\n occurring in different variations thereof.\n .\n The assembler is routinely used for such various tasks as mutation\n detection in different cell types, similarity analysis of transcripts\n between organisms, and pristine assembly of sequences from various\n sources for oligo design in clinical microarray experiments.\n .\n The package provides the following executables:\n Binaries provided:\n  * mira: for assembly of genome sequences\n  * miramem: estimating memory needed to assemble projects.\n  * mirabait: a \"grep\" like agent to select reads with kmers up to 256 bases.\n  * miraconvert: is a agent to convert, extract and sometimes recalculate all\n    kinds of data related to sequence assembly files.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 2 / 90","doi":"10.1101/gr.1917404","topics":null,"edam_scopes":null,"bio.agents":"MIRA","OMICagents":"OMICS_00023","SEQwiki":null,"SciCrunch":{"source":"mira","name":"SciCrunch","entry":"SCR_010731"},"RRID":null},{"package":"mlv-smile","distribution":"debian","release":"sid","component":"main","version":"1.47","source":"mlv-smile","homepage":"http://www-igm.univ-mlv.fr/~marsan/smile_english.html","description":"Find statistically significant patterns in sequences","long_description":" Smile determines sequence motifs on the basis of a set of DNA, RNA or\n protein sequences.\n  * No hard limit on the number of combinations of motifs to describe\n    subsets of sequences.\n  * The sequence alphabet may be specified.\n  * The use of wildcards is supported.\n  * Better determination of significance of motifs by simulation.\n  * Introduction of a set of sequences with negative controls\n    that should not match automatically determined motifs.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 3 / 88","doi":"10.1089/106652700750050826","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_20188","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python-mmtk","distribution":"debian","release":"jessie","component":"main","version":"2.7.9","source":"mmtk","homepage":"http://dirac.cnrs-orleans.fr/MMTK/","description":"molecular modeling agentkit","long_description":" The Molecular Modeling Agentkit (MMTK) is a library for molecular\n simulation applications. It provides the most common methods in\n molecular simulations (molecular dynamics, energy minimization,\n normal mode analysis) and several force fields used for biomolecules\n (Amber 94, Amber 99, several elastic network models). MMTK also\n serves as a code basis that can be easily extended and modified to\n deal with non-standard situations in molecular simulations.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 0 / 151","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_28982","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"mobyle","distribution":"debian","release":"sid","component":"main","version":"1.5.5","source":"mobyle","homepage":"https://projets.pasteur.fr/projects/mobyle","description":"Web portal that provides web forms for command-line software","long_description":" Mobyle is a framework and web portal specifically aimed at the integration of\n bioinformatics software and databanks. It generates a web interface from an xml\n description for command-line based agents.\n It can submit jobs locally or using DRM systems.\n .\n This package will restart Apache after enabling the ‘rewrite’ and ‘headers’\n modules.\n .\n The Mobyle project is now considered a legacy project and the code, although\n still available, will no longer maintained after december 31st, 2016.\n","interface":["web"],"biology":null,"fields":["biology","biology:bioinformatics"],"use":null,"popcon":"0 / 1 / 3","doi":"10.1093/bioinformatics/btp493","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_05996","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"mobyle-programs","distribution":"debian","release":"sid","component":"main","version":"5.1.2","source":"mobyle-programs","homepage":"https://projets.pasteur.fr/projects/show/mobyle","description":"program descriptions for the mobyle portal","long_description":" Set of programs for the mobyle framework.\n Those programs can be deployed to be used on the portal.\n However those depends on a number of executables that should\n be installed on the server. This set can be used as a starter.\n","interface":null,"biology":null,"fields":["biology:bioinformatics"],"use":null,"popcon":"0 / 1 / 3","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"mobyle-tutorials","distribution":"debian","release":"sid","component":"main","version":"1.5.0","source":"mobyle-tutorials","homepage":"https://projets.pasteur.fr/projects/mobyle/wiki/Download","description":"program tutorials for the mobyle portal","long_description":" Mobyle is a framework and web portal specifically aimed at the integration of\n bioinformatics software and databanks. It generates a web interface from an xml\n description for command-line based agents.\n It can submit jobs locally or using DRM systems.\n .\n This package contains a set of tutorials for the mobyle framework.\n Those tutorials can be deployed to be used on the portal.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 1 / 3","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"modeller","distribution":"prospective","release":"vcs","component":"non-free","version":"9.19","source":"modeller","homepage":"https://salilab.org/modeller/","description":"Protein structure modeling by satisfaction of spatial restraints","long_description":" MODELLER is used for homology or comparative modeling of protein\n three-dimensional structures (1). The user provides an alignment of a\n sequence to be modeled with known related structures and MODELLER automatically\n calculates a model containing all non-hydrogen atoms. MODELLER implements\n comparative protein structure modeling by satisfaction of spatial restraints\n (2, 3), and can perform many additional tasks, including de novo modeling of\n loops in protein structures, optimization of various models of protein\n structure with respect to a flexibly defined objective function, multiple\n alignment of protein sequences and/or structures, clustering, searching of\n sequence databases, comparison of protein structures, etc.","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 1 / 26","doi":"10.1146/annurev.biophys.29.1.291","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"molekel","distribution":"prospective","release":"vcs","component":"main","version":"5.4","source":"molekel","homepage":"http://ugovaretto.github.io/molekel/","description":"Advanced Interactive 3D-Graphics for Molecular Sciences","long_description":" Molekel is an open-source multi-platform molecular visualization program.\n .\n Some of the features are:\n  * Different methods to speed-up rendering of molecules with support\n    for billboards and view-dependent level of detail techniques\n  * Programmable shaders; standard shaders to enhance rendering quality,\n    outline contours and perform sketch-like renderings are provided\n  * Visualization of residues (ribbon or schematic)\n  * Complete control over the generation of molecular surfaces (bounding\n    box and resolution)\n  * Visualization of the following surfaces:\n    - Orbitals\n    - Iso-surface from density matrix\n    - Iso-surface from Gaussian cube grid data\n    - SAS\n    - SES\n    - Van der Waals\n  * Animation of molecular surfaces\n  * Animation of vibrational modes\n  * Export high resolution images for 300+ DPI printing\n  * Export to PostScript and PDF\n  * Export animation\n  * Plane widget to visualize a scalar field: the plane can be freely\n    moved in 3d space and the points on the plane surface will be colored\n    according to the value of the scalar field: a cursor can be moved on\n    the plane surface to show the exact value of the field at a specific\n    point in space.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"mosaik-aligner","distribution":"prospective","release":"vcs","component":"main","version":"2.2.30+20140627","source":"mosaik-aligner","homepage":"https://github.com/wanpinglee/MOSAIK","description":"reference-guided aligner for next-generation sequencing","long_description":" MosaikBuild converts various sequence formats into Mosaik’s native read\n format. MosaikAligner pairwise aligns each read to a specified series of\n reference sequences. MosaikSort resolves paired-end reads and sorts the\n alignments by the reference sequence coordinates. Finally, MosaikText\n converts alignments to different text-based formats.\n .\n At this time, the workflow consists of supplying sequences in FASTA,\n FASTQ, Illumina Bustard & Gerald, or SRF file formats and producing\n results in the BLAT axt, the BAM/SAM, the UCSC Genome Browser bed, or\n the Illumina ELAND formats.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"mothur","distribution":"debian","release":"sid","component":"main","version":"1.41.21","source":"mothur","homepage":"http://www.mothur.org","description":"sequence analysis suite for research on microbiota","long_description":" Mothur seeks to develop a single piece of open-source, expandable\n software to fill the bioinformatics needs of the microbial ecology\n community. It has incorporated the functionality of dotur, sons,\n treeclimber, s-libshuff, unifrac, and much more. In addition to improving\n the flexibility of these algorithms, a number of other features including\n calculators and visualization agents were added.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 10 / 100","doi":"10.1128/AEM.01541-09","topics":["Microbial ecology"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Sequence", "formats": ["FASTQ"]}], "outputs": [{"data": "Report", "formats": ["Text", "SVG", "newick"]}], "function": ["Analysis"]}],"bio.agents":null,"OMICagents":"OMICS_01518","SEQwiki":null,"SciCrunch":{"source":"mothur","name":"SciCrunch","entry":"SCR_011947"},"RRID":null},{"package":"mpsqed","distribution":"prospective","release":"vcs","component":"main","version":"0.9.3","source":"mpsqed","homepage":"http://sourceforge.net/projects/mpsqed/","description":"alignment editor and multiplex pyrosequencing assay designer","long_description":" Molecular-based diagnostic assays are the gold standard for infectious\n diseases today, since they allow a rapid and sensitive identification\n and typing of various pathogens. While PCR can be designed to be\n specific for a certain pathogen, a subsequent sequence analysis is\n frequently required for confirmation or typing. The design of\n appropriate PCR-based assays is a complex task, especially when\n conserved discriminating polymorphisms are rare or if the number of\n types which need to be differentiated is high. One extremely useful but\n underused method for this purpose is the multiplex pyrosequencing\n technique. mPSQed is a program developed at the Robert Koch Institute\n and targeted at facilitating the creation of such assays.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1371/journal.pone.0038140","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"mptp","distribution":"debian","release":"sid","component":"main","version":"0.2.4","source":"mptp","homepage":"https://github.com/Pas-Kapli/mptp","description":"single-locus species delimitation","long_description":" Implementation of a fast species delimitation method, based on PTP\n (Zhang et al. 2013) with a 64-bit multi-threaded design that handles\n very large datasets.\n .\n The agent mPTP can handle very large biodiversity datasets. It implements\n a fast method to compute the ML delimitation from an inferred\n phylogenetic tree of the samples. Using MCMC, it also computes the\n support values for each clade, which can be used to assess the\n confidence of the ML delimitation.\n .\n ML delimitation mPTP implements two flavours of the point-estimate\n solution. First, it implements the original method from (Zhang et al.\n 2013) where all within-species processes are modelled with a single\n exponential distribution. mPTP uses a dynamic programming implementation\n which estimates the ML delimitation faster and more accurately than the\n original PTP. The dynamic programming implementation has similar\n properties as (Gulek et al. 2010). See the wiki for more information.\n The second method assumes a distinct exponential distribution for the\n branching events of each of the delimited species allowing it to fit to\n a wider range of empirical datasets.\n .\n MCMC method mPTP generates support values for each clades. They\n represent the ratio of the number of samples for which a particular node\n was in the between-species process, to the total number of samples.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 0 / 17","doi":"10.1101/063875","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_15264","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"mrbayes","distribution":"debian","release":"sid","component":"main","version":"3.2.6","source":"mrbayes","homepage":"http://mrbayes.csit.fsu.edu/","description":"Bayesian Inference of Phylogeny","long_description":" Bayesian inference of phylogeny is based upon a quantity called the posterior\n probability distribution of trees, which is the probability of a tree\n conditioned on the observations. The conditioning is accomplished using\n Bayes's theorem. The posterior probability distribution of trees is\n impossible to calculate analytically; instead, MrBayes uses a simulation\n technique called Markov chain Monte Carlo (or MCMC) to approximate the\n posterior probabilities of trees.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"11 / 3 / 154","doi":"10.1093/sysbio/sys029","topics":null,"edam_scopes":null,"bio.agents":"MrBayes","OMICagents":"OMICS_04237","SEQwiki":null,"SciCrunch":{"source":"mrbayes","name":"SciCrunch","entry":"SCR_012067"},"RRID":null},{"package":"mrs","distribution":"debian","release":"sid","component":"main","version":"6.0.5","source":"mrs","homepage":"http://mrs.cmbi.ru.nl/","description":"Information Retrieval System for Biomedical databanks","long_description":" MRS is a complete system to retrieve, index and query biological and\n medical databanks. It comes with all the code required to fetch data\n using FTP or rsync, then creates a local databank with indices using\n a databank specific parser written in Perl. It can then serve this\n data using a built-in web application and webservices.\n .\n Searching can be done on words and Boolean queries. As a bonus you\n can search protein sequences using a custom Blast algorithm.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 0 / 1","doi":"10.1093/nar/gki422","topics":null,"edam_scopes":null,"bio.agents":"mrs","OMICagents":"OMICS_21449","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"msxpertsuite","distribution":"debian","release":"sid","component":"main","version":"5.8.6","source":"msxpertsuite","homepage":"http://www.msxpertsuite.org/","description":"mass spectrometry software suite - metapackage","long_description":" msXpertSuite provides programs to model linear (bio-) polymer\n chemistries, simulate mass spectral data, analyse and data-mine mass.\n It is the successor of GNU polyXmass, first, and then of massXpert.\n .\n The massXpert and mineXpert programs allow the following:\n .\n massXpert:\n  - making brand new polymer chemistry definitions;\n  - using the definitions to perform easy calculations in a desktop\n    calculator-like manner;\n  - performing sophisticated polymer sequence editing and simulations;\n  - perform m/z list comparisons;\n .\n  Chemical simulations encompass cleavage (either chemical or\n  enzymatic), gas-phase fragmentations, chemical modification of any\n  monomer in the polymer sequence, cross-linking of monomers in the\n  sequence, arbitrary mass searches, calculation of the isotopic\n  pattern...\n .\n mineXpert:\n  - Open mass spectrometry data files (mzML, mzXML, asc, xy, ...);\n  - Calculate and display the TIC chromatogram;\n  - For mobility data, calculate and display a mz=f(dt) color map;\n  - Integrate the data from the TIC chromatogram or color map\n    - to mass spectrum;\n    - to drift spectrum;\n    - back to TIC chromatogram (XIC chromatogram);\n    - reverse operations;\n    - to single TIC intensity value\n      (for mass spectral intensity comparisons);\n  - Model centroids peaks into mass spectra using either the\n    Gaussian model or the Lorentzian model;\n  - Export the data to text files;\n  - Slice a big initial file into smaller chunks for easier mining;\n  - Define how mining activity is recorded on disk for later use;\n  - Convert mzML files into a private (albeit open) mass spectrometry\n    format that allows better performance (based on SQLite3).\n .\n This package depends on both massXpert and mineXpert packages and thus will\n install both of them. To install only one of the packages, install the\n corresponding msxpertsuite-massxpert or msxpertsuite-minexpert package.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 0 / 39","doi":"10.1093/bioinformatics/btp504","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_31015","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"mugsy","distribution":"prospective","release":"vcs","component":"main","version":"1r2.3","source":"mugsy","homepage":"http://mugsy.sourceforge.net/","description":"multiple whole genome alignment agent","long_description":" Mugsy is a multiple whole genome aligner. Mugsy uses Nucmer for\n pairwise alignment, a custom graph based segmentation procedure for\n identifying collinear regions, and the segment-based progressive\n multiple alignment strategy from Seqan::TCoffee. Mugsy accepts draft\n genomes in the form of multi-FASTA files and does not require a\n reference genome.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1093/bioinformatics/btq665","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_03606","SEQwiki":null,"SciCrunch":{"source":"mugsy","name":"SciCrunch","entry":"SCR_001414"},"RRID":null},{"package":"mummer","distribution":"debian","release":"sid","component":"main","version":"3.23","source":"mummer","homepage":"http://mummer.sourceforge.net/","description":"Efficient sequence alignment of full genomes","long_description":" MUMmer is a system for rapidly aligning entire genomes, whether\n in complete or draft form. For example, MUMmer 3.0 can find all\n 20-basepair or longer exact matches between a pair of 5-megabase genomes\n in 13.7 seconds, using 78 MB of memory, on a 2.4 GHz Linux desktop\n computer. MUMmer can also align incomplete genomes; it handles the 100s\n or 1000s of contigs from a shotgun sequencing project with ease, and\n will align them to another set of contigs or a genome using the NUCmer\n program included with the system. If the species are too divergent for\n DNA sequence alignment to detect similarity, then the PROmer program\n can generate alignments based upon the six-frame translations of both\n input sequences.\n","interface":["commandline"],"biology":null,"fields":["biology","biology:bioinformatics"],"use":["comparing"],"popcon":"21 / 5 / 235","doi":"10.1186/gb-2004-5-2-r12","topics":["Sequence analysis"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Sequence", "formats": ["FASTA"]}], "outputs": [{"data": "Sequence alignment", "formats": ["Alignment format (text)"]}, {"data": "Sequence", "formats": ["FASTA"]}, {"data": "Sequence variations", "formats": ["Textual format"]}], "function": ["Local sequence alignment", "Genome alignment"]}],"bio.agents":"mummer","OMICagents":"OMICS_14554","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"murasaki","distribution":"debian","release":"sid","component":"main","version":"1.68.6","source":"murasaki","homepage":"http://murasaki.dna.bio.keio.ac.jp/wiki/","description":"homology detection agent across multiple large genomes","long_description":" Murasaki is a scalable and fast, language theory-based homology\n detection agent across multiple large genomes. It enable whole-genome\n scale multiple genome global alignments. Supports unlimited length\n gapped-seed patterns and unique TF-IDF based filtering.\n .\n Murasaki is an anchor alignment software, which is\n  * exteremely fast (17 CPU hours for whole Human x Mouse genome (with\n    40 nodes: 52 wall minutes))\n  * scalable (Arbitrarily parallelizable across multiple nodes using MPI.\n    Even a single node with 16GB of ram can handle over 1Gbp of sequence.)\n  * unlimited pattern length\n  * repeat tolerant\n  * intelligent noise reduction\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 3 / 58","doi":"10.1371/journal.pone.0012651","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_11714","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"murasaki-mpi","distribution":"debian","release":"sid","component":"main","version":"1.68.6","source":"murasaki","homepage":"http://murasaki.dna.bio.keio.ac.jp/wiki/","description":"homology detection agent across multiple large genomes (MPI-version)","long_description":" Murasaki is a scalable and fast, language theory-based homology\n detection agent across multiple large genomes. It enable whole-genome\n scale multiple genome global alignments. Supports unlimited length\n gapped-seed patterns and unique TF-IDF based filtering.\n .\n Murasaki is an anchor alignment software, which is\n  * exteremely fast (17 CPU hours for whole Human x Mouse genome (with\n    40 nodes: 52 wall minutes))\n  * scalable (Arbitrarily parallelizable across multiple nodes using MPI.\n    Even a single node with 16GB of ram can handle over 1Gbp of sequence.)\n  * unlimited pattern length\n  * repeat tolerant\n  * intelligent noise reduction\n .\n This package provides the MPI-enabled binary for murasaki.  While this\n will speed up operation on multi-processor machines it will slow down\n on a single processor.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 0 / 2","doi":"10.1371/journal.pone.0012651","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_11714","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"muscle","distribution":"debian","release":"sid","component":"main","version":"3.8.1551","source":"muscle","homepage":"http://www.drive5.com/muscle/","description":"Multiple alignment program of protein sequences","long_description":" MUSCLE is a multiple alignment program for protein sequences. MUSCLE\n stands for multiple sequence comparison by log-expectation. In the\n authors tests, MUSCLE achieved the highest scores of all tested\n programs on several alignment accuracy benchmarks, and is also one of\n the fastest programs out there.\n","interface":["commandline"],"biology":["format:aln","nuceleic-acids","peptidic"],"fields":["biology","biology:bioinformatics"],"use":["comparing"],"popcon":"27 / 42 / 499","doi":"10.1093/nar/gkh340","topics":["Sequence analysis"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Sequence", "formats": ["FASTA"]}], "outputs": [{"data": "Alignment", "formats": ["FASTA-aln", "ClustalW format", "PHYLIP format"]}], "function": ["Multiple sequence alignment"]}],"bio.agents":"MUSCLE","OMICagents":"OMICS_00982","SEQwiki":null,"SciCrunch":{"source":"muscle","name":"SciCrunch","entry":"SCR_011812"},"RRID":null},{"package":"mustang","distribution":"debian","release":"sid","component":"main","version":"3.2.3","source":"mustang","homepage":"http://lcb.infotech.monash.edu.au/mustang/","description":"multiple structural alignment of proteins","long_description":" Mustang is an algorithm to align multiple protein structures.\n Given a set of PDB files, the program uses the spatial\n information in the Calpha atoms of the set to produce a sequence alignment.\n Based on a progressive pairwise heuristic the algorithm then proceeds\n through a number of refinement passes. Mustang reports the multiple\n sequence alignment and the corresponding superposition of structures.\n","interface":["commandline"],"biology":["peptidic"],"fields":["biology","biology:bioinformatics"],"use":["comparing","analysing"],"popcon":"17 / 5 / 366","doi":"10.1002/prot.20921","topics":null,"edam_scopes":null,"bio.agents":"MUSTANG","OMICagents":"OMICS_03642","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"mview","distribution":"prospective","release":"vcs","component":"main","version":"1.64","source":"mview","homepage":"https://desmid.github.io/mview/","description":"biological sequence alignment conversion","long_description":" mview is a command line utility that extracts and reformats the results\n of a sequence database search or a multiple alignment, optionally adding\n HTML markup for web page layout. It can also be used as a filter to\n extract and convert searches or alignments to common formats.\n .\n Inputs:\n  * Sequence database search: BLAST, FASTA suites.\n  * Multiple sequence alignment: CLUSTAL, HSSP, MSF, FASTA, PIR, MAF\n Outputs:\n  * HTML, FASTA, CLUSTAL, MSF, PIR, RDB (tab-separated).\n .\n The redundancy of that source tree with existing JS packages needs to\n be evaluated. In the interim, the package shall remain in experimental.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1093/bioinformatics/14.4.380","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_15907","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"nanocall","distribution":"prospective","release":"vcs","component":"main","version":"0.7.4","source":"nanocall","homepage":"https://github.com/mateidavid/nanocall","description":"Basecaller for Oxford Nanopore Sequencing Data","long_description":" The highly portable Oxford Nanopore MinION sequencer has enabled new\n applications of genome sequencing directly in the field. However, the\n MinION currently relies on a cloud computing platform, Metrichor\n (metrichor.com), for translating locally generated sequencing data into\n basecalls.\n .\n Nanocall allows offline and private analysis of MinION data. Nanocall is\n the first freely-available, open-source basecaller for Oxford Nanopore\n sequencing data and does not require an internet connection. Using R7.3\n chemistry, on two E.coli and two human samples, with natural as well as\n PCR-amplified DNA, Nanocall reads have ~68% identity, directly\n comparable to Metrichor \"1D\" data. Further, Nanocall is efficient,\n processing ~2500Kbp of sequence per core hour using the fastest\n settings, and fully parallelized. Using a 4 core desktop computer,\n Nanocall could basecall a MinION sequencing run in real time. Metrichor\n provides the ability to integrate the \"1D\" sequencing of template and\n complement strands of a single DNA molecule, and create a \"2D\" read.\n Nanocall does not currently integrate this technology, and addition of\n this capability will be an important future development. In summary,\n Nanocall is the first open-source, freely available, off-line basecaller\n for Oxford Nanopore sequencing data.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1093/bioinformatics/btw569","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_11495","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"nanook","distribution":"debian","release":"sid","component":"main","version":"1.33","source":"nanook","homepage":"https://documentation.tgac.ac.uk/display/NANOOK/NanoOK","description":"pre- and post-alignment analysis of nanopore sequencing data","long_description":" NanoOK is a flexible, multi-reference software for pre- and post-\n alignment analysis of nanopore sequencing data, quality and error\n profiles.\n .\n NanoOK (pronounced na-nook) is a agent for extraction, alignment and\n analysis of Nanopore reads. NanoOK will extract reads as FASTA or FASTQ\n files, align them (with a choice of alignment agents), then generate a\n comprehensive multi-page PDF report containing yield, accuracy and\n quality analysis. Along the way, it generates plain text files which can\n be used for further analysis, as well as graphs suitable for inclusion\n in presentations and papers.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 0 / 15","doi":"10.1093/bioinformatics/btv540","topics":null,"edam_scopes":null,"bio.agents":"https://bio.agents/NanoOK","OMICagents":"OMICS_09997","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"nanopolish","distribution":"debian","release":"sid","component":"main","version":"0.11.0","source":"nanopolish","homepage":"https://github.com/jts/nanopolish","description":"consensus caller for nanopore sequencing data","long_description":" Nanopolish uses a signal-level hidden Markov model for consensus calling\n of nanopore genome sequencing data. It can perform signal-level analysis\n of Oxford Nanopore sequencing data. Nanopolish can calculate an improved\n consensus sequence for a draft genome assembly, detect base\n modifications, call SNPs and indels with respect to a reference genome\n and more.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 8 / 62","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_16545","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"ncbi-blast+","distribution":"debian","release":"sid","component":"main","version":"2.8.1","source":"ncbi-blast+","homepage":"http://www.ncbi.nlm.nih.gov/IEB/AgentBox/CPP_DOC/","description":"next generation suite of BLAST sequence search agents","long_description":" The Basic Local Alignment Search Agent (BLAST) is the most widely\n used sequence similarity agent. There are versions of BLAST that\n compare protein queries to protein databases, nucleotide queries\n to nucleotide databases, as well as versions that translate nucleotide\n queries or databases in all six frames and compare to protein databases\n or queries.\n PSI-BLAST produces a position-specific-scoring-matrix (PSSM) starting\n with a protein query, and then uses that PSSM to perform further searches.\n It is also possible to compare a protein or nucleotide query to a\n database of PSSM’s.\n The NCBI supports a BLAST web page at blast.ncbi.nlm.nih.gov as well as\n a network service.\n","interface":["commandline"],"biology":null,"fields":["biology","biology:bioinformatics"],"use":["analysing"],"popcon":"86 / 84 / 1204","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"blast","OMICagents":"OMICS_01436","SEQwiki":null,"SciCrunch":{"source":"ncbi-blast+","name":"SciCrunch","entry":"SCR_004870"},"RRID":null},{"package":"ncbi-blast+-legacy","distribution":"debian","release":"sid","component":"main","version":"2.8.1","source":"ncbi-blast+","homepage":"http://www.ncbi.nlm.nih.gov/IEB/AgentBox/CPP_DOC/","description":"NCBI Blast legacy call script","long_description":" This package adds some fake scripts to call NCBI+ programs\n with the NCBI blast command line. It makes use of the\n legacy_blast script in ncbi-blast+ package.\n","interface":["commandline"],"biology":null,"fields":["biology","biology:bioinformatics"],"use":null,"popcon":"30 / 58 / 779","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"blast","OMICagents":"OMICS_01436","SEQwiki":null,"SciCrunch":{"source":"ncbi-blast+","name":"SciCrunch","entry":"SCR_004870"},"RRID":null},{"package":"ncbi-entrez-direct","distribution":"debian","release":"sid","component":"main","version":"10.9.20190219+ds","source":"ncbi-entrez-direct","homepage":"http://www.ncbi.nlm.nih.gov/books/NBK179288","description":"NCBI Entrez utilities on the command line","long_description":" Entrez Direct (EDirect) is an advanced method for accessing NCBI's set\n of interconnected databases (publication, sequence, structure, gene,\n variation, expression, etc.) from a terminal window or script.\n Functions take search terms from command-line arguments.  Individual\n operations are combined to build multi-step queries.  Record retrieval\n and formatting normally complete the process.\n .\n EDirect also provides an argument-driven function that simplifies the\n extraction of data from document summaries or other results that are\n returned in structured XML format.  This can eliminate the need for\n writing custom software to answer ad hoc questions.  Queries can move\n seamlessly between EDirect commands and UNIX utilities or scripts to\n perform actions that cannot be accomplished entirely within Entrez.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 20 / 69","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"ncbi-igblast","distribution":"prospective","release":"vcs","component":"main","version":"1.9.0","source":"ncbi-igblast","homepage":"https://ncbi.github.io/igblast/","description":"Immunoglobulin and T cell receptor variable domain sequence analysis","long_description":" IgBLAST allows users to view the matches to the germline V, D, and J\n genes, details at rearrangement junctions, the delineation of IG V\n domain framework regions, and complementarity determining regions.\n IgBLAST has the capability to analyse nucleotide and protein\n sequences, and can process sequences in batches.  Furthermore,\n IgBLAST allows searches against the germline gene databases and other\n sequence databases simultaneously to minimize the chance of missing\n possibly the best matching germline V gene.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":"igblast","OMICagents":"OMICS_06083","SEQwiki":null,"SciCrunch":{"source":"ncbi-igblast","name":"SciCrunch","entry":"SCR_002873"},"RRID":null},{"package":"ncbi-seg","distribution":"debian","release":"sid","component":"main","version":"0.0.20000620","source":"ncbi-seg","homepage":"ftp://ftp.ncbi.nih.gov/pub/seg/seg/","description":"agent to mask segments of low compositional complexity in amino acid sequences","long_description":" ncbi-seg (a.k.a. SEG) is a program for identifying and masking segments of\n low compositional complexity in amino acid sequences.\n .\n ncbi-seg divides sequences into contrasting segments of low-complexity and\n high-complexity.  Low-complexity segments defined by the\n algorithm represent \"simple sequences\" or \"compositionally-biased regions\".\n .\n This program is inappropriate for masking nucleotide sequences and, in fact,\n may strip some nucleotide ambiguity codes from nt. sequences as they are being\n read.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"10 / 3 / 124","doi":"10.1016/0097-8485(93)85006-X","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libncbi6-dev","distribution":"debian","release":"sid","component":"main","version":"6.1.20170106","source":"ncbi-agents6","homepage":"http://www.ncbi.nlm.nih.gov/IEB/AgentBox/","description":"NCBI libraries for biology applications (development files)","long_description":" This package supplies development versions of NCBI's non-graphical C\n libraries, along with the corresponding header files.\n","interface":null,"biology":["nuceleic-acids","peptidic"],"fields":["biology","biology:bioinformatics"],"use":["analysing","calculating","converting","searching"],"popcon":"0 / 3 / 47","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"cn3d","OMICagents":"OMICS_05052","SEQwiki":null,"SciCrunch":{"source":"ncbi-agents6","name":"SciCrunch","entry":"SCR_004861"},"RRID":null},{"package":"libvibrant6-dev","distribution":"debian","release":"sid","component":"main","version":"6.1.20170106","source":"ncbi-agents6","homepage":"http://www.ncbi.nlm.nih.gov/IEB/AgentBox/","description":"NCBI libraries for graphic biology applications (development files)","long_description":" Vibrant allows you to develop portable (Motif, MS-Windows, Mac-OS) graphic\n biological applications.\n","interface":["3d","x11"],"biology":["nuceleic-acids","peptidic"],"fields":["biology","biology:bioinformatics","biology:structural"],"use":["analysing","calculating","editing","viewing"],"popcon":"0 / 2 / 37","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"cn3d","OMICagents":"OMICS_05052","SEQwiki":null,"SciCrunch":{"source":"ncbi-agents6","name":"SciCrunch","entry":"SCR_004861"},"RRID":null},{"package":"ncbi-agents-bin","distribution":"debian","release":"sid","component":"main","version":"6.1.20170106","source":"ncbi-agents6","homepage":"http://www.ncbi.nlm.nih.gov/IEB/AgentBox/","description":"NCBI libraries for biology applications (text-based utilities)","long_description":" This package includes various utilities distributed with the NCBI C SDK,\n including the development agents asnagent and errhdr (formerly of\n libncbi6-dev).  None of the programs in this package require X; you can\n find the X-based utilities in the ncbi-agents-x11 package.  BLAST and\n related agents now come from a separate source base, corresponding to the\n ncbi-blast+ and ncbi-blast+-legacy packages.\n","interface":["commandline"],"biology":["nuceleic-acids","peptidic"],"fields":["biology","biology:bioinformatics"],"use":["calculating","analysing","converting","searching"],"popcon":"14 / 7 / 203","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"cn3d","OMICagents":"OMICS_05052","SEQwiki":null,"SciCrunch":{"source":"ncbi-agents6","name":"SciCrunch","entry":"SCR_004861"},"RRID":null},{"package":"ncbi-agents-x11","distribution":"debian","release":"sid","component":"main","version":"6.1.20170106","source":"ncbi-agents6","homepage":"http://www.ncbi.nlm.nih.gov/IEB/AgentBox/","description":"NCBI libraries for biology applications (X-based utilities)","long_description":" This package includes some X-based utilities distributed with the\n NCBI C SDK: Cn3D, Network Entrez, Sequin, ddv, and udv.  These\n programs are not part of ncbi-agents-bin because they depend on\n several additional library packages.\n","interface":["3d","x11"],"biology":["nuceleic-acids","peptidic"],"fields":["biology:structural","biology","biology:bioinformatics"],"use":["analysing","calculating","editing","searching","viewing"],"popcon":"91 / 5 / 160","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"cn3d","OMICagents":"OMICS_05052","SEQwiki":null,"SciCrunch":{"source":"ncbi-agents6","name":"SciCrunch","entry":"SCR_004861"},"RRID":null},{"package":"libncbi-vdb-dev","distribution":"debian","release":"sid","component":"main","version":"2.9.3","source":"ncbi-vdb","homepage":"https://github.com/ncbi/ncbi-vdb","description":"libraries for using data in the INSDC Sequence Read Archives (devel)","long_description":" Much of the data submitted these days, for example in BAM, Illumina\n export.txt, and Complete Genomics formats, contain alignment\n information. With aligned data, NCBI uses Compression by Reference,\n which only stores the differences in base pairs between sequence data\n and the segment it aligns to. The process to restore original data, for\n example as FastQ, requires fast access to the reference sequences that\n the original data was aligned to. NCBI recommends that SRA users\n dedicate local disk space to store references downloaded from the NCBI\n SRA site. As of Fall 2014, the complete collection of these reference\n sequences is 66 GB. While it isn't usually necessary to download the\n entirety of the reference sequences, this should give you an idea of the\n scale of the storage requirement. By default, the Agentkit will download\n missing reference sequences on demand and cache them in the user's home\n directory. The location of this cache is configurable, as is whether the\n download is automatic or manual.\n .\n This is the development package.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 2 / 33","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"neobio","distribution":"debian","release":"sid","component":"main","version":"0.0.20030929","source":"neobio","homepage":"http://neobio.sourceforge.net/","description":"computes alignments of amino acid and nucleotide sequences","long_description":" Library and graphical user interface for pairwise sequence alignments.\n Implementation of the dynamic programming methods of Needleman & Wunsch\n (global alignment) and Smith & Waterman (local alignment).\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 3 / 73","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"NeoBio_1.0_pre-alpha","OMICagents":"OMICS_21450","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"nextsv","distribution":"prospective","release":"vcs","component":"non-free","version":"0.4.0","source":"nextsv","homepage":"https://github.com/Nextomics/nextsv","description":"automated structural variation detection for long-read sequencing","long_description":" NextSV is an computational pipeline that allows structural variant (SV)\n calling from PacBio sequencing data using PBhoney and Sniffles. NextSV takes\n FASTA or FASTQ files as input. Once the SV caller is selected by user, NextSV\n automatically chooses the compatible aligner and performs mapping. The\n alignments will be automatically sorted and then presented to the SV caller.\n Users can change the parameters by modifying its configuration file. When the\n analysis is finished, NextSV will examine the FASTA/FASTQ, BAM, and result\n files and generate a report showing various statistics. If more than both\n callers are selected, NextSV will format the raw result files (.tails, .spots,\n or .vcf files) into bed files and generate the intersection or union call set\n for the purpose of higher accuracy or sensitivity.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1101/092544","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"ngila","distribution":"prospective","release":"vcs","component":"main","version":"1.3","source":"ngila","homepage":"https://github.com/reedacartwright/ngila","description":"global pairwise alignments with logarithmic and affine gap costs","long_description":" Ngila is an application that will find the best alignment of a pair\n of sequences using log-affine gap costs, which are the most\n biologically realistic gap costs.\n .\n Ngila implements the Miller and Myers (1988) algorithm in order to\n find a least costly global alignment of two sequences given homology\n costs and a gap cost. Two versions of the algorithm are\n included: holistic and divide-and-conquer. The former is faster but\n the latter utilizes less memory. Ngila starts with the\n divide-and-conquer method but switches to the holistic method for\n subsequences smaller than a user-established threshold. This improves\n its speed without substantially increasing memory requirements. Ngila\n also allows users to assign costs to end gaps that are smaller than\n costs for internal gaps. This is important for aligning using the\n free-end-gap method.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1093/bioinformatics/btm095","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_03695","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"ngsqcagentkit","distribution":"prospective","release":"vcs","component":"main","version":"2.3.3","source":"ngsqcagentkit","homepage":"http://nipgr.res.in/ngsqcagentkit.html","description":"agentkit for the quality control of next generation sequencing data","long_description":" NGS QC Agentkit: A agentkit for the quality control (QC) of next\n generation sequencing (NGS) data. The agentkit comprises of user-friendly\n stand alone agents for quality control of the sequence data generated\n using Illumina and Roche 454 platforms with detailed results in the form\n of tables and graphs, and filtering of high-quality sequence data. It\n also includes few other agents, which are helpful in NGS data quality\n control and analysis. ","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1371/journal.pone.0030619","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libngs-java","distribution":"debian","release":"sid","component":"main","version":"2.9.3","source":"ngs-sdk","homepage":"https://github.com/ncbi/ngs","description":"Next Generation Sequencing language Bindings (Java bindings)","long_description":" NGS is a new, domain-specific API for accessing reads, alignments and\n pileups produced from Next Generation Sequencing. The API itself is\n independent from any particular back-end implementation, and supports\n use of multiple back-ends simultaneously. It also provides a library for\n building new back-end \"engines\". The engine for accessing SRA data is\n contained within the sister repository ncbi-vdb.\n .\n The API is currently expressed in C++, Java and Python languages. The\n design makes it possible to maintain a high degree of similarity between\n the code in one language and code in another - especially between C++\n and Java.\n .\n Java bindings.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 16 / 247","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libngs-sdk-dev","distribution":"debian","release":"sid","component":"main","version":"2.9.3","source":"ngs-sdk","homepage":"https://github.com/ncbi/ngs","description":"Next Generation Sequencing language Bindings (development)","long_description":" NGS is a new, domain-specific API for accessing reads, alignments and\n pileups produced from Next Generation Sequencing. The API itself is\n independent from any particular back-end implementation, and supports\n use of multiple back-ends simultaneously. It also provides a library for\n building new back-end \"engines\". The engine for accessing SRA data is\n contained within the sister repository ncbi-vdb.\n .\n The API is currently expressed in C++, Java and Python languages. The\n design makes it possible to maintain a high degree of similarity between\n the code in one language and code in another - especially between C++\n and Java.\n .\n This is the development package.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 33 / 249","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python3-ngs","distribution":"debian","release":"sid","component":"main","version":"2.9.3","source":"ngs-sdk","homepage":"https://github.com/ncbi/ngs","description":"Next Generation Sequencing language Bindings (Python3 bindings)","long_description":" NGS is a new, domain-specific API for accessing reads, alignments and\n pileups produced from Next Generation Sequencing. The API itself is\n independent from any particular back-end implementation, and supports\n use of multiple back-ends simultaneously. It also provides a library for\n building new back-end \"engines\". The engine for accessing SRA data is\n contained within the sister repository ncbi-vdb.\n .\n The API is currently expressed in C++, Java and Python languages. The\n design makes it possible to maintain a high degree of similarity between\n the code in one language and code in another - especially between C++\n and Java.\n .\n Python3 bindings.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 1 / 33","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"njplot","distribution":"debian","release":"sid","component":"main","version":"2.4","source":"njplot","homepage":"http://pbil.univ-lyon1.fr/software/njplot","description":"phylogenetic tree drawing program","long_description":" NJplot is able to draw any dendrogram expressed in the Newick standard\n phylogenetic tree format (e.g., the format used by the Phylip package).\n NJplot is especially convenient for rooting the unrooted trees\n obtained from parsimony, distance or maximum likelihood tree-building\n methods.\n","interface":["x11"],"biology":null,"fields":["biology","biology:bioinformatics"],"use":["analysing","editing","organizing","printing","viewing"],"popcon":"84 / 0 / 138","doi":"10.1016/0300-9084(96)84768-7","topics":null,"edam_scopes":null,"bio.agents":"NJplot","OMICagents":"OMICS_04815","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"norsnet","distribution":"debian","release":"sid","component":"main","version":"1.0.17","source":"norsnet","homepage":"https://www.rostlab.org/owiki/index.php/Norsnet","description":"agent to identify unstructured loops in proteins","long_description":" NORSnet can distinguish between very long contiguous segments with\n non-regular secondary structure (NORS regions) and well-folded proteins.\n .\n NORSnet was trained on predicted information rather than on experimental data.\n This allows NORSnet to reach into regions in sequence space that are not\n covered by specialized disorder predictors.  One disadvantage of this approach\n is that it is not optimal for the identification of the \"average\" disordered\n region.\n .\n NORSnet takes the following input, further described on norsnet(1):\n  * a protein sequence in a FASTA file\n  * secondary structure and solvent accessibility prediction by prof(1)\n  * an HSSP file\n  * flexible/rigid residues prediction by profbval(1)\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 3 / 117","doi":"10.1371/journal.pcbi.0030140","topics":null,"edam_scopes":null,"bio.agents":"norsnet","OMICagents":"OMICS_16034","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"norsp","distribution":"debian","release":"sid","component":"main","version":"1.0.6","source":"norsp","homepage":"https://rostlab.org/owiki/index.php/NORSp_-_predictor_of_NOn-Regular_Secondary_Structure","description":"predictor of non-regular secondary structure","long_description":" NORSp is a publicly available predictor for disordered regions in proteins.\n Specifically, it predicts long regions with no regular secondary structure.\n Upon submission of a protein sequence, NORSp analyses the protein about its\n secondary structure, the presence of transmembrane helices and coiled-coils.\n It then returns the presence and position of disordered regions.\n .\n NORSp can be useful for biologists in several ways. For example,\n crystallographers can check whether their proteins contain NORS regions and\n make the decision about whether to proceed with the experiments since NORS\n proteins may be difficult to crystallise, as demonstrated by the their low\n occurrence in PDB. Biologists interested in protein structure-function\n relationship may also find it interesting to verify whether the\n protein-protein interaction sites coincide with NORS regions.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 3 / 118","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"norsp","OMICagents":"OMICS_21452","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"nw-align","distribution":"prospective","release":"vcs","component":"main","version":"0.20100803","source":"nw-align","homepage":"http://zhanglab.ccmb.med.umich.edu/NW-align","description":"global protein sequence alignment","long_description":" NWalign is simple and robust alignment program for protein\n sequence-to-sequence alignments based on the standard Needleman-Wunsch\n dynamic programming algorithm. The implementation is performed in\n FORTRAN.\n .\n This program was tested at 2014-02-01 by Daniel Barker at the Debian\n Med sprint and was not functional according to his test.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"oases","distribution":"prospective","release":"vcs","component":"main","version":"0.2.09","source":"oases","homepage":"https://www.ebi.ac.uk/~zerbino/oases/","description":"de novo transcriptome assembler for very short reads","long_description":" Oases is a de novo transcriptome assembler designed to produce\n transcripts from short read sequencing technologies, such as Illumina,\n SOLiD, or 454 in the absence of any genomic assembly.  Oases uploads a\n preliminary assembly produced by Velvet, and clusters the contigs into\n small groups, called loci. It then exploits the paired-end read and long\n read information, when available, to construct transcript isoforms.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1093/bioinformatics/bts094","topics":null,"edam_scopes":null,"bio.agents":"oases","OMICagents":"OMICS_01322","SEQwiki":null,"SciCrunch":{"source":"oases","name":"SciCrunch","entry":"SCR_011896"},"RRID":null},{"package":"obiagents","distribution":"debian","release":"sid","component":"main","version":"1.2.12","source":"obiagents","homepage":"https://pypi.python.org/pypi/OBIAgents","description":"programs to analyze NGS data in a DNA metabarcoding context","long_description":" The OBIAgents programs aims to help you to manipulate various data and\n sequence files in a convenient way using the Unix command line interface.\n They follow the standard Unix interface for command line program, allowing to\n chain a set of commands using the pipe mechanism.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 7 / 10","doi":"10.1111/1755-0998.12428","topics":null,"edam_scopes":null,"bio.agents":"OBIAgents","OMICagents":"OMICS_32696","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"omegamap","distribution":"prospective","release":"vcs","component":"main","version":"0.5","source":"omegamap","homepage":"http://www.danielwilson.me.uk/omegaMap.html","description":"describing selection and recombination in sequences","long_description":" OmegaMap is a program for detecting natural selection and recombination\n in DNA or RNA sequences.  It is based on a model of population\n genetics and molecular evolution.  The signature of natural selection\n is determined by the relative excess of non-synonymous to synonymous\n polymorphisms.  The signature of recombination is detected from the\n patterns of linkage disequilibrium.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1534/genetics.105.044917","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_31719","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libopenms-dev","distribution":"debian","release":"sid","component":"main","version":"2.4.0-real","source":"openms","homepage":"http://www.openms.de","description":"library for LC/MS data management and analysis - dev files","long_description":" OpenMS is a library for LC/MS data management and analysis. OpenMS\n offers an infrastructure for the development of mass\n spectrometry-related software and powerful 2D and 3D visualization\n solutions.\n .\n OpenMS offers analyses for various quantitation protocols, including\n label-free quantitation, SILAC, iTRAQ, SRM, SWATH…\n .\n It provides built-in algorithms for de-novo identification and\n database search, as well as adapters to other state-of-the art agents\n like X!Tandem, Mascot, OMSSA…\n .\n OpenMS supports the Proteomics Standard Initiative (PSI) formats for\n MS data and supports easy integration of agents into workflow engines\n like Knime, Galaxy, WS-Pgrade, and TOPPAS via the TOPPagents concept\n and a unified parameter handling.\n .\n This package ships the library development files.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 5 / 11","doi":"10.1186/1471-2105-9-163","topics":null,"edam_scopes":null,"bio.agents":"openms","OMICagents":"OMICS_02387","SEQwiki":null,"SciCrunch":{"source":"openms","name":"SciCrunch","entry":"SCR_012042"},"RRID":null},{"package":"openms","distribution":"debian","release":"sid","component":"main","version":"2.4.0-real","source":"openms","homepage":"http://www.openms.de","description":"package for LC/MS data management and analysis","long_description":" OpenMS is a package for LC/MS data management and analysis. OpenMS\n offers an infrastructure for the development of mass\n spectrometry-related software and powerful 2D and 3D visualization\n solutions.\n .\n TOPP (the OpenMS proteomic pipeline) is a pipeline for the analysis\n of HPLC/MS data. It consists of a set of numerous small applications\n that can be chained together to create analysis pipelines tailored\n for a specific problem.\n .\n This package is a metapackage that depends on both the libopenms\n library package (libOpenMS and libOpenMS_GUI) and the OpenMS\n Proteomic Pipeline (topp) package.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 1 / 66","doi":"10.1186/1471-2105-9-163","topics":null,"edam_scopes":null,"bio.agents":"openms","OMICagents":"OMICS_02387","SEQwiki":null,"SciCrunch":{"source":"openms","name":"SciCrunch","entry":"SCR_012042"},"RRID":null},{"package":"topp","distribution":"debian","release":"sid","component":"main","version":"2.4.0-real","source":"openms","homepage":"http://www.openms.de","description":"set of programs implementing The OpenMS Proteomic Pipeline","long_description":" TOPP (the OpenMS proteomic pipeline) is a pipeline for the analysis\n of HPLC/MS data. It consists of a set of numerous small applications\n that can be chained together to create analysis pipelines tailored\n for a specific problem. The applications make use of the libopenms\n library. Some examples of these applications are :\n .\n   - TOPPView: A viewer for mass spectrometry data.\n   - TOPPAS: An assistant for GUI-driven TOPP workflow design.\n   - DTAExtractor: Extracts spectra of an MS run file to several\n     files in DTA format.\n   - FileConverter:  Converts between different MS file formats.\n   - FileFilter: Extracts or manipulates portions of data from peak,\n     feature or consensus feature files.\n   - SpectraMerger: Merges spectra from an LC/MS map, either by\n     precursor or by RT blocks.\n   - BaselineFilter: Removes the baseline from profile spectra using a\n     top-hat filter.\n   - InternalCalibration: Applies an internal calibration.\n   - PTModel: Trains a model for the prediction of proteotypic\n     peptides from a training set.\n   - RTPredict: Predicts retention times for peptides using a model\n     trained by RTModel.\n   - ExecutePipeline: Executes workflows created by TOPPAS.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 6 / 64","doi":"10.1186/1471-2105-9-163","topics":null,"edam_scopes":null,"bio.agents":"openms","OMICagents":"OMICS_02387","SEQwiki":null,"SciCrunch":{"source":"openms","name":"SciCrunch","entry":"SCR_012042"},"RRID":null},{"package":"paipline","distribution":"prospective","release":"vcs","component":"main","version":"0.0+git20180416.062bce7","source":"paipline","homepage":"https://gitlab.com/andreas.andrusch/paipline","description":"Pipeline for the Automatic Identification of Pathogens","long_description":" This program is designed to search for pathogen nucleic acid sequences\n in NGS datasets. It needs databases in the format provided by the database-\n updater found under https://gitlab.com/andreas.andrusch/database-updater.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1093/bioinformatics/bty595","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"pal2nal","distribution":"debian","release":"sid","component":"main","version":"14.1","source":"pal2nal","homepage":"http://www.bork.embl.de/pal2nal","description":"converts proteins to genomic DNA alignment","long_description":" PAL2NAL is a program that converts a multiple sequence alignment\n of proteins and the corresponding DNA (or mRNA) sequences into\n a codon-based DNA alignment. The program automatically assigns\n the corresponding codon sequence even if the input DNA sequence\n has mismatches with the input protein sequence, or contains UTRs,\n polyA tails. It can also deal with frame shifts in the input\n alignment, which is suitable for the analysis of pseudogenes.\n The resulting codon-based DNA alignment can further be subjected\n to the calculation of synonymous (Ks) and non-synonymous (Ka)\n substitution rates.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 0 / 17","doi":"10.1093/nar/gkl315","topics":null,"edam_scopes":null,"bio.agents":"pal2nal","OMICagents":"OMICS_20386","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"paleomix","distribution":"debian","release":"sid","component":"main","version":"1.2.13.3","source":"paleomix","homepage":"http://geogenetics.ku.dk/publications/paleomix","description":"pipelines and agents for the processing of ancient and modern HTS data","long_description":" The PALEOMIX pipelines are a set of pipelines and agents designed to aid\n the rapid processing of High-Throughput Sequencing (HTS) data: The BAM\n pipeline processes de-multiplexed reads from one or more samples,\n through sequence processing and alignment, to generate BAM alignment\n files useful in downstream analyses; the Phylogenetic pipeline carries\n out genotyping and phylogenetic inference on BAM alignment files, either\n produced using the BAM pipeline or generated elsewhere; and the Zonkey\n pipeline carries out a suite of analyses on low coverage equine\n alignments, in order to detect the presence of F1-hybrids in\n archaeological assemblages. In addition, PALEOMIX aids in metagenomic\n analysis of the extracts.\n .\n The pipelines have been designed with ancient DNA (aDNA) in mind, and\n includes several features especially useful for the analyses of ancient\n samples, but can all be for the processing of modern samples, in order\n to ensure consistent data processing.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 0 / 12","doi":"10.1038/nprot.2014.063","topics":null,"edam_scopes":null,"bio.agents":"PALEOMIX","OMICagents":"OMICS_03749","SEQwiki":null,"SciCrunch":{"source":"paleomix","name":"SciCrunch","entry":"SCR_015057"},"RRID":null},{"package":"paml","distribution":"debian","release":"sid","component":"main","version":"4.9h","source":"paml","homepage":"http://abacus.gene.ucl.ac.uk/software/paml.html","description":"Phylogenetic Analysis by Maximum Likelihood (PAML)","long_description":" PAML is a package of programs for phylogenetic analyses of DNA or\n protein sequences using maximum likelihood. PAML is not good for tree\n making. It may be used to estimate parameters and test hypotheses to\n study the evolutionary process, when you have reconstructed trees using\n other programs such as PAUP*, PHYLIP, MOLPHY, PhyML, RaxML, etc.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 1 / 36","doi":"10.1093/molbev/msm088","topics":null,"edam_scopes":null,"bio.agents":"paml","OMICagents":"OMICS_04238","SEQwiki":null,"SciCrunch":{"source":"paml","name":"SciCrunch","entry":"SCR_014932"},"RRID":null},{"package":"paraclu","distribution":"debian","release":"sid","component":"main","version":"9","source":"paraclu","homepage":"http://cbrc3.cbrc.jp/~martin/paraclu/","description":"Parametric clustering of genomic and transcriptomic features","long_description":" Paraclu finds clusters in data attached to sequences.  It was first\n applied to transcription start counts in genome sequences, but it\n could be applied to other things too.\n .\n Paraclu is intended to explore the data, imposing minimal prior\n assumptions, and letting the data speak for itself.\n .\n One consequence of this is that paraclu can find clusters within\n clusters.  Real data sometimes exhibits clustering at multiple scales:\n there may be large, rarefied clusters; and within each large cluster\n there may be several small, dense clusters.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 3 / 114","doi":"10.1101/gr.6831208","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_21452","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"parsinsert","distribution":"debian","release":"sid","component":"main","version":"1.04","source":"parsinsert","homepage":"http://sourceforge.net/projects/parsinsert/","description":"Parsimonious Insertion of unclassified sequences into phylogenetic trees","long_description":" ParsInsert efficiently produces both a phylogenetic tree and taxonomic\n classification for sequences for microbial community sequence analysis. This\n is a C++ implementation of the Parsimonious Insertion algorithm.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 3 / 120","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_21460","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"parsnp","distribution":"debian","release":"sid","component":"main","version":"1.2","source":"parsnp","homepage":"http://harvest.readthedocs.org/en/latest/content/parsnp.html","description":"rapid core genome multi-alignment","long_description":" Parsnp was designed to align the core genome of hundreds to thousands of\n bacterial genomes within a few minutes to few hours. Input can be both\n draft assemblies and finished genomes, and output includes variant (SNP)\n calls, core genome phylogeny and multi-alignments. Parsnp leverages\n contextual information provided by multi-alignments surrounding SNP\n sites for filtration/cleaning, in addition to existing agents for\n recombination detection/filtration and phylogenetic reconstruction.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 2 / 54","doi":"10.1101/007351","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_21461","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"partitionfinder","distribution":"prospective","release":"vcs","component":"main","version":"2.0.0~pre9","source":"partitionfinder","homepage":"https://github.com/brettc/partitionfinder","description":"choses partitioning schemes and models of molecular evolution for sequence data","long_description":" PartitionFinder and PartitionFinderProtein are Python programs for\n simultaneously choosing partitioning schemes and models of molecular evolution\n for sequence data.  You can use them before running a phylogenetic analysis,\n in order to decide how to divide up your sequence data into separate blocks\n before analysis, and to simultaneously perform model selection on each of\n those blocks.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"patman","distribution":"debian","release":"sid","component":"main","version":"1.2.2","source":"patman","homepage":"https://bioinf.eva.mpg.de/patman/","description":"rapid alignment of short sequences to large databases","long_description":" Patman searches for short patterns in large DNA databases, allowing\n for approximate matches. It is optimized for searching for many small\n pattern at the same time, for example microarray probes.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 1 / 18","doi":"10.1093/bioinformatics/btn223","topics":null,"edam_scopes":null,"bio.agents":"patman","OMICagents":"OMICS_00997","SEQwiki":null,"SciCrunch":{"source":"patman","name":"SciCrunch","entry":"SCR_011821"},"RRID":null},{"package":"patristic","distribution":"prospective","release":"vcs","component":"main","version":"0.0.20100817","source":"patristic","homepage":"http://www.bioinformatics.org/patristic/","description":"Calculate patristic distances and comparing the components of genetic change","long_description":" Patristic overcomes some logistic barriers to analysing signals in\n sequences. In additional to calculating patristic distances, it provides\n plots for any combination of matrices, calculates commonly used\n statistics, allows data such as isolation dates to be entered and\n reorders matrices with matching species or gene labels. It will be used\n to analyse rates of mutation and substitutional saturation and the\n evolution of viruses.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1186/1471-2148-6-1","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"pbalign","distribution":"debian","release":"sid","component":"main","version":"0.3.2","source":"pbalign","homepage":"https://github.com/PacificBiosciences/pbalign","description":"map Pacific Biosciences reads to reference DNA sequences","long_description":" pbalign aligns PacBio reads to reference sequences, filters aligned\n reads according to user-specific filtering criteria, and converts the\n output to either the SAM format or PacBio Compare HDF5 (e.g., .cmp.h5)\n format.\n .\n This package is part of the SMRTAnalysis suite.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 5 / 40","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_18565","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libpbbam-dev","distribution":"debian","release":"sid","component":"main","version":"0.19.0","source":"pbbam","homepage":"http://pbbam.readthedocs.org/en/latest/index.html","description":"Pacific Biosciences binary alignment/map (BAM) library (headers)","long_description":" The BAM format is a binary, compressed, record-oriented container format\n for raw or aligned sequence reads. The associated SAM format is a text\n representation of the same data. The specifications for BAM/SAM are maintained\n by the SAM/BAM Format Specification Working Group.\n .\n PacBio-produced BAM files are fully compatible with the BAM specification,\n but makes use of the extensibility mechanisms of the BAM specification to\n encode PacBio-specific information. The pbbam library provides agents to\n work with these files\n .\n This package contains the library header files.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 7 / 24","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"pbbarcode","distribution":"debian","release":"sid","component":"main","version":"0.8.0","source":"pbbarcode","homepage":"https://github.com/PacificBiosciences/pbbarcode","description":"annotate PacBio sequencing reads with barcode information","long_description":" The pbbarcode package provides agents for annotating PacBio sequencing reads\n with barcode information. Typically, pbbarcode is called in context of a\n SMRTPipe workflow as opposed to directly on the command line, however, users\n are encouraged to utilize the command-line utility directly, as more options\n are available.\n .\n This package is part of the SMRTAnalysis suite.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 3 / 57","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_18566","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libpbcopper-dev","distribution":"debian","release":"sid","component":"main","version":"0.4.1","source":"pbcopper","homepage":"https://github.com/PacificBiosciences/pbcopper","description":"data structures, algorithms, and utilities for C++ applications -- header files","long_description":" pbcopper provides general agents for C++ applications. It is developed\n for use by applications of the Pacific Biosciences SMRT Analysis\n suite.\n .\n This package contains the header files and static library\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"pbdagcon","distribution":"debian","release":"sid","component":"main","version":"0.3+git20161121.0000000+ds","source":"pbdagcon","homepage":"https://github.com/PacificBiosciences/pbdagcon","description":"sequence consensus using directed acyclic graphs","long_description":" pbdagcon is a agent that implements DAGCon (Directed Acyclic Graph Consensus)\n which is a sequence consensus algorithm based on using directed acyclic\n graphs to encode multiple sequence alignment.\n .\n It uses the alignment information from blasr to align sequence reads to a\n \"backbone\" sequence. Based on the underlying alignment directed acyclic graph\n (DAG), it will be able to use the new information from the reads to find the\n discrepancies between the reads and the \"backbone\" sequences. A dynamic\n programming process is then applied to the DAG to find the optimum sequence\n of bases as the consensus. The new consensus can be used as a new backbone\n sequence to iteratively improve the consensus quality.\n .\n While the code is developed for processing PacBio(TM) raw sequence data,\n the algorithm can be used for general consensus purpose. Currently, it only\n takes FASTA input. For shorter read sequences, one might need to adjust the\n blasr alignment parameters to get the alignment string properly.\n .\n The code and the underlying graphical data structure have been used for some\n algorithm development prototyping including phasing reads and pre-assembly.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 4 / 46","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_18567","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"pbgenomicconsensus","distribution":"debian","release":"sid","component":"main","version":"2.3.2","source":"pbgenomicconsensus","homepage":"https://github.com/PacificBiosciences/GenomicConsensus","description":"Pacific Biosciences variant and consensus caller","long_description":" The GenomicConsensus package provides Quiver, Pacific Biosciences'\n flagship consensus and variant caller. Quiver is an algorithm that finds\n the maximum likelihood template sequence given PacBio reads of the template.\n These reads are modeled using a conditional random field approach that\n prescribes a probability to a read given a template sequence. In addition to\n the base sequence of each read, Quiver uses several additional quality value\n covariates that the base caller provides.\n .\n This package is part of the SMRTAnalysis suite\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 8 / 48","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_18568","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"pbh5agents","distribution":"debian","release":"sid","component":"main","version":"0.8.0+git20170929.58d54ff","source":"pbh5agents","homepage":"https://github.com/PacificBiosciences/pbh5agents","description":"agents for manipulating Pacific Biosciences HDF5 files","long_description":" This package provides functionality for manipulating and extracting data\n from cmp.h5 and bas.h5 files produced by the Pacific Biosciences sequencers.\n cmp.h5 files contain alignment information while bas.h5 files contain\n base-call information.\n .\n This package is part of the SMRTAnalysis suite.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 3 / 55","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_05138","SEQwiki":null,"SciCrunch":{"source":"pbh5agents","name":"SciCrunch","entry":"SCR_003027"},"RRID":null},{"package":"python-pbh5agents","distribution":"debian","release":"sid","component":"main","version":"0.8.0+git20170929.58d54ff","source":"pbh5agents","homepage":"https://github.com/PacificBiosciences/pbh5agents","description":"agents for manipulating Pacific Biosciences HDF5 files -- Python 2 library","long_description":" This package provides functionality for manipulating and extracting data\n from cmp.h5 and bas.h5 files produced by the Pacific Biosciences sequencers.\n cmp.h5 files contain alignment information while bas.h5 files contain\n base-call information.\n .\n pbh5agents is part of the SMRTAnalysis suite. This package provides the\n Python 2 backend library\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 3 / 63","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_05138","SEQwiki":null,"SciCrunch":{"source":"pbh5agents","name":"SciCrunch","entry":"SCR_003027"},"RRID":null},{"package":"libblasr-dev","distribution":"debian","release":"sid","component":"main","version":"5.3.1","source":"pbseqlib","homepage":"https://github.com/PacificBiosciences/blasr_libcpp","description":"agents for aligning PacBio reads to target sequences (development files)","long_description":" Blasr_libcpp is a library used by blasr and other executables such as\n samtoh5, loadPulses for analyzing PacBio sequences. This library contains\n three sub-libraries, including pbdata, hdf and alignment.\n .\n This package contains the header files and static library for the alignment\n sublibrary.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 1 / 31","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libpbdata-dev","distribution":"debian","release":"sid","component":"main","version":"5.3.1","source":"pbseqlib","homepage":"https://github.com/PacificBiosciences/blasr_libcpp","description":"agents for handling PacBio sequences (development files)","long_description":" Blasr_libcpp is a library used by blasr and other executables such as\n samtoh5, loadPulses for analyzing PacBio sequences. This library contains\n three sub-libraries, including pbdata, hdf and alignment.\n .\n This package contains the header files and static library for the pbdata\n sublibrary.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 4 / 31","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libpbihdf-dev","distribution":"debian","release":"sid","component":"main","version":"5.3.1","source":"pbseqlib","homepage":"https://github.com/PacificBiosciences/blasr_libcpp","description":"agents for handling PacBio hdf5 files (development files)","long_description":" Blasr_libcpp is a library used by blasr and other executables such as\n samtoh5, loadPulses for analyzing PacBio sequences. This library contains\n three sub-libraries, including pbdata, hdf and alignment.\n .\n This package contains the header files and static library for the hdf\n sublibrary.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 26","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libpbseq-dev","distribution":"debian","release":"sid","component":"main","version":"5.3.1","source":"pbseqlib","homepage":"https://github.com/PacificBiosciences/blasr_libcpp","description":"library for analyzing PacBio sequencing data (development files)","long_description":" Blasr_libcpp is a library used by blasr and other executables such as\n samtoh5, loadPulses for analyzing PacBio sequences. This library contains\n three sub-libraries, including pbdata, hdf and alignment.\n .\n This is a metapackage that depends on the pbseqlib component development files.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 25","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"pbsim","distribution":"debian","release":"sid","component":"main","version":"1.0.3+git20180330.e014b1d","source":"pbsim","homepage":"https://github.com/pfaucon/PBSIM-PacBio-Simulator","description":"simulator for PacBio sequencing reads","long_description":" PacBio DNA sequencers produce two types of characteristic reads: CCS\n (short and low error rate) and CLR (long and high error rate), both of\n which could be useful for de novo assembly of genomes. PBSIM simulates\n those PacBio reads from a reference sequence by using either a model-based\n or sampling-based simulation. Simulated reads are useful, for example, when\n developing or evaluating sequence assemblers targeted at PacBio data.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 3 / 61","doi":"10.1093/bioinformatics/bts649","topics":["Sequence analysis"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Sequence", "formats": ["FASTA"]}], "outputs": [{"data": "Sequence", "formats": ["FASTQ"]}], "function": ["Probabilistic sequence generation"]}],"bio.agents":"PBSIM","OMICagents":"OMICS_00253","SEQwiki":null,"SciCrunch":{"source":"pbsim","name":"SciCrunch","entry":"SCR_002512"},"RRID":null},{"package":"pbhoney","distribution":"debian","release":"sid","component":"main","version":"15.8.24","source":"pbsuite","homepage":"http://sourceforge.net/projects/pb-jelly","description":"genomic structural variation discovery","long_description":" PBHoney is an implementation of two variant-identification\n approaches designed to exploit the high mappability of long reads\n (i.e., greater than 10,000 bp). PBHoney considers both intra-read\n discordance and soft-clipped tails of long reads to identify\n structural variants.\n .\n PBHoney is part of the PBSuite.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 3 / 42","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_21465","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"pbjelly","distribution":"debian","release":"sid","component":"main","version":"15.8.24","source":"pbsuite","homepage":"http://sourceforge.net/projects/pb-jelly","description":"genome assembly upgrading agent","long_description":" PBJelly is a highly automated pipeline that aligns long sequencing\n reads (such as PacBio RS reads or long 454 reads in fasta format)\n to high-confidence draft assembles. PBJelly fills or reduces as\n many captured gaps as possible to produce upgraded draft genomes.\n .\n PBJelly is part of the PBSuite.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 3 / 43","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_21465","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"pbsuite","distribution":"debian","release":"sid","component":"main","version":"15.8.24","source":"pbsuite","homepage":"http://sourceforge.net/projects/pb-jelly","description":"software for Pacific Biosciences sequencing data","long_description":" The PBSuite contains two projects created for analysis of\n Pacific Biosciences long-read sequencing data.\n  * PBJelly - genome upgrading agent\n  * PBHoney - structural variation discovery\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 37","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_21465","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"pcma","distribution":"prospective","release":"vcs","component":"main","version":"2.0+20040626","source":"pcma","homepage":"http://prodata.swmed.edu/pcma/pcma.php","description":"fast and accurate multiple sequence alignment based on profile consistency","long_description":" PCMA (profile consistency multiple sequence alignment) is a progressive\n multiple sequence alignment program that combines two different\n alignment strategies. Highly similar sequences are aligned in a fast way\n as in ClustalW, forming pre-aligned groups. The T-Coffee strategy is\n applied to align the relatively divergent groups based on\n profile–profile comparison and consistency. The scoring function for\n local alignments of pre-aligned groups is based on a novel\n profile–profile comparison method that is a generalization of the\n PSI-BLAST approach to profile–sequence comparison. PCMA balances speed\n and accuracy in a flexible way and is suitable for aligning large\n numbers of sequences.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1093/bioinformatics/btg008","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_14997","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"pdb2pqr","distribution":"debian","release":"sid","component":"main","version":"2.1.1","source":"pdb2pqr","homepage":"https://www.cgl.ucsf.edu/chimera/docs/ContributedSoftware/apbs/pdb2pqr.html","description":"Preparation of protein structures for electrostatics calculations","long_description":" PDB2PQR is a Python software package that automates many of the common\n tasks of preparing structures for continuum electrostatics calculations.\n It thus provides a platform-independent utility for converting protein files\n in PDB format to PQR format. These tasks include:\n  * Adding a limited number of missing heavy atoms to biomolecular structures\n  * Determining side-chain pKas\n  * Placing missing hydrogens\n  * Optimizing the protein for favorable hydrogen bonding\n  * Assigning charge and radius parameters from a variety of force fields\n .\n This package also includes PropKa, a agent to modify the protonation state of\n protein structures in the Protein Data Bank (PDB) format to match a given pKa\n value. It can also be used to refine NMR structures, which often yield\n inaccurate pKa values for some residues.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"17 / 4 / 255","doi":"10.1093/nar/gkm276","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_14370","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"perlprimer","distribution":"debian","release":"sid","component":"main","version":"1.2.4","source":"perlprimer","homepage":"http://perlprimer.sourceforge.net","description":"Graphical design of primers for PCR","long_description":" PerlPrimer is a free, open-source GUI application written in Perl that designs\n primers for standard Polymerase Chain Reaction (PCR), bisulphite PCR,\n real-time PCR (QPCR) and sequencing. It aims to automate and simplify the\n process of primer design.\n .\n If operated online, the agent nicely communicates with the Ensembl\n project for further insights into the gene structure, i.e., allowing\n for taking the location of exons and introns into account for the design\n of the primers.  The sequences themselves can be retrieved, too.\n","interface":["x11"],"biology":["format:aln","nuceleic-acids","peptidic"],"fields":["biology","biology:molecular"],"use":["analysing"],"popcon":"19 / 21 / 117","doi":"10.1093/bioinformatics/bth254","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_02354","SEQwiki":null,"SciCrunch":{"source":"perlprimer","name":"SciCrunch","entry":"SCR_012038"},"RRID":null},{"package":"perm","distribution":"debian","release":"sid","component":"main","version":"0.4.0","source":"perm","homepage":"https://omicagents.com/perm-agent","description":"efficient mapping of short reads with periodic spaced seeds","long_description":" PerM is a software package which was designed to perform highly efficient\n genome scale alignments for hundreds of millions of short reads produced by\n the ABI SOLiD and Illumina sequencing platforms. Today PerM is capable of\n providing full sensitivity for alignments within 4 mismatches for 50bp SOLID\n reads and 9 mismatches for 100bp Illumina reads.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 3 / 114","doi":"10.1093/bioinformatics/btp486","topics":null,"edam_scopes":null,"bio.agents":"perm","OMICagents":"OMICS_00675","SEQwiki":null,"SciCrunch":{"source":"perm","name":"SciCrunch","entry":"SCR_004223"},"RRID":null},{"package":"pfagents","distribution":"debian","release":"sid","component":"main","version":"3","source":"pfagents","homepage":"http://web.expasy.org/pfagents/","description":"build and search protein and DNA generalized profiles","long_description":" The pfagents package contains all the software necessary to build protein\n and DNA generalized profiles and use them to scan and align sequences,\n and search databases.\n .\n File formats used by the pfagents\n  * Generalized profiles format and syntax.\n  * The multiple sequence alignment format (PSA).\n  * The extended header multiple sequence alignment format (XPSA).\n .\n Programs to build generalized profiles\n  pfmake\n    Build a profile from a multiple sequence alignment.\n  pfscale\n    Fit parameters of an extreme-value distribution to a profile score list.\n  pfw\n    Weight sequences of a multiple sequence alignment to correct for\n    sampling bias.\n .\n Programs to search with generalized profiles\n  pfsearch / pfsearchV3\n    Search a protein or DNA sequence library for sequence segments matching\n    a profile (V3 is the new version of this agent).\n  pfscan\n    Scan a protein or DNA sequence with a profile library\n .\n Conversion programs\n  psa2msa\n    Reformat PSA file to Pearson/Fasta multiple sequence alignment file.\n  ptof\n    Convert a protein profile into a frame-search profile to search DNA\n    sequences. To be used with 2ft.\n  2ft\n    Converts both strands of DNA into so-called interleaved\n    frame-translated DNA sequences to search with protein profiles. To be\n    used with ptof.\n  6ft\n    Translates all six reading frames of a double-stranded DNA sequence\n    into individual protein sequences.\n  pfgtop\n    Convert a profile in GCG format into PROSITE format.\n  pfhtop\n    Convert a HMMER1 ASCII-formatted HMM into an equivalent PROSITE profile.\n  ptoh\n    Converts a generalized profile into an approximately equivalent HMM\n    profile in HMMER1 format (can be read by the hmmconvert program from\n    the HMMER2 package).\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 0 / 21","doi":"10.1093/bib/3.3.265","topics":null,"edam_scopes":null,"bio.agents":"pfagents","OMICagents":"OMICS_29588","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"phast","distribution":"debian","release":"sid","component":"main","version":"1.5","source":"phast","homepage":"http://compgen.cshl.edu/phast/","description":"phylogenetic analysis with space/time models","long_description":" PHAST is a software package for comparative and evolutionary genomics.\n It consists of about half a dozen major programs, plus more than a dozen\n utilities for manipulating sequence alignments, phylogenetic trees, and\n genomic annotations. For the most part, PHAST focuses on two kinds of\n applications: the identification of novel functional elements, including\n protein-coding exons and evolutionarily conserved sequences; and\n statistical phylogenetic modeling, including estimation of model\n parameters, detection of signatures of selection, and reconstruction of\n ancestral sequences.\n .\n PHAST does not support phylogeny reconstruction or sequence alignment,\n and it is designed for use with DNA sequences only (see Comparison).\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 1 / 18","doi":"10.1093/bib/bbq072","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_01557","SEQwiki":null,"SciCrunch":{"source":"phast","name":"SciCrunch","entry":"SCR_003204"},"RRID":null},{"package":"phipack","distribution":"debian","release":"sid","component":"main","version":"0.0.20160614","source":"phipack","homepage":"http://www.maths.otago.ac.nz/~dbryant/software/phimanual.pdf","description":"PHI test and other tests of recombination","long_description":" The PhiPack software package implements a few tests for recombination\n and can produce refined incompatibility matrices as well. Specifically,\n PHIPack implements the 'Pairwise Homoplasy Index', Maximum Chi2 and the\n 'Neighbour Similarity Score'. The program Phi can be run to produce a\n p-value of recombination within a data set and the program profile can\n be run to determine regions exhibiting strongest evidence mosaicism.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 3 / 61","doi":"10.1534/genetics.105.048975","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_21684","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"phybin","distribution":"debian","release":"sid","component":"main","version":"0.3","source":"phybin","homepage":"http://www.cs.indiana.edu/~rrnewton/projects/phybin/","description":"binning/clustering newick trees by topology","long_description":" PhyBin is a simple command line agent that classifies a set of Newick\n tree files by their topology. The purpose of it is to take a large set\n of tree files and browse through the most common tree topologies.\n .\n It can do simple binning of identical trees or more complex clustering\n based on an all-to-all Robinson-Foulds distance matrix.\n .\n phybin produces output files that characterize the size and contents of\n each bin or cluster (including generating GraphViz-based visual\n representations of the tree topologies).\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 4 / 59","doi":"10.7717/peerj.187","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_21685","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"phylip","distribution":"debian","release":"sid","component":"main","version":"3.697","source":"phylip","homepage":"http://evolution.genetics.washington.edu/phylip.html","description":"package of programs for inferring phylogenies","long_description":" The PHYLogeny Inference Package is a package of programs for inferring\n phylogenies (evolutionary trees) from sequences.\n Methods that are available in the package include parsimony, distance\n matrix, and likelihood methods, including bootstrapping and consensus\n trees. Data types that can be handled include molecular sequences, gene\n frequencies, restriction sites, distance matrices, and 0/1 discrete\n characters.\n","interface":["commandline"],"biology":null,"fields":["biology","biology:bioinformatics"],"use":["analysing","comparing"],"popcon":"34 / 29 / 805","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"PHYLIP","OMICagents":"OMICS_04240","SEQwiki":null,"SciCrunch":{"source":"phylip","name":"SciCrunch","entry":"SCR_006244"},"RRID":null},{"package":"phylophlan","distribution":"prospective","release":"vcs","component":"contrib","version":"1.1.0","source":"phylophlan","homepage":"https://bitbucket.org/nsegata/phylophlan/wiki/Home","description":"microbial Tree of Life using 400 universal proteins","long_description":" PhyloPhlAn is a computational pipeline for reconstructing highly\n accurate and resolved phylogenetic trees based on whole-genome sequence\n information. The pipeline is scalable to thousands of genomes and uses\n the most conserved 400 proteins for extracting the phylogenetic signal.\n PhyloPhlAn also implements taxonomic curation, estimation, and insertion\n operations.\n .\n The main features of PhyloPhlAn are:\n  * completely automatic, as the user needs only to provide the\n    (unannotated) protein sequences of the input genomes (as multifasta\n    files of peptides - not nucleotides)\n  * very high topological accuracy and resolution because of the use of\n    up to 400 previously identified most conserved proteins\n  * the possibility of integrating new genomes in the already\n    reconstructed most comprehensive tree of life (3,171 microbial\n    genomes)\n  * taxonomy estimation for the newly inserted genomes\n  * taxonomic curation for the produced phylogenetic trees","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1038/ncomms3304","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"phyloviz-core","distribution":"prospective","release":"vcs","component":"main","version":"0.0.20111121","source":"phyloviz-core","homepage":"http://www.phyloviz.net","description":"phylogenetic inference and data visualization for sequence based typing methods","long_description":" Phyloviz allows the analysis of sequence-based typing methods that\n generate allelic profiles and their associated epidemiological data.\n .\n For representing the possible evolutionary relationships between\n strains identified by allelic profiles it uses the goeBURST algorithm, a\n refinement of eBURST algorithm proposed by Feil et al., and its\n expansion to generate a complete minimum spanning tree (MST).\n .\n Phyloviz is being developed in a modular way to allow its expansion\n with novel data analysis algorithms and new visualization modules.\n .\n Capabilities\n  * Modularity allows the creation of plugins to analyse different types of data\n  * Allows the visualization of data overlaid onto goeBURST and MST results\n  * Confidence assessment of each link in the graph\n  * Query the data and see the query results directly onto the graphs\n  * Search your data set using regular expressions to select what to display\n  * Export the results as images in various formats: eps, png, gif, pdf, etc","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1186/1471-2105-13-87","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"phyml","distribution":"debian","release":"sid","component":"main","version":"3.3.20180621","source":"phyml","homepage":"http://www.atgc-montpellier.fr/phyml","description":"Phylogenetic estimation using Maximum Likelihood","long_description":" PhyML is a software that estimates maximum likelihood phylogenies from\n alignments of nucleotide or amino acid sequences. It provides a wide\n range of options that were designed to facilitate standard phylogenetic\n analyses. The main strengths of PhyML lies in the large number of\n substitution models coupled to various options to search the space of\n phylogenetic tree topologies, going from very fast and efficient methods\n to slower but generally more accurate approaches. It also implements\n two methods to evaluate branch supports in a sound statistical framework\n (the non-parametric bootstrap and the approximate likelihood ratio test).\n .\n PhyML was designed to process moderate to large data sets. In theory,\n alignments with up to 4,000 sequences 2,000,000 character-long can\n be analyzed. In  practice however, the amount of memory required to process\n a data set is proportional of the product of the number of sequences by their\n length. Hence, a large number of sequences can only be processed provided\n that they are short. Also, PhyML can handle long sequences provided that\n they are not numerous. With most standard personal computers, the “comfort\n zone” for PhyML generally lies around 3 to 500 sequences less than 2,000\n character long.\n .\n This package also includes PhyTime.\n","interface":["commandline"],"biology":["peptidic"],"fields":["biology","biology:bioinformatics"],"use":["comparing","analysing"],"popcon":"23 / 6 / 405","doi":"10.1093/molbev/msq060","topics":null,"edam_scopes":null,"bio.agents":"PhyML","OMICagents":"OMICS_04241","SEQwiki":null,"SciCrunch":{"source":"phyml","name":"SciCrunch","entry":"SRC_014629"},"RRID":null},{"package":"physamp","distribution":"debian","release":"sid","component":"main","version":"1.1.0","source":"physamp","homepage":"https://jydu.github.io/physamp/","description":"sample sequence alignment corresponding to phylogeny","long_description":" The PhySamp package currently contains two programs: bppphysamp, which\n samples sequences according to their similarity, and bppalnoptim, which\n samples a sequence alignment by removing sequences in order to maximize\n the number of sites suitable for a given analysis. The bppalnoptim\n program has three running modes:\n  * Interactive: the user will be iteratively proposed a set of choices\n    for sequence removal, with their corresponding site gains. The\n    procedure stops when the user does not want to remove more sequences,\n    and the resulting filtered alignment is written.\n  * Automatic: the user enters an a priori criterion for stopping\n    the filtering procedure (for instance a minimum number of\n    sequences to keep).\n  * Diagnostic: this mode allows one to plot the trade-off curve, by\n    showing the site gain as a function of the number of removed\n    sequences.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 3 / 61","doi":"10.1186/s12859-015-0619-8","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_21686","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"phyutility","distribution":"debian","release":"sid","component":"main","version":"2.7.3","source":"phyutility","homepage":"http://github.com/blackrim/phyutility","description":"simple analyses or modifications on both phylogenetic trees and data matrices","long_description":" Phyutility (fyoo-til-i-te) is a command line program that performs\n simple analyses or modifications on both trees and data matrices.\n .\n Currently it performs the following functions (to suggest another\n feature, submit an Issue and use the label Type-Enhancement) :\n .\n Trees\n  * rerooting\n  * pruning\n  * type conversion\n  * consensus\n  * leaf stability\n  * lineage movement\n  * tree support\n .\n Data Matrices\n  * concatenate alignments\n  * genbank parsing\n  * trimming alignments\n  * search NCBI\n  * fetch NCBI\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 3 / 113","doi":"10.1093/bioinformatics/btm619","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_21687","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"phyx","distribution":"debian","release":"sid","component":"main","version":"0.999+ds","source":"phyx","homepage":"https://github.com/FePhyFoFum/phyx","description":"UNIX-style phylogenetic analyses on trees and sequences","long_description":" phyx provides a convenient, lightweight and inclusive agentkit consisting of\n programs spanning the wide breadth of programs utilized by researchers\n performing phylogenomic analyses. Modeled after Unix/GNU/Linux command\n line agents, individual programs perform a single task and operate on\n standard I/O streams. A result of this stream-centric approach is that, for\n most programs, only a single sequence or tree is in memory at any moment.\n Thus, large datasets can be processed with minimal memory requirements.\n phyx’s ever-growing complement of programs consists of over 35 programs\n focused on exploring, manipulating, analyzing and simulating phylogenetic\n objects (alignments, trees and MCMC logs). As with standard Unix command\n line agents, these programs can be piped (together with non-phyx agents),\n allowing the easy construction of efficient analytical pipelines.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 7 / 14","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_02387","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"picard-agents","distribution":"debian","release":"sid","component":"main","version":"2.18.25","source":"picard-agents","homepage":"http://broadinstitute.github.io/picard/","description":"Command line agents to manipulate SAM and BAM files","long_description":" SAM (Sequence Alignment/Map) format is a generic format for storing\n large nucleotide sequence alignments. Picard Agents includes these\n utilities to manipulate SAM and BAM files:\n  AddCommentsToBam                  FifoBuffer\n  AddOrReplaceReadGroups            FilterSamReads\n  BaitDesigner                      FilterVcf\n  BamIndexStats                     FixMateInformation\n  BamToBfq                          GatherBamFiles\n  BedToIntervalList                 GatherVcfs\n  BuildBamIndex                     GenotypeConcordance\n  CalculateHsMetrics                IlluminaBasecallsToFastq\n  CalculateReadGroupChecksum        IlluminaBasecallsToSam\n  CheckIlluminaDirectory            LiftOverIntervalList\n  CheckTerminatorBlock              LiftoverVcf\n  CleanSam                          MakeSitesOnlyVcf\n  CollectAlignmentSummaryMetrics    MarkDuplicates\n  CollectBaseDistributionByCycle    MarkDuplicatesWithMateCigar\n  CollectGcBiasMetrics              MarkIlluminaAdapters\n  CollectHiSeqXPfFailMetrics        MeanQualityByCycle\n  CollectIlluminaBasecallingMetrics MergeBamAlignment\n  CollectIlluminaLaneMetrics        MergeSamFiles\n  CollectInsertSizeMetrics          MergeVcfs\n  CollectJumpingLibraryMetrics      NormalizeFasta\n  CollectMultipleMetrics            PositionBasedDownsampleSam\n  CollectOxoGMetrics                QualityScoreDistribution\n  CollectQualityYieldMetrics        RenameSampleInVcf\n  CollectRawWgsMetrics              ReorderSam\n  CollectRnaSeqMetrics              ReplaceSamHeader\n  CollectRrbsMetrics                RevertOriginalBaseQualitiesAndAddMateCigar\n  CollectSequencingArtifactMetrics  RevertSam\n  CollectTargetedPcrMetrics         SamFormatConverter\n  CollectVariantCallingMetrics      SamToFastq\n  CollectWgsMetrics                 ScatterIntervalsByNs\n  CompareMetrics                    SortSam\n  CompareSAMs                       SortVcf\n  ConvertSequencingArtifactToOxoG   SplitSamByLibrary\n  CreateSequenceDictionary          SplitVcfs\n  DownsampleSam                     UpdateVcfSequenceDictionary\n  EstimateLibraryComplexity         ValidateSamFile\n  ExtractIlluminaBarcodes           VcfFormatConverter\n  ExtractSequences                  VcfToIntervalList\n  FastqToSam                        ViewSam\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"11 / 29 / 173","doi":null,"topics":["Sequencing","Document, record and content management"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Sequence", "formats": ["SAM", "BAM"]}], "outputs": [{"data": "Sequence", "formats": ["SAM", "BAM"]}, {"data": "Report", "formats": ["Textual format"]}], "function": ["Data handling", "Filtering", "Statistics and probability"]}],"bio.agents":"Picard_agents","OMICagents":"OMICS_01066","SEQwiki":null,"SciCrunch":{"source":"picard-agents","name":"SciCrunch","entry":"SCR_006525"},"RRID":null},{"package":"piler","distribution":"debian","release":"sid","component":"main","version":"0~20140707","source":"piler","homepage":"http://www.drive5.com/piler/","description":"genomic repeat analysis","long_description":" PILER (Parsimonious Inference of a Library of Elementary Repeats)\n searches a genome sequence for repetitive elements. It implements search\n algorithms that identify characteristic patterns of local alignments\n induced by certain classes of repeats.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 3 / 64","doi":"10.1093/bioinformatics/bti1003","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_07639","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"pilon","distribution":"debian","release":"sid","component":"main","version":"1.23","source":"pilon","homepage":"https://github.com/broadinstitute/pilon/wiki","description":"automated genome assembly improvement and variant detection agent","long_description":" Pilon is a software agent which can be used to:\n  * Automatically improve draft assemblies\n  * Find variation among strains, including large event detection\n Pilon requires as input a FASTA file of the genome along with one or more\n BAM files of reads aligned to the input FASTA file. Pilon uses read\n alignment analysis to identify inconsistencies between the input genome and\n the evidence in the reads. It then attempts to make improvements to the\n input genome, including:\n  * Single base differences\n  * Small indels\n  * Larger indel or block substitution events\n  * Gap filling\n  * Identification of local misassemblies, including optional opening\n    of new gaps\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 8 / 20","doi":"10.1371/journal.pone.0112963","topics":null,"edam_scopes":null,"bio.agents":"pilon","OMICagents":"OMICS_14553","SEQwiki":null,"SciCrunch":{"source":"pilon","name":"SciCrunch","entry":"SCR_014731"},"RRID":null},{"package":"pipasic","distribution":"prospective","release":"vcs","component":"main","version":"0.0.r15","source":"pipasic","homepage":"http://sourceforge.net/projects/pipasic/","description":"Protein Abundance Correction in Metaproteomic Data","long_description":" Metaproteomic analysis allows studying the interplay of organisms or\n functional groups and has become increasingly popular also for\n diagnostic purposes. However, difficulties arise due to the high\n sequence similarity between related organisms. Further, the state of\n conservation of proteins between species can be correlated with their\n expression level which can lead to significant bias in results and\n interpretation. These challenges are similar but not identical to the\n challenges arising in the analysis of metagenomic samples and require\n specific solutions.\n .\n pipasic (peptide intensity-weighted proteome abundance similarity\n correction) is a agent which corrects identification and spectral\n counting based quantification results using peptide similarity\n estimation and expression level weighting within a non-negative lasso\n framework. pipasic has distinct advantages over approaches only\n regarding unique peptides or aggregating results to the lowest common\n ancestor.","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 1","doi":"10.1093/bioinformatics/btu267","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"pirs","distribution":"debian","release":"sid","component":"main","version":"2.0.2","source":"pirs","homepage":"https://github.com/galaxy001/pirs","description":"Profile based Illumina pair-end Reads Simulator","long_description":" The program pIRS can be used for simulating Illumina PE reads, with a\n series of characters generated by Illumina sequencing platform, such as\n insert size distribution, sequencing error(substitution, insertion,\n deletion), quality score and GC content-coverage bias.\n .\n The insert size follows a normal distribution, so users should set the\n mean value and standard deviation. Usually the standard deviation is set\n as 1/20 of the mean value. The normal distribution by Box-Muller method\n is simulated.\n .\n The program simulates sequencing error, quality score and GC content-\n coverage bias according to the empirical distribution profile. Some\n default profiles counted from lots of real sequencing data are provided.\n .\n To simulate reads from diploid genome, users should simulate the diploid\n genome sequence firstly by setting the ratio of heterozygosis SNP,\n heterozygosis InDel and structure variation.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 3 / 56","doi":"10.1093/bioinformatics/bts187","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_07639","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"placnet","distribution":"debian","release":"sid","component":"main","version":"1.03","source":"placnet","homepage":"http://sourceforge.net/projects/placnet/","description":"Plasmid Constellation Network project","long_description":" Placnet is a new agent for plasmid analysis in NGS projects. Placnet is\n optimized to work with Illumina sequences but it also works with 454,\n Iontorrent or any of the actual sequence technologies.\n .\n The input of placnet is a set of contigs and one or more SAM files with\n the mapping of the reads against the contigs. Placnet obtains a set of\n files, easily opened on Cytoscape software or other network agents.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 3 / 63","doi":"10.1371/journal.pgen.1004766","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_11487","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"plasmidomics","distribution":"debian","release":"sid","component":"main","version":"0.2.0","source":"plasmidomics","homepage":"https://www.ira.cinvestav.mx/Investigaci%C3%B3n/Biotecnolog%C3%ADayBioqu%C3%ADmica/ProfesoresInvestigadores/DrRobertWinkler/Software/PlasmidDrawingProgramPlasmidomics02/tabid/778/language/en-US/Default.aspx","description":"draw plasmids and vector maps with PostScript graphics export","long_description":" Plasmidomics is written for easy drawing of plasmids and vector maps\n to use them in theses, presentations or other forms of publications. It\n natively supports PostScript as output format.\n","interface":["x11"],"biology":null,"fields":["biology","biology:molecular"],"use":["TODO"],"popcon":"10 / 3 / 97","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_21688","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"plasmidseeker","distribution":"debian","release":"sid","component":"main","version":"1.0","source":"plasmidseeker","homepage":"https://github.com/bioinfo-ut/PlasmidSeeker","description":"identification of known plasmids from whole-genome sequencing reads","long_description":" PlasmidSeeker is a k-mer based program for the identification of known\n plasmids from bacterial whole genome sequencing reads.\n .\n PlasmidSeeker that enables the detection of plasmids from bacterial WGS\n data without read assembly. The PlasmidSeeker algorithm is based on\n k-mers and uses k-mer abundance to distinguish between plasmid and\n bacterial sequences. The performance of PlasmidSeeker was tested on a set\n of simulated and real bacterial WGS samples, resulting in 100%\n sensitivity and 99.98% specificity.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 7 / 16","doi":"10.7717/peerj.4588","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_28371","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"plast","distribution":"debian","release":"sid","component":"main","version":"2.3.2","source":"plast","homepage":"https://plast.inria.fr/","description":"Parallel Local Sequence Alignment Search Agent","long_description":" PLAST is a fast, accurate and NGS scalable bank-to-bank sequence\n similarity search agent providing significant accelerations of seeds-\n based heuristic comparison methods, such as the Blast suite of\n algorithms.\n .\n Relying on unique software architecture, PLAST takes full advantage of\n recent multi-core personal computers without requiring any additional\n hardware devices.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 3 / 61","doi":"10.1186/1471-2105-10-329","topics":null,"edam_scopes":null,"bio.agents":"plast","OMICagents":"OMICS_06498","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"plato","distribution":"prospective","release":"vcs","component":"main","version":"2.0.0","source":"plato","homepage":"https://ritchielab.psu.edu/plato","description":"Analysis, translation, and organization of large-scale genetic data","long_description":" PLATO is an acronym for \"PLatform for the Analysis, Translation,\n and Organization of large-scale data\".  Recent technological advances\n enable the study of hundreds of thousands of human single-nucleotide\n polymorphisms at the population level. Because strategies for analyzing\n these data have not kept pace with the laboratory methods that generate\n the data, it is unlikely that these advances will immediately lead to\n an improved understanding of the genetic contribution to common human\n disease and drug response. Currently, no single analytical method\n allows us to extract all available information from a whole-genome\n association study. In fact, no single method can be optimal for all\n datasets, especially when the genetic architecture for diseases can\n vary substantially, as is certainly the case. Therefore, an integrative\n platform is needed to accommodate multiple analytical methods for\n analysis as we learn more about genetic architecture. As a result,\n we are developing a system for the analysis of genome-wide association\n data that will incorporate several analytical approaches as filters to\n allow a scientist to choose whatever analytical methods they wish to\n apply. PLATO (PLatform for the Analysis, Translation, and Organization\n of large-scale data) will incorporate a number of filters to select\n the important SNPs in a genome-wide association study.\n .\n Whole-genome Association Study Pipeline (WASP) has recently been\n absorbed into PLATO. WASP was designed to aid in retrieving, evaluating,\n formatting, and analyzing genotypic and clinical data from the latest\n large-scale genotyping studies. WASP implements a battery of quality\n control procedures to assess the data. Among the currently available\n procedures are the examination of marker and sample genotyping\n efficiency, allele frequency calculations, checks of Mendelian error\n (if applicable) and gender discrepancies (based on available chromosome X\n and Y genotypes), and tests of Hardy-Weinberg Equilibrium. Additionally,\n WASP can retrieve and format data for other software programs such as the\n Graphical Representation of Relationships (GRR) program, or STRUCTURE,\n and depending on the nature of the samples and the depth of examination\n the user desires to pursue. Beyond the quality control aspect of this\n application, WASP can perform standard tests of association using the\n Transmission Disequilibrium Test TDT for family-based datasets and the\n chi-square test of association for case-control datasets.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1142/9789814295291_0034","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"plink","distribution":"debian","release":"sid","component":"main","version":"1.07","source":"plink","homepage":"http://zzz.bwh.harvard.edu/plink/","description":"whole-genome association analysis agentset","long_description":" plink expects as input the data from SNP (single\n nucleotide polymorphism) chips of many individuals\n and their phenotypical description of a disease.\n It finds associations of single or pairs of DNA\n variations with a phenotype and can retrieve\n SNP annotation from an online source.\n .\n SNPs can evaluated individually or as pairs for their\n association with the disease phenotypes. The joint\n investigation of copy number variations is supported.\n A variety of statistical tests have been implemented.\n .\n Please note: The executable was renamed to plink1\n because of a name clash.  Please read more about this\n in /usr/share/doc/plink/README.Debian.\n","interface":["commandline"],"biology":null,"fields":["biology:bioinformatics","biology"],"use":null,"popcon":"18 / 2 / 130","doi":"10.1086/519795","topics":null,"edam_scopes":null,"bio.agents":"PLINK","OMICagents":"OMICS_00206","SEQwiki":null,"SciCrunch":{"source":"plink","name":"SciCrunch","entry":"SCR_001757"},"RRID":null},{"package":"plink1.9","distribution":"debian","release":"sid","component":"main","version":"1.90~b6.6-181012","source":"plink1.9","homepage":"https://www.cog-genomics.org/plink/1.9/","description":"whole-genome association analysis agentset","long_description":" plink expects as input the data from SNP (single nucleotide polymorphism)\n chips of many individuals and their phenotypical description of a disease.\n It finds associations of single or pairs of DNA variations with a phenotype\n and can retrieve SNP annotation from an online source.\n .\n SNPs can evaluated individually or as pairs for their association with the\n disease phenotypes. The joint investigation of copy number variations is\n supported. A variety of statistical tests have been implemented.\n .\n plink1.9 is a comprehensive update of plink with new algorithms and new\n methods, faster and less memory consumer than the first plink.\n .\n Please note: The executable was renamed to plink1.9\n because of a name clash.  Please read more about this\n in /usr/share/doc/plink1.9/README.Debian.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"14 / 2 / 77","doi":"10.1186/s13742-015-0047-8","topics":null,"edam_scopes":null,"bio.agents":"PLINK","OMICagents":"OMICS_00206","SEQwiki":null,"SciCrunch":{"source":"plink1.9","name":"SciCrunch","entry":"SCR_001757"},"RRID":null},{"package":"plip","distribution":"debian","release":"sid","component":"main","version":"1.4.3~b","source":"plip","homepage":"https://projects.biotec.tu-dresden.de/plip-web/plip/","description":"fully automated protein-ligand interaction profiler","long_description":" The Protein-Ligand Interaction Profiler (PLIP) is a agent to analyze\n and visualize protein-ligand interactions in PDB files.\n .\n Features include:\n  * Detection of eight different types of noncovalent interactions\n  * Automatic detection of relevant ligands in a PDB file\n  * Direct download of PDB structures from wwPDB server if valid\n    PDB ID is given\n  * Processing of custom PDB files containing protein-ligand complexes\n    (e.g. from docking)\n  * No need for special preparation of a PDB file, works out of the box\n  * Atom-level interaction reports in rST and XML formats for easy parsing\n  * Generation of PyMOL session files (.pse) for each pairing, enabling easy\n    preparation of images for publications and talks\n  * Rendering of preview image for each ligand and its interactions\n    with the protein\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 2 / 63","doi":"10.1093/nar/gkv315","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_08028","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"poa","distribution":"debian","release":"sid","component":"main","version":"2.0+20060928","source":"poa","homepage":"http://poamsa.sourceforge.net/","description":"Partial Order Alignment for multiple sequence alignment","long_description":" POA is Partial Order Alignment, a fast program for multiple sequence\n alignment (MSA) in bioinformatics. Its advantages are speed,\n scalability, sensitivity, and the superior ability to handle branching\n / indels in the alignment. Partial order alignment is an approach to\n MSA, which can be combined with existing methods such as progressive\n alignment. POA optimally aligns a pair of MSAs and which therefore can\n be applied directly to progressive alignment methods such as CLUSTAL.\n For large alignments, Progressive POA is 10-30 times faster than\n CLUSTALW.\n","interface":["commandline"],"biology":null,"fields":["biology","biology:bioinformatics"],"use":null,"popcon":"18 / 5 / 363","doi":"10.1093/bioinformatics/bth126","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_14254","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"populations","distribution":"debian","release":"sid","component":"main","version":"1.2.33+svn0120106","source":"populations","homepage":"http://www.bioinformatics.org/~tryphon/populations/","description":"population genetic software","long_description":" Populations is a population genetic software. It computes genetic\n distances between populations or individuals. It builds phylogenetic\n trees (NJ or UPGMA) with bootstrap values.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 6 / 87","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_29592","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"porechop","distribution":"debian","release":"sid","component":"main","version":"0.2.4","source":"porechop","homepage":"https://rrwick.github.io/Porechop","description":"adapter trimmer for Oxford Nanopore reads","long_description":" Porechop is a agent for finding and removing adapters from Oxford\n Nanopore reads. Adapters on the ends of reads are trimmed off, and\n when a read has an adapter in its middle, it is treated as chimeric\n and chopped into separate reads. Porechop performs thorough\n alignments to effectively find adapters, even at low sequence\n identity.\n Porechop also supports demultiplexing of Nanopore reads that were\n barcoded with the Native Barcoding Kit, PCR Barcoding Kit or Rapid\n Barcoding Kit.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 7 / 15","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_17306","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"poreagents","distribution":"debian","release":"sid","component":"main","version":"0.6.0","source":"poreagents","homepage":"http://poreagents.readthedocs.org","description":"agentkit for nanopore nucleotide sequencing data","long_description":" poreagents is a flexible agentkit for exploring datasets generated by nanopore\n sequencing devices from MinION for the purposes of quality control and\n downstream analysis. Poreagents operates directly on the native FAST5 (a\n variant of the HDF5 standard) file format produced by ONT and provides a\n wealth of format conversion utilities and data exploration and visualization\n agents.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 2 / 58","doi":"10.1093/bioinformatics/btu555","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_07584","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"prank","distribution":"debian","release":"sid","component":"main","version":"0.0.170427","source":"prank","homepage":"http://wasabiapp.org/software/prank/","description":"Probabilistic Alignment Kit for DNA, codon and amino-acid sequences","long_description":" PRANK is a probabilistic multiple alignment program for DNA, codon\n and amino-acid sequences. It's based on a novel algorithm that treats\n insertions correctly and avoids over-estimation of the number of\n deletion events. In addition, PRANK borrows ideas from maximum\n likelihood methods used in phylogenetics and correctly takes into\n account the evolutionary distances between sequences. Lastly, PRANK\n allows for defining a potential structure for sequences to be aligned\n and then, simultaneously with the alignment, predicts the locations\n of structural units in the sequences.\n .\n PRANK is a command-line program for UNIX-style environments but the\n same sequence alignment engine is implemented in the graphical\n program PRANKSTER. In addition to providing a user-friendly interface\n to those not familiar with Unix systems, PRANKSTER is an alignment\n browser for alignments saved in the HSAML format. The novel format\n allows for storing all the information generated by the aligner and\n the alignment browser is a convenient way to analyse and manipulate\n the data.\n .\n PRANK aims at an evolutionarily correct sequence alignment and often\n the result looks different from ones generated with other alignment\n methods. There are, however, cases where the different look is caused\n by violations of the method's assumptions. To understand why things\n may go wrong and how to avoid that, read this explanation of\n differences between PRANK and traditional progressive alignment\n methods.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"20 / 5 / 353","doi":"10.1007/978-1-62703-646-7_10","topics":null,"edam_scopes":null,"bio.agents":"prank","OMICagents":"OMICS_12425","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"predictnls","distribution":"debian","release":"sid","component":"main","version":"1.0.20","source":"predictnls","homepage":"http://rostlab.org/services/predictNLS/","description":"prediction and analysis of protein nuclear localization signals","long_description":" predictnls is a method for the prediction and analysis of protein nuclear\n localization signals (NLS).  In addition to reporting the positions of\n NLSs found, predictnls also gives short statistics.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 3 / 118","doi":"10.1093/embo-reports/kvd092","topics":null,"edam_scopes":null,"bio.agents":"predictnls","OMICagents":"OMICS_01633","SEQwiki":null,"SciCrunch":{"source":"predictnls","name":"SciCrunch","entry":"SCR_008553"},"RRID":null},{"package":"predictprotein","distribution":"debian","release":"sid","component":"main","version":"1.1.08","source":"predictprotein","homepage":"http://www.predictprotein.org","description":"suite of protein sequence analysis agents","long_description":" PredictProtein is a sequence analysis suite providing prediction of protein\n structure and function.\n .\n PredictProtein takes a protein sequence as input and provides the following\n per-residue, or whole protein annotations:\n  * secondary structure\n  * solvent accessibility\n  * multiple sequence alignments\n  * PROSITE sequence motifs\n  * low-complexity regions\n  * nuclear localisation signals\n  * regions lacking regular structure (NORS)\n  * unstructured loops\n  * transmembrane helices\n  * transmembrane beta barrels\n  * coiled-coil regions\n  * disulfide-bonds\n  * disordered regions\n  * B-value flexibility\n  * protein-protein interaction sites\n  * Gene Ontology terms\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 3 / 65","doi":"10.1093/nar/gkh377","topics":null,"edam_scopes":null,"bio.agents":"predictprotein","OMICagents":"OMICS_07135","SEQwiki":null,"SciCrunch":{"source":"predictprotein","name":"SciCrunch","entry":"SCR_002803"},"RRID":null},{"package":"python3-presto","distribution":"debian","release":"sid","component":"main","version":"0.5.10","source":"presto","homepage":"https://presto.readthedocs.io","description":"agentkit for processing B and T cell sequences","long_description":" pRESTO is a agentkit for processing raw reads from high-throughput\n sequencing of B cell and T cell repertoires.\n .\n Dramatic improvements in high-throughput sequencing technologies now\n enable large-scale characterization of lymphocyte repertoires, defined\n as the collection of trans-membrane antigen-receptor proteins located on\n the surface of B cells and T cells. The REpertoire Sequencing TOolkit\n (pRESTO) is composed of a suite of utilities to handle all stages\n of sequence processing prior to germline segment assignment. pRESTO\n is designed to handle either single reads or paired-end reads. It\n includes features for quality control, primer masking, annotation of\n reads with sequence embedded barcodes, generation of unique molecular\n identifier (UMI) consensus sequences, assembly of paired-end reads and\n identification of duplicate sequences. Numerous options for sequence\n sorting, sampling and conversion operations are also included.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 7 / 13","doi":"10.1093/bioinformatics/btu138","topics":null,"edam_scopes":null,"bio.agents":"pRESTO","OMICagents":"OMICS_03443","SEQwiki":null,"SciCrunch":{"source":"presto","name":"SciCrunch","entry":"SCR_013285"},"RRID":null},{"package":"prime-phylo","distribution":"debian","release":"sid","component":"main","version":"1.0.11","source":"prime-phylo","homepage":"http://prime.sbc.su.se","description":"bayesian estimation of gene trees taking the species tree into account","long_description":" PrIME (Probabilistic Integrated Models of Evolution) is a package\n supporting inference of evolutionary parameters in a Bayesian framework\n using Markov chain Monte Carlo simulation. A distinguishing feature of\n PrIME is that the species tree is taken into account when analyzing gene\n trees.\n .\n The input data to PrIME is a multiple sequence alignment in FASTA format\n and the output data contains trees in Newick format.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 2 / 102","doi":"10.1073/pnas.0806251106","topics":null,"edam_scopes":null,"bio.agents":"PrIME","OMICagents":"OMICS_29591","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"primer3","distribution":"debian","release":"sid","component":"main","version":"2.4.0","source":"primer3","homepage":"http://primer3.sourceforge.net","description":"agent to design flanking oligo nucleotides for DNA amplification","long_description":" Primer3 picks primers for Polymerase Chain Reactions (PCRs), considering as\n criteria oligonucleotide melting temperature, size, GC content and\n primer-dimer possibilities, PCR product size, positional constraints within\n the source sequence, and miscellaneous other constraints. All of these\n criteria are user-specifiable as constraints, and some are specifiable as\n terms in an objective function that characterizes an optimal primer pair.\n","interface":["commandline"],"biology":null,"fields":["biology","biology:bioinformatics"],"use":null,"popcon":"33 / 30 / 988","doi":"10.1385/1-59259-192-2:365","topics":null,"edam_scopes":null,"bio.agents":"primer3","OMICagents":"OMICS_02325","SEQwiki":null,"SciCrunch":{"source":"primer3","name":"SciCrunch","entry":"SCR_003139"},"RRID":null},{"package":"proalign","distribution":"debian","release":"sid","component":"main","version":"0.603","source":"proalign","homepage":"http://ueg.ulb.ac.be/ProAlign/","description":"Probabilistic multiple alignment program","long_description":" ProAlign performs probabilistic sequence alignments using hidden Markov\n models (HMM). It includes a graphical interface (GUI) allowing to (i)\n perform alignments of nucleotide or amino-acid sequences, (ii) view the\n quality of solutions, (iii) filter the unreliable alignment regions and\n (iv) export alignments to other software.\n .\n ProAlign uses a progressive method, such that multiple alignment is\n created stepwise by performing pairwise alignments in the nodes of a\n guide tree. Sequences are described with vectors of character\n probabilities, and each pairwise alignment reconstructs the ancestral\n (parent) sequence by computing the probabilities of different\n characters according to an evolutionary model.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 3 / 71","doi":"10.1093/bioinformatics/btg193","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_21691","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"probabel","distribution":"debian","release":"sid","component":"main","version":"0.5.0","source":"probabel","homepage":"http://www.genabel.org","description":"Agentset for Genome-Wide Association Analysis","long_description":" The ProbABEL package is part of the GenABEL project for analysis of genome-wide\n data. ProbABEL is used to run GWAS. Using files in filevector/DatABEL format\n even allows for running GWAS on computers with only a few GB of RAM.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 14 / 109","doi":"10.1186/1471-2105-11-134","topics":null,"edam_scopes":null,"bio.agents":"GENABEL","OMICagents":"OMICS_00234","SEQwiki":null,"SciCrunch":{"source":"probabel","name":"SciCrunch","entry":"SCR_001842"},"RRID":null},{"package":"probalign","distribution":"debian","release":"sid","component":"main","version":"1.4","source":"probalign","homepage":"http://probalign.njit.edu/standalone.html","description":"multiple sequence alignment using partition function posterior probabilities","long_description":" Probalign uses partition function posterior probability estimates to\n compute maximum expected accuracy multiple sequence alignments. It\n performs statistically significantly better than the leading alignment\n programs Probcons v1.1, MAFFT v5.851, and MUSCLE v3.6 on BAliBASE 3.0,\n HOMSTRAD, and OXBENCH benchmarks. Probalign improvements are largest on\n datasets containing N/C terminal extensions and on datasets with long\n and heterogeneous length sequences. On heteregeneous length datasets\n containing repeats Probalign alignment accuracy is 10% and 15% higher\n than the other three methods when standard deviation of length is at\n least 300 and 400.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"16 / 6 / 333","doi":"10.1093/bioinformatics/btl472","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_00985","SEQwiki":null,"SciCrunch":{"source":"probalign","name":"SciCrunch","entry":"SCR_013332"},"RRID":null},{"package":"probcons","distribution":"debian","release":"sid","component":"main","version":"1.12","source":"probcons","homepage":"http://probcons.stanford.edu/","description":"PROBabilistic CONSistency-based multiple sequence alignment","long_description":" Agent for generating multiple alignments of protein sequences. Using a\n combination of probabilistic modeling and consistency-based alignment\n techniques, PROBCONS has achieved the highest accuracies of all alignment\n methods to date. On the BAliBASE benchmark alignment database, alignments\n produced by PROBCONS show statistically significant improvement over current\n programs, containing an average of 7% more correctly aligned columns than\n those of T-Coffee, 11% more correctly aligned columns than those of CLUSTAL W,\n and 14% more correctly aligned columns than those of DIALIGN.\n","interface":["commandline"],"biology":null,"fields":["biology","biology:bioinformatics"],"use":["comparing"],"popcon":"18 / 5 / 373","doi":"10.1101/gr.2821705","topics":null,"edam_scopes":null,"bio.agents":"probcons","OMICagents":"OMICS_00986","SEQwiki":null,"SciCrunch":{"source":"probcons","name":"SciCrunch","entry":"SCR_011813"},"RRID":null},{"package":"proda","distribution":"debian","release":"sid","component":"main","version":"1.0","source":"proda","homepage":"http://proda.stanford.edu/","description":"multiple alignment of protein sequences","long_description":" ProDA is a system for automated detection and alignment of homologous\n regions in collections of proteins with arbitrary domain architectures.\n Given an input set of unaligned sequences, ProDA identifies all\n homologous regions appearing in one or more sequences, and returns a\n collection of local multiple alignments for these regions.\n","interface":["commandline"],"biology":["nuceleic-acids","peptidic"],"fields":["biology","biology:bioinformatics"],"use":["analysing","comparing"],"popcon":"18 / 5 / 358","doi":"10.1093/nar/gkl511","topics":null,"edam_scopes":null,"bio.agents":"ProDA","OMICagents":"OMICS_21692","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"prodigal","distribution":"debian","release":"sid","component":"main","version":"2.6.3","source":"prodigal","homepage":"http://prodigal.ornl.gov/","description":"Microbial (bacterial and archaeal) gene finding program","long_description":" Prodigal (Prokaryotic Dynamic Programming Genefinding Algorithm) is a\n microbial (bacterial and archaeal) gene finding program developed at\n Oak Ridge National Laboratory and the University of Tennessee.\n Key features of Prodigal include:\n .\n Speed: Prodigal is an extremely fast gene recognition agent\n (written in very vanilla C). It can analyze an entire microbial genome\n in 30 seconds or less.\n .\n Accuracy: Prodigal is a highly accurate gene finder.\n It correctly locates the 3' end of every gene in the experimentally verified\n Ecogene data set (except those containing introns).\n It possesses a very sophisticated ribosomal binding site scoring system that\n enables it to locate the translation initiation site with great accuracy\n (96% of the 5' ends in the Ecogene data set are located correctly).\n .\n Specificity: Prodigal's false positive rate compares favorably with other\n gene identification programs, and usually falls under 5%.\n .\n GC-Content Indifferent: Prodigal performs well even in high GC genomes,\n with over a 90% perfect match (5'+3') to the Pseudomonas aeruginosa curated\n annotations.\n .\n Metagenomic Version: Prodigal can run in metagenomic mode and analyze\n sequences even when the organism is unknown.\n .\n Ease of Use: Prodigal can be run in one step on a single genomic sequence\n or on a draft genome containing many sequences. It does not need to be\n supplied with any knowledge of the organism, as it learns all the properties\n it needs to on its own.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"12 / 4 / 126","doi":"10.1186/1471-2105-11-119","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_01493","SEQwiki":null,"SciCrunch":{"source":"prodigal","name":"SciCrunch","entry":"SCR_011936"},"RRID":null},{"package":"profbval","distribution":"debian","release":"sid","component":"main","version":"1.0.22","source":"profbval","homepage":"https://www.rostlab.org/owiki/index.php/PROFbval","description":"predictor of flexible/rigid protein residues from sequence","long_description":" PROFbval can be useful for both protein structure and\n function predictions. For instance, a biologist can locate potentially\n antigenic determinants by identifying the most flexible residues on the\n protein surface. Additionally, a crystallographer can locate residues that\n potentially have high experimental B-values.\n .\n PROFbval takes the following input, further described on profbval(1):\n  * a protein sequence in a FASTA file\n  * secondary structure and solvent accessibility prediction by prof(1)\n  * an HSSP file\n .\n Background: the mobility of a given residue on the protein surface is related\n to its functional role.\n Therefore, identification of extremely rigid or flexible\n residues on the protein surface is helpful for identifying functionally\n important residues in proteins. A common measure of atom mobility in proteins\n is B-value data from x-ray crystallography structures. PROFbval is the first\n agent to predict normalized backbone B-values from amino-acid sequence.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 3 / 117","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_09791","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"profisis","distribution":"debian","release":"sid","component":"main","version":"1.0.11","source":"profisis","homepage":"https://rostlab.org/owiki/index.php/PROFisis","description":"prediction of protein-protein interaction sites from sequence","long_description":" Profisis (ISIS) identifies interacting protein residues in protein-protein\n interfaces from sequence alone.\n .\n The strongest predictions of the method reached over 90% accuracy in a\n cross-validation experiment.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 3 / 116","doi":"10.1093/bioinformatics/btl303","topics":null,"edam_scopes":null,"bio.agents":"profisis","OMICagents":"OMICS_13706","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"profit","distribution":"prospective","release":"vcs","component":"non-free","version":"3.1","source":"profit","homepage":"http://www.bioinf.org.uk/software/profit/","description":"Protein structure alignment","long_description":" ProFit is designed to be the ultimate protein least squares fitting\n program. It has many features including flexible specification of\n fitting zones and atoms, calculation of RMS over different zones or\n atoms, RMS-by-residue calculation, on-line help facility, etc.\n .\n A symbolic link is provided to have the binary name back to how\n it is historically correct.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"profnet-bval","distribution":"debian","release":"sid","component":"main","version":"1.0.22","source":"profnet","homepage":"http://www.predictprotein.org/","description":"neural network architecture for profbval","long_description":" Profnet is a component of the prediction methods that make up the\n Predict Protein service by the lab of Burkhard Rost. It provides the neural\n network component to a variety of predictors that perform protein feature\n prediction directly from sequence.  This neural network implementation has\n to be compiled for every different network architecture.\n .\n This package contains the neural network architecture for profbval.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 3 / 122","doi":"10.1093/bioinformatics/btl032","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_09791","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"profnet-chop","distribution":"debian","release":"sid","component":"main","version":"1.0.22","source":"profnet","homepage":"http://www.predictprotein.org/","description":"neural network architecture for profchop","long_description":" Profnet is a component of the prediction methods that make up the\n Predict Protein service by the lab of Burkhard Rost. It provides the neural\n network component to a variety of predictors that perform protein feature\n prediction directly from sequence.  This neural network implementation has\n to be compiled for every different network architecture.\n .\n This package contains the neural network architecture for profchop.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 3 / 80","doi":"10.1093/bioinformatics/btl032","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_09791","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"profnet-con","distribution":"debian","release":"sid","component":"main","version":"1.0.22","source":"profnet","homepage":"http://www.predictprotein.org/","description":"neural network architecture for profcon","long_description":" Profnet is a component of the prediction methods that make up the\n Predict Protein service by the lab of Burkhard Rost. It provides the neural\n network component to a variety of predictors that perform protein feature\n prediction directly from sequence.  This neural network implementation has\n to be compiled for every different network architecture.\n .\n This package contains the neural network architecture for profcon.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 3 / 81","doi":"10.1093/bioinformatics/btl032","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_09791","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"profnet-isis","distribution":"debian","release":"sid","component":"main","version":"1.0.22","source":"profnet","homepage":"http://www.predictprotein.org/","description":"neural network architecture for profisis","long_description":" Profnet is a component of the prediction methods that make up the\n Predict Protein service by the lab of Burkhard Rost. It provides the neural\n network component to a variety of predictors that perform protein feature\n prediction directly from sequence.  This neural network implementation has\n to be compiled for every different network architecture.\n .\n This package contains the neural network architecture for profisis.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 3 / 120","doi":"10.1093/bioinformatics/btl032","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_09791","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"profnet-md","distribution":"debian","release":"sid","component":"main","version":"1.0.22","source":"profnet","homepage":"http://www.predictprotein.org/","description":"neural network architecture for metadisorder","long_description":" Profnet is a component of the prediction methods that make up the\n Predict Protein service by the lab of Burkhard Rost. It provides the neural\n network component to a variety of predictors that perform protein feature\n prediction directly from sequence.  This neural network implementation has\n to be compiled for every different network architecture.\n .\n This package contains the neural network architecture for metadisorder.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 3 / 81","doi":"10.1093/bioinformatics/btl032","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_09791","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"profnet-norsnet","distribution":"debian","release":"sid","component":"main","version":"1.0.22","source":"profnet","homepage":"http://www.predictprotein.org/","description":"neural network architecture for norsnet","long_description":" Profnet is a component of the prediction methods that make up the\n Predict Protein service by the lab of Burkhard Rost. It provides the neural\n network component to a variety of predictors that perform protein feature\n prediction directly from sequence.  This neural network implementation has\n to be compiled for every different network architecture.\n .\n This package contains the neural network architecture for norsnet.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 3 / 120","doi":"10.1093/bioinformatics/btl032","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_09791","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"profnet-prof","distribution":"debian","release":"sid","component":"main","version":"1.0.22","source":"profnet","homepage":"http://www.predictprotein.org/","description":"neural network architecture for profacc","long_description":" Profnet is a component of the prediction methods that make up the\n Predict Protein service by the lab of Burkhard Rost. It provides the neural\n network component to a variety of predictors that perform protein feature\n prediction directly from sequence.  This neural network implementation has\n to be compiled for every different network architecture.\n .\n This package contains the neural network architecture for profsec and profacc.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"13 / 3 / 129","doi":"10.1093/bioinformatics/btl032","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_09791","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"profnet-snapfun","distribution":"debian","release":"sid","component":"main","version":"1.0.22","source":"profnet","homepage":"http://www.predictprotein.org/","description":"neural network architecture for snapfun","long_description":" Profnet is a component of the prediction methods that make up the\n Predict Protein service by the lab of Burkhard Rost. It provides the neural\n network component to a variety of predictors that perform protein feature\n prediction directly from sequence.  This neural network implementation has\n to be compiled for every different network architecture.\n .\n This package contains the neural network architecture for snapfun.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 3 / 81","doi":"10.1093/bioinformatics/btl032","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_09791","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"profphd-net","distribution":"debian","release":"sid","component":"main","version":"1.0.22","source":"profnet","homepage":"http://www.predictprotein.org/","description":"neural network architecture for profphd","long_description":" Profnet is a component of the prediction methods that make up the\n Predict Protein service by the lab of Burkhard Rost. It provides the neural\n network component to a variety of predictors that perform protein feature\n prediction directly from sequence.  This neural network implementation has\n to be compiled for every different network architecture.\n .\n This package contains the neural network architecture for profphd.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"13 / 3 / 130","doi":"10.1093/bioinformatics/btl032","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_09791","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"profphd","distribution":"debian","release":"sid","component":"main","version":"1.0.42","source":"profphd","homepage":"http://predictprotein.org/","description":"secondary structure and solvent accessibility predictor","long_description":" This package provides prof(1), the protein secondary structure, accessibility\n and transmembrane helix predictor from Burkhard Rost.  Prediction is either\n done from protein sequence alone or from an alignment - the latter should be\n used for optimal performance.\n .\n How well does prof(1) perform?\n .\n  * Secondary structure is predicted at an expected average accuracy > 72% for\n    the three states helix, strand and loop.\n .\n  * Solvent accessibility is predicted at a correlation coefficient\n    (correlation between experimentally observed and predicted relative\n    solvent accessibility) of 0.54\n .\n  * Transmembrane helix prediction has an expected per-residue accuracy of\n    about 95%.  The number of false positives, i.e., transmembrane helices\n    predicted in globular proteins, is about 2%.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"12 / 3 / 127","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"profphd-utils","distribution":"debian","release":"sid","component":"main","version":"1.0.10","source":"profphd-utils","homepage":"http://www.rostlab.org/","description":"profphd helper utilities convert_seq and filter_hssp","long_description":" The package provides the following binary utilities: convert_seq, filter_hssp.\n These are used by prof from the profphd package: a secondary structure,\n accessibility and transmembrane helix predictor from Burkhard Rost.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"13 / 3 / 130","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"proftmb","distribution":"debian","release":"sid","component":"main","version":"1.1.12","source":"proftmb","homepage":"http://rostlab.org/","description":"per-residue prediction of bacterial transmembrane beta barrels","long_description":" proftmb predicts transmembrane beta-barrel (TMB) proteins in Gram-negative\n bacteria.\n .\n For each query protein, proftmb provides both a Z-value indicating that the\n protein actually contains a membrane barrel, and a four-state per-residue\n labeling of upward- and downward-facing strands, periplasmic hairpins and\n extracellular loops.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"10 / 3 / 91","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"proftmb","OMICagents":"OMICS_16019","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"progressivemauve","distribution":"debian","release":"sid","component":"main","version":"1.2.0+4713","source":"progressivemauve","homepage":"http://darlinglab.org/mauve/user-guide/mauvealigner.html","description":"multiple genome alignment algorithms","long_description":" The mauveAligner and progressiveMauve alignment algorithms have been\n implemented as command-line programs included with the downloadable Mauve\n software.  When run from the command-line, these programs provide options\n not yet available in the graphical interface.\n .\n Mauve is a system for efficiently constructing multiple genome alignments\n in the presence of large-scale evolutionary events such as rearrangement\n and inversion. Multiple genome alignment provides a basis for research\n into comparative genomics and the study of evolutionary dynamics.  Aligning\n whole genomes is a fundamentally different problem than aligning short\n sequences.\n .\n Mauve has been developed with the idea that a multiple genome aligner\n should require only modest computational resources. It employs algorithmic\n techniques that scale well in the amount of sequence being aligned. For\n example, a pair of Y. pestis genomes can be aligned in under a minute,\n while a group of 9 divergent Enterobacterial genomes can be aligned in\n a few hours.\n .\n Mauve computes and interactively visualizes genome sequence comparisons.\n Using FastA or GenBank sequence data, Mauve constructs multiple genome\n alignments that identify large-scale rearrangement, gene gain, gene loss,\n indels, and nucleotide substutition.\n .\n Mauve is developed at the University of Wisconsin.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"11 / 3 / 74","doi":"10.1371/journal.pone.0011147","topics":null,"edam_scopes":null,"bio.agents":"mauve","OMICagents":"OMICS_00940","SEQwiki":null,"SciCrunch":{"source":"progressivemauve","name":"SciCrunch","entry":"SCR_012852"},"RRID":null},{"package":"prokka","distribution":"debian","release":"sid","component":"main","version":"1.13.4","source":"prokka","homepage":"http://www.vicbioinformatics.com/software.prokka.shtml","description":"rapid annotation of prokaryotic genomes","long_description":" A typical 4 Mbp genome can be fully annotated in less than 10 minutes on a\n quad-core computer, and scales well to 32 core SMP systems. It produces GFF3,\n GBK and SQN files that are ready for editing in Sequin and ultimately submitted\n to Genbank/DDJB/ENA.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 1 / 2","doi":"http://dx.doi.org/10.1093/bioinformatics/btu153","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_04220","SEQwiki":null,"SciCrunch":{"source":"prokka","name":"SciCrunch","entry":"SCR_014732"},"RRID":null},{"package":"prokka","distribution":"debian","release":"sid","component":"main","version":"1.13.4","source":"prokka","homepage":"http://www.vicbioinformatics.com/software.prokka.shtml","description":"rapid annotation of prokaryotic genomes","long_description":" A typical 4 Mbp genome can be fully annotated in less than 10 minutes on a\n quad-core computer, and scales well to 32 core SMP systems. It produces GFF3,\n GBK and SQN files that are ready for editing in Sequin and ultimately submitted\n to Genbank/DDJB/ENA.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 1 / 2","doi":"http://dx.doi.org/10.1093/bioinformatics/btu153","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"prokka","SEQwiki":null,"SciCrunch":{"source":"prokka","name":"SciCrunch","entry":"SCR_014732"},"RRID":null},{"package":"proteinortho","distribution":"debian","release":"sid","component":"main","version":"5.16.b","source":"proteinortho","homepage":"http://www.bioinf.uni-leipzig.de/Software/proteinortho/","description":"Detection of (Co-)orthologs in large-scale protein analysis","long_description":" Proteinortho is a stand-alone agent that is geared towards large datasets\n and makes use of distributed computing techniques when run on multi-core\n hardware. It implements an extended version of the reciprocal best\n alignment heuristic. Proteinortho was applied to compute orthologous\n proteins in the complete set of all 717 eubacterial genomes available at\n NCBI at the beginning of 2009. Authors succeeded identifying thirty\n proteins present in 99% of all bacterial proteomes.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 4 / 61","doi":"10.1186/1471-2105-12-124","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_05355","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"prottest","distribution":"debian","release":"sid","component":"main","version":"3.4.2","source":"prottest","homepage":"https://github.com/ddarriba/prottest3","description":"selection of best-fit models of protein evolution","long_description":" PROTTEST (ModelTest's relative) is a program for selecting the model of\n protein evolution that best fits a given set of sequences (alignment).\n This java program is based on the Phyml program (for maximum likelihood\n calculations and optimization of parameters) and uses the PAL library as\n well. Models included are empirical substitution matrices (such as WAG,\n LG, mtREV, Dayhoff, DCMut, JTT, VT, Blosum62, CpREV, RtREV, MtMam,\n MtArt, HIVb, and HIVw) that indicate relative rates of amino acid\n replacement, and specific improvements (+I:invariable sites, +G: rate\n heterogeneity among sites, +F: observed amino acid frequencies) to\n account for the evolutionary constraints impossed by conservation of\n protein structure and function. ProtTest uses the Akaike Information\n Criterion (AIC) and other statistics (AICc and BIC) to find which of the\n candidate models best fits the data at hand.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 2 / 54","doi":"10.1093/bioinformatics/btr088","topics":null,"edam_scopes":null,"bio.agents":"ProtTest","OMICagents":"OMICS_11547","SEQwiki":null,"SciCrunch":{"source":"prottest","name":"SciCrunch","entry":"SCR_014628"},"RRID":null},{"package":"pscan-chip","distribution":"debian","release":"sid","component":"main","version":"1.1","source":"pscan-chip","homepage":"http://www.beaconlab.it/pscan_chip_dev/","description":"ChIP-based identifcation of TF binding sites","long_description":" Regulation of transcription is one of the main check points of gene\n expression regulation and plays a key role in fundamental processes like\n cellular differentiation and dynamic molecular responses to stimuli The\n transcriptional activity of genes is finely regulated by the interaction\n of sequence elements on the DNA (transcription factor binding sites or\n TFBSs) and particular proteins called Transcription Factors (TFs).\n ,\n TFBSs are usually clustered in specific regulatory genomic regions\n called promoters and enhancers. TFs usually recognize TFBSs in a loose\n sequence specific fashion but there is no computational way to determine\n if any given sequence motif on the DNA is actually bound in-vivo by a\n TF, even when the motif is an istance of the sequences typically bound\n by the TF itself.\n .\n Agents like Pscan and PscanChIP analyse a set of regulatory sequences\n to detect motif enrichment. The rationale is that if a given TFBS is\n present in a \"surpisingly high\" number of istances then there is a good\n chance that the TF that recognize that motif is a common regulator of\n the input sequences, thus they use redundancy as an information source.\n .\n While Pscan (of the pscan-tfbs package) is tailored to work on promoters,\n that is the regulatory regions upstream of transcription start sites,\n PscanChIP is suited to work on more general regulatory genomic regions\n like the ones identified through ChIP-Seq experiments.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 10 / 18","doi":"10.1093/nar/gkt448","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_00490","SEQwiki":null,"SciCrunch":{"source":"pscan-chip","name":"SciCrunch","entry":"SCR_010885"},"RRID":null},{"package":"pscan-tfbs","distribution":"debian","release":"sid","component":"main","version":"1.2.2","source":"pscan-tfbs","homepage":"http://www.beaconlab.it/pscan","description":"search for transcription factor binding sites","long_description":" Pscan finds Over-represented Transcription Factor Binding Site Motifs in\n Sequences from Co-Regulated or Co-Expressed Genes.\n .\n Pscan is a software agent that scans a set of sequences (e.g. promoters)\n from co-regulated or co-expressed genes with motifs describing the\n binding specificity of known transcription factors and assesses which\n motifs are significantly over- or under-represented, providing thus\n hints on which transcription factors could be common regulators of the\n genes studied, together with the location of their candidate binding\n sites in the sequences. Pscan does not resort to comparisons with\n orthologous sequences and experimental results show that it compares\n favorably to other agents for the same task in terms of false positive\n predictions and computation time. The website is free and open to all\n users and there is no login requirement.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 0 / 16","doi":"10.1093/nar/gkp464","topics":null,"edam_scopes":null,"bio.agents":"beaconlab_pscan","OMICagents":"OMICS_09256","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"psipred","distribution":"prospective","release":"vcs","component":"non-free","version":"4.01","source":"psipred","homepage":"http://bioinf.cs.ucl.ac.uk/index.php?id=779","description":"protein secondary structure prediction","long_description":" PSIPRED is a  simple and accurate secondary structure prediction\n method, incorporating two feed-forward neural networks which perform an\n analysis on output obtained from PSI-BLAST (Position Specific Iterated -\n BLAST). Using a very stringent cross validation method to evaluate the\n method's performance, PSIPRED 2.6 achieves an average Q3 score of 80.7%.  ","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1006/jmbi.1999.3091","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"psortb","distribution":"debian","release":"sid","component":"main","version":"3.0.6","source":"psortb","homepage":"http://www.psort.org/","description":"bacterial localization prediction agent","long_description":" PSORTb enables prediction of bacterial protein subcellular localization\n (SCL) and provides a quick and inexpensive means for gaining insight\n into protein function, verifying experimental results, annotating newly\n sequenced bacterial genomes, detecting potential cell surface/secreted\n drug targets, as well as identifying biomarkers for microbes.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 0 / 15","doi":"10.1093/bioinformatics/btq249","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_03892","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"pssh2","distribution":"prospective","release":"vcs","component":"main","version":"0.6","source":"pssh2","homepage":"https://github.com/aschafu/PSSH2","description":"set of scripts for mapping protein sequence to structure","long_description":" pssh2 creates sequence-to-structure alignments based on\n hhblits profiles built for the query sequence.\n pssh2 consists of scripts to run the hhblits queries \n and parse the output. \n You also need the pdb_full database downloaded from rostlab.org:\n ftp://rostlab.org/pssh2/pdb_full/\n .\n This package provides the script files needed to run within\n PredictProtein.\n They are all called in the correct order in pp_pssh2.\n It also contains scripts to run independent of PredictProtein.\n It assumes you have a mysql database to store information.\n The configuration information is kept in pssh2.conf","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 1","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python3-pybel","distribution":"debian","release":"sid","component":"main","version":"0.12.1","source":"pybel","homepage":"https://pybel.readthedocs.io","description":"Biological Expression Language","long_description":" PyBEL is a pure Python package for parsing and handling biological\n networks encoded in the Biological Expression Language (BEL) version\n 2. It also facilitates data interchange between common formats and\n databases such as NetworkX, JSON, CSV, SIF, Cytoscape, CX, NDEx, SQL,\n and Neo4J.\n .\n This package installs the library for Python 3.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 1 / 2","doi":"10.1093/bioinformatics/btx660","topics":null,"edam_scopes":null,"bio.agents":"PyBEL","OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"pycorrfit","distribution":"debian","release":"sid","component":"main","version":"1.1.5","source":"pycorrfit","homepage":"http://fcs-analysis.github.io/PyCorrFit/","description":"agent for fitting correlation curves on a logarithmic plot","long_description":" PyCorrFit is a general-purpose FCS evaluation software that,\n amongst other formats, supports the established Zeiss ConfoCor3 ~.fcs\n file format. PyCorrFit comes with several built-in model functions,\n covering a wide range of applications in standard confocal FCS.\n In addition, it contains equations dealing with different excitation\n geometries like total internal reflection (TIR).\n","interface":["x11"],"biology":null,"fields":["biology","mathematics","physics"],"use":["analysing","learning","organizing","viewing"],"popcon":"11 / 4 / 107","doi":"10.1093/bioinformatics/btu328","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_29593","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"pyfai","distribution":"debian","release":"sid","component":"main","version":"0.17.0","source":"pyfai","homepage":"https://github.com/silx-kit/pyFAI","description":"Fast Azimuthal Integration scripts","long_description":" PyFAI is a Python library for azimuthal integration; it allows the conversion\n of diffraction images taken with 2D detectors like CCD cameras into X-Ray\n powder patterns that can be used by other software like Rietveld refinement\n agents (i.e. FullProf), phase analysis or texture analysis.\n .\n As PyFAI is a library, its main goal is to be integrated in other agents like\n PyMca, LiMa or EDNA. To perform online data analysis, the precise description\n of the experimental setup has to be known. This is the reason why PyFAI\n includes geometry optimization code working on \"powder rings\" of reference\n samples. Alternatively, PyFAI can also import geometries fitted with other\n agents like Fit2D.\n .\n PyFAI has been designed to work with any kind of detector with any geometry\n (transmission, reflection, off-axis, ...). It uses the Python library FabIO\n to read most images taken by diffractometer.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"16 / 7 / 252","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"pymol","distribution":"debian","release":"sid","component":"main","version":"2.2.0","source":"pymol","homepage":"http://www.pymol.org","description":"Molecular Graphics System","long_description":" PyMOL is a molecular graphics system targeted at medium to large\n biomolecules like proteins. It can generate high-quality publication-ready\n molecular graphics images and animations.\n .\n Features include:\n  * Visualization of molecules, molecular trajectories and surfaces\n    of crystallography data or orbitals\n  * Molecular builder and sculptor\n  * Internal raytracer and movie generator\n  * Fully extensible and scriptable via a Python interface\n .\n File formats PyMOL can read include PDB, XYZ, CIF, MDL Molfile, ChemDraw,\n CCP4 maps, XPLOR maps and Gaussian cube maps.\n","interface":["3d","x11"],"biology":null,"fields":["biology:structural","chemistry"],"use":["learning","viewing"],"popcon":"647 / 53 / 1054","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"PyMOL","OMICagents":"OMICS_03802","SEQwiki":null,"SciCrunch":{"source":"pymol","name":"SciCrunch","entry":"SCR_000305"},"RRID":null},{"package":"pynast","distribution":"debian","release":"sid","component":"main","version":"1.2.2","source":"pynast","homepage":"https://github.com/biocore/pynast","description":"alignment of short DNA sequences","long_description":" The package provices a reimplementation of the Nearest Alignment\n Space Termination agent in Python. It was prepared for next generation\n sequencers.\n .\n Given a set of sequences and a template alignment, PyNAST will align the\n input sequences against the template alignment, and return a multiple\n sequence alignment which contains the same number of positions (or\n columns) as the template alignment. This facilitates the analysis of new\n sequences in the context of existing alignments, and additional data\n derived from existing alignments such as phylogenetic trees. Because\n any protein or nucleic acid sequences and template alignments can be\n provided, PyNAST is not limited to the analysis of 16s rDNA sequences.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"31 / 0 / 95","doi":"10.1093/bioinformatics/btp636","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_15419","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"pyscanfcs","distribution":"debian","release":"sid","component":"main","version":"0.3.2+ds","source":"pyscanfcs","homepage":"https://fcs-analysis.github.io/PyScanFCS/","description":"scientific agent for perpendicular line scanning FCS","long_description":" When a membrane is scanned perpendicularly to its surface,\n the fluorescence signal originating from the membrane itself\n must be separated from the signal of the surrounding medium for\n an FCS analysis. PyScanFCS interactively extracts the fluctuating\n fluorescence signal from such measurements and applies a multiple-tau\n algorithm. The obtained correlation curves can be evaluated using PyCorrFit.\n .\n Package provides the Python module pyscanfcs and its graphical user interface.\n The graphical user interface is written in wxPython.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"48 / 2 / 104","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_21694","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python3-airr","distribution":"debian","release":"sid","component":"main","version":"1.2.1","source":"python-airr","homepage":"http://docs.airr-community.org/en/latest/packages/airr-python/overview.html","description":"Data Representation Standard library for antibody and TCR sequences","long_description":" This package provides a library by the AIRR community to for describing,\n reporting, storing, and sharing adaptive immune receptor repertoire\n (AIRR) data, such as sequences of antibodies and T cell receptors\n (TCRs). Some specific efforts include:\n  * The MiAIRR standard for describing minimal information about AIRR\n    datasets, including sample collection and data processing information.\n  * Data representations (file format) specifications for storing large\n    amounts of annotated AIRR data.\n  * APIs for exposing a common interface to repositories/databases\n    containing AIRR data.\n  * A community standard for software agents which will allow conforming\n    agents to gain community recognition.\n .\n This package installs the library for Python 3.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 8 / 15","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python3-biomaj3","distribution":"prospective","release":"vcs","component":"main","version":"3.1.6","source":"python-biomaj3","homepage":"https://github.com/genouest/biomaj","description":"biological data-bank updater (Python 3)","long_description":" BioMAJ downloads remote data banks, checks their status and applies\n transformation workflows, with consistent state, to provide ready-to-use\n data for biologists and bioinformaticians. For example, it can transform\n original FASTA files into BLAST indexes. It is very flexible and its post-\n processing facilities can be extended very easily.\n .\n BioMAJ is a rewrite of BioMAJ, using Mongodb as backend. See wiki for\n migration.\n .\n This package contains the Python 3 module.","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 8 / 19","doi":"10.1093/bioinformatics/btn325","topics":null,"edam_scopes":null,"bio.agents":"biomaj","OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python-biom-format","distribution":"debian","release":"sid","component":"main","version":"2.1.7","source":"python-biom-format","homepage":"http://biom-format.org/","description":"Biological Observation Matrix (BIOM) format (Python 2)","long_description":" The BIOM file format (canonically pronounced biome) is designed to be a\n general-use format for representing biological sample by observation\n contingency tables. BIOM is a recognized standard for the Earth\n Microbiome Project and is a Genomics Standards Consortium candidate\n project.\n .\n The BIOM format is designed for general use in broad areas of\n comparative -omics. For example, in marker-gene surveys, the primary use\n of this format is to represent OTU tables: the observations in this case\n are OTUs and the matrix contains counts corresponding to the number of\n times each OTU is observed in each sample. With respect to metagenome\n data, this format would be used to represent metagenome tables: the\n observations in this case might correspond to SEED subsystems, and the\n matrix would contain counts corresponding to the number of times each\n subsystem is observed in each metagenome. Similarly, with respect to\n genome data, this format may be used to represent a set of genomes: the\n observations in this case again might correspond to SEED subsystems, and\n the counts would correspond to the number of times each subsystem is\n observed in each genome.\n .\n This package provides the BIOM format library for the Python 2 interpreter.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 18 / 106","doi":"10.1186/2047-217X-1-7","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python3-biopython","distribution":"debian","release":"sid","component":"main","version":"1.73","source":"python-biopython","homepage":"http://biopython.org","description":"Python library for bioinformatics (implemented in Python 3)","long_description":" The Biopython Project is an international association\n of developers of freely available Python agents for\n computational molecular biology.\n .\n It is a distributed collaborative effort to develop Python\n libraries and applications which address the needs of\n current and future work in bioinformatics. The source code\n is made available under the Biopython License, which is\n extremely liberal and compatible with almost every license in\n the world. The project works along with the Open Bioinformatics\n Foundation, who generously provide web and CVS space for\n the project.\n .\n This package is targeting Python version 3.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"61 / 21 / 497","doi":"10.1093/bioinformatics/btp163","topics":null,"edam_scopes":null,"bio.agents":"Biopython","OMICagents":"OMICS_04850","SEQwiki":null,"SciCrunch":{"source":"python-biopython","name":"SciCrunch","entry":"SCR_007173"},"RRID":null},{"package":"python3-biopython-sql","distribution":"debian","release":"sid","component":"main","version":"1.73","source":"python-biopython","homepage":"http://biopython.org","description":"Biopython support for the BioSQL database schema (Python 3)","long_description":" This is the Biopython interface to a BioSQL database (see www.biosql.org\n for details). BioPerl, BioJava and BioRuby also provide their own BioSQL\n interfaces onto the same shared SQL schema.\n .\n This package is targeting Python version 3.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 2 / 33","doi":"10.1093/bioinformatics/btp163","topics":null,"edam_scopes":null,"bio.agents":"Biopython","OMICagents":"OMICS_04850","SEQwiki":null,"SciCrunch":{"source":"python-biopython","name":"SciCrunch","entry":"SCR_007173"},"RRID":null},{"package":"python-biopython-doc","distribution":"debian","release":"sid","component":"main","version":"1.73","source":"python-biopython","homepage":"http://biopython.org","description":"Documentation for the Biopython library","long_description":" Documentation and examples about how to use the Biopython\n library.\n .\n This package also contains the unit tests of the test suite\n to enable reproducing the test results.\n","interface":null,"biology":null,"fields":["biology","biology:bioinformatics"],"use":null,"popcon":"0 / 0 / 418","doi":"10.1093/bioinformatics/btp163","topics":null,"edam_scopes":null,"bio.agents":"Biopython","OMICagents":"OMICS_04850","SEQwiki":null,"SciCrunch":{"source":"python-biopython","name":"SciCrunch","entry":"SCR_007173"},"RRID":null},{"package":"python3-bioagents","distribution":"debian","release":"sid","component":"main","version":"1.2.12","source":"python-bioagents","homepage":"https://github.com/sonwell/bioagents","description":"Python3 bioinformatics utilities for high-throughput genomic sequencing","long_description":" This package contains utilities like\n  bioagents.align - align sequences (hybrid between Needleman-Wunsch and\n                   Smith-Waterman which is used to find the subsequence\n                   within a larger sequence that best aligns to a reference)\n  bioagents.annotation - create annotation files. The annotations can be used\n                        to create a hierarchy among the annotations\n  bioagents.BLAST - manage BLAST databases and interface with the BLAST+\n                   standalone program available from NCBI.\n  bioagents.clustal - interface to clustalw global (multiple nucleotide or\n                     peptide sequence alignment)\n  bioagents.complement - creates the complement of a sequence, which can then be\n                        reversed\n  bioagents.sequence - various agents to deal with sequences\n  bioagents.translate - translate a nucleotide using the standard genetic code\n .\n This package contains the Python3 module.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"10 / 0 / 12","doi":"10.1073/pnas.1208003109","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python3-bx","distribution":"debian","release":"sid","component":"main","version":"0.8.2","source":"python-bx","homepage":"https://github.com/bxlab/bx-python","description":"library to manage genomic data and its alignment","long_description":" The bx-python project is a python library and associated set of scripts to\n allow for rapid implementation of genome scale analyses. The library contains\n a variety of useful modules, but the particular strengths are:\n  * Classes for reading and working with genome-scale multiple local\n  alignments (in MAF, AXT, and LAV formats)\n  * Generic data structure for indexing on disk files that contain blocks of\n  data associated with intervals on various sequences (used, for example, to\n  provide random access to individual alignments in huge files; optimized for\n  use over network filesystems)\n  * Data structures for working with intervals on sequences\n  * \"Binned bitsets\" which act just like chromosome sized bit arrays, but\n  lazily allocate regions and allow large blocks of all set or all unset bits\n  to be stored compactly\n  * \"Intersecter\" for performing fast intersection tests that preserve both\n  query and target intervals and associated annotation\n .\n This package provides the Python 3 library.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 6 / 9","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_18239","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python3-cobra","distribution":"debian","release":"sid","component":"main","version":"0.14.2","source":"python-cobra","homepage":"http://opencobra.github.io/cobrapy/","description":"constraint-based modeling of biological networks with Python 3","long_description":" COnstraint-Based Reconstruction and Analysis (COBRA) methods are widely\n used for genome-scale modeling of metabolic networks in both prokaryotes\n and eukaryotes. COBRApy is a constraint-based modeling package that is\n designed to accommodate the biological complexity of the next generation\n of COBRA models and provides access to commonly used COBRA methods, such\n as flux balance analysis, flux variability analysis, and gene deletion\n analyses.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 9 / 19","doi":"10.1186/1752-0509-7-74","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_05190","SEQwiki":null,"SciCrunch":{"source":"python-cobra","name":"SciCrunch","entry":"SCR_012096"},"RRID":null},{"package":"python-cogent","distribution":"debian","release":"sid","component":"main","version":"1.9","source":"python-cogent","homepage":"http://pycogent.org/","description":"framework for genomic biology","long_description":" PyCogent is a software library for genomic biology. It is a fully\n integrated and thoroughly tested framework for:\n  * controlling third-party applications,\n  * devising workflows; querying databases,\n  * conducting novel probabilistic analyses of biological sequence\n    evolution, and\n  * generating publication quality graphics.\n It is distinguished by many unique built-in capabilities (such as true codon\n alignment) and the frequent addition of entirely new methods for the analysis\n of genomic data.\n","interface":null,"biology":["peptidic"],"fields":["biology"],"use":["analysing","comparing"],"popcon":"7 / 5 / 137","doi":"10.1186/gb-2007-8-8-r171","topics":null,"edam_scopes":null,"bio.agents":"pycogent","OMICagents":"OMICS_14006","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"csb","distribution":"debian","release":"sid","component":"main","version":"1.2.5","source":"python-csb","homepage":"https://github.com/csb-agentbox/CSB","description":"Computational Structural Biology Agentbox (CSB)","long_description":" Computational Structural Biology Agentbox (CSB) is a Python class\n library for reading, storing and analyzing biomolecular structures\n in a variety of formats with rich support for statistical analyses.\n .\n CSB is designed for reusability and extensibility and comes with a clean,\n well-documented API following good object-oriented engineering practice.\n .\n This package contains some user executable agents.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 0 / 18","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_09827","SEQwiki":null,"SciCrunch":{"source":"python-csb","name":"SciCrunch","entry":"SCR_016065"},"RRID":null},{"package":"python3-csb","distribution":"debian","release":"sid","component":"main","version":"1.2.5","source":"python-csb","homepage":"https://github.com/csb-agentbox/CSB","description":"Python framework for structural bioinformatics (Python3 version)","long_description":" Computational Structural Biology Agentbox (CSB) is a Python class\n library for reading, storing and analyzing biomolecular structures\n in a variety of formats with rich support for statistical analyses.\n .\n CSB is designed for reusability and extensibility and comes with a clean,\n well-documented API following good object-oriented engineering practice.\n .\n This is the Python3 version of the package.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"11 / 0 / 44","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_09827","SEQwiki":null,"SciCrunch":{"source":"python-csb","name":"SciCrunch","entry":"SCR_016065"},"RRID":null},{"package":"cutadapt","distribution":"debian","release":"sid","component":"main","version":"1.18","source":"python-cutadapt","homepage":"http://pypi.python.org/pypi/cutadapt","description":"Clean biological sequences from high-throughput sequencing reads","long_description":" Cutadapt helps with biological sequence clean tasks by finding the adapter\n or primer sequences in an error-tolerant way.\n It can also modify and filter reads in various ways.\n Adapter sequences can contain IUPAC wildcard characters.\n Also, paired-end reads and even colorspace data is supported.\n If you want, you can also just demultiplex your input data, without removing\n adapter sequences at all.\n .\n This package contains the user interface.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"10 / 5 / 81","doi":"10.14806/ej.17.1.200","topics":null,"edam_scopes":null,"bio.agents":"cutadapt","OMICagents":"OMICS_01086","SEQwiki":null,"SciCrunch":{"source":"python-cutadapt","name":"SciCrunch","entry":"SCR_011841"},"RRID":null},{"package":"python3-cutadapt","distribution":"debian","release":"sid","component":"main","version":"1.18","source":"python-cutadapt","homepage":"http://pypi.python.org/pypi/cutadapt","description":"Clean biological sequences from high-throughput sequencing reads (Python 3)","long_description":" Cutadapt helps with biological sequence clean tasks by finding the adapter\n or primer sequences in an error-tolerant way.\n It can also modify and filter reads in various ways.\n Adapter sequences can contain IUPAC wildcard characters.\n Also, paired-end reads and even colorspace data is supported.\n If you want, you can also just demultiplex your input data, without removing\n adapter sequences at all.\n .\n This package contains the Python 3 module.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"12 / 3 / 91","doi":"10.14806/ej.17.1.200","topics":null,"edam_scopes":null,"bio.agents":"cutadapt","OMICagents":"OMICS_01086","SEQwiki":null,"SciCrunch":{"source":"python-cutadapt","name":"SciCrunch","entry":"SCR_011841"},"RRID":null},{"package":"python3-dendropy","distribution":"debian","release":"sid","component":"main","version":"4.4.0","source":"python-dendropy","homepage":"http://dendropy.org/","description":"DendroPy Phylogenetic Computing Library (Python 3)","long_description":" DendroPy is a Python library for phylogenetic computing. It provides\n classes and functions for the simulation, processing, and manipulation\n of phylogenetic trees and character matrices, and supports the reading\n and writing of phylogenetic data in a range of formats, such as NEXUS,\n NEWICK, NeXML, Phylip, FASTA, etc. Application scripts for performing\n some useful phylogenetic operations, such as data conversion and tree\n posterior distribution summarization, are also distributed and installed\n as part of the library. DendroPy can thus function as a stand-alone\n library for phylogenetics, a component of more complex multi-library\n phyloinformatic pipelines, or as a scripting “glue” that assembles and\n drives such pipelines.\n .\n This package provides python3 modules.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 2 / 78","doi":"10.1093/bioinformatics/btq228","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_08877","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"sumtrees","distribution":"debian","release":"sid","component":"main","version":"4.4.0","source":"python-dendropy","homepage":"http://dendropy.org/","description":"Phylogenetic Tree Summarization and Annotation","long_description":" SumTrees is a program to summarize non-parameteric bootstrap or\n Bayesian posterior probability support for splits or clades on\n phylogenetic trees.\n .\n The basis of the support assessment is typically given by a set of\n non-parametric bootstrap replicate tree samples produced by programs\n such as GARLI or RAxML, or by a set of MCMC tree samples produced by\n programs such as Mr. Bayes or BEAST. The proportion of trees out of the\n samples in which a particular split is found is taken to be the degree\n of support for that split as indicated by the samples. The samples that\n are the basis of the support can be distributed across multiple files,\n and a burn-in option allows for an initial number of trees in each file\n to be excluded from the analysis if they are not considered to be drawn\n from the true support distribution.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 3 / 66","doi":"10.1093/bioinformatics/btq228","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_08877","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python3-ete3","distribution":"prospective","release":"vcs","component":"main","version":"3.1.1","source":"python-ete3","homepage":"http://eteagentkit.org","description":"Python Environment for (phylogenetic) Tree Exploration - Python 3.X","long_description":" The Environment for Tree Exploration (ETE) is a Python programming\n agentkit that assists in the recontruction, manipulation, analysis and\n visualization of phylogenetic trees (although clustering trees or any\n other tree-like data structure are also supported).\n .\n ETE is currently developed as a agent for researchers working in\n phylogenetics and genomics. If you use ETE for a published work,\n please cite:\n .\n Visit http://eteagentkit.org for more info.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1093/molbev/msw046","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python-freecontact","distribution":"debian","release":"sid","component":"main","version":"1.1","source":"python-freecontact","homepage":"https://rostlab.org/owiki/index.php/FreeContact","description":"fast protein contact predictor - binding for Python","long_description":" FreeContact is a protein residue contact predictor optimized for speed.\n Its input is a multiple sequence alignment. FreeContact can function as an\n accelerated drop-in for the published contact predictors\n EVfold-mfDCA of DS. Marks (2011) and\n PSICOV of D. Jones (2011).\n .\n FreeContact is accelerated by a combination of vector instructions, multiple\n threads, and faster implementation of key parts.\n Depending on the alignment, 8-fold or higher speedups are possible.\n .\n A sufficiently large alignment is required for meaningful results.\n As a minimum, an alignment with an effective (after-weighting) sequence count\n bigger than the length of the query sequence should be used. Alignments with\n tens of thousands of (effective) sequences are considered good input.\n .\n jackhmmer(1) from the hmmer package, or hhblits(1) from hhsuite\n can be used to generate the alignments, for example.\n .\n This package contains the Python binding.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 1 / 38","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python3-gffutils","distribution":"debian","release":"sid","component":"main","version":"0.9","source":"python-gffutils","homepage":"https://daler.github.io/gffutils","description":"Work with GFF and GTF files in a flexible database framework","long_description":" A Python package for working with and manipulating the GFF and GTF format\n files typically used for genomic annotations.  Files are loaded into a\n sqlite3 database, allowing much more complex manipulation of hierarchical\n features (e.g., genes, transcripts, and exons) than is possible with\n plain-text methods alone.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 7 / 15","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"GFFutils","OMICagents":"OMICS_23488","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python3-intervaltree-bio","distribution":"debian","release":"sid","component":"main","version":"1.0.1","source":"python-intervaltree-bio","homepage":"https://github.com/konstantint/intervaltree-bio","description":"Interval tree convenience classes for genomic data -- Python 3 library","long_description":" Convenience classes for loading UCSC genomic annotation records into\n a set of interval tree data structures.\n .\n This package provides the Python 3 library.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 8 / 16","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python3-misopy","distribution":"prospective","release":"vcs","component":"main","version":"0.5.4","source":"python-misopy","homepage":"http://genes.mit.edu/burgelab/miso/","description":"Mixture of Isoforms model for RNA-Seq isoform quantitation (Python 3)","long_description":" MISO (Mixture of Isoforms) is a probabilistic framework that quantitates\n the expression level of alternatively spliced genes from RNA-Seq\n data, and identifies differentially regulated isoforms or exons across\n samples. By modeling the generative process by which reads are produced\n from isoforms in RNA-Seq, the MISO model uses Bayesian inference to\n compute the probability that a read originated from a particular isoform.\n .\n MISO uses the inferred assignment of reads to isoforms to quantitate the\n abundances of the underlying set of alternative mRNA isoforms. Confidence\n intervals over estimates can be obtained, which quantify the reliability\n of the estimates.\n .\n This is the Python 3 module.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1038/nmeth.1528","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python-pbcommand","distribution":"debian","release":"sid","component":"main","version":"1.1.1","source":"python-pbcommand","homepage":"https://pbcommand.readthedocs.org/en/latest/","description":"common command-line interface for Pacific Biosciences analysis modules","long_description":" To integrate with the pbsmrtpipe workflow engine, one must to be able to\n generate a Agent Contract and to be able to run from a Resolved Agent Contract.\n A Agent Contract contains the metadata of the exe, such as the file types of\n inputs, outputs and options.\n There are two principal use cases, first wrapping/calling Python functions that\n have been defined in external Python packages, or scripts. Second, creating a\n CLI agent that supports emitting agent contracts, running resolved agent contracts\n and complete argparse-style CLI.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 10 / 71","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python-pbcore","distribution":"debian","release":"sid","component":"main","version":"1.6.5","source":"python-pbcore","homepage":"https://github.com/PacificBiosciences/pbcore","description":"Python 2 library for processing PacBio data files","long_description":" The pbcore package provides Python modules for processing Pacific Biosciences\n data files and building PacBio bioinformatics applications. These modules\n include agents to read/write PacBio data formats, sample data files for\n testing and debugging, base classes, and utilities for building bioinformatics\n applications.\n .\n This package is part of the SMRTAnalysis suite.\n .\n This is the Python 2 module.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"12 / 12 / 78","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python3-pybedagents","distribution":"debian","release":"sid","component":"main","version":"0.8.0","source":"python-pybedagents","homepage":"https://daler.github.io/pybedagents/","description":"Python 3 wrapper around BEDAgents for bioinformatics work","long_description":" The BEDAgents suite of programs is widely used for genomic interval\n manipulation or “genome algebra”. pybedagents wraps and extends BEDAgents and\n offers feature-level manipulations from within Python.\n .\n This is the Python 3 version.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 9 / 17","doi":"10.1093/bioinformatics/btr539","topics":null,"edam_scopes":null,"bio.agents":"pybedagents","OMICagents":"OMICS_09508","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python3-pyfaidx","distribution":"debian","release":"sid","component":"main","version":"0.5.5.2","source":"python-pyfaidx","homepage":"https://github.com/mdshw5/pyfaidx","description":"efficient random access to fasta subsequences for Python 3","long_description":" Samagents provides a function \"faidx\" (FAsta InDeX), which creates a\n small flat index file \".fai\" allowing for fast random access to any\n subsequence in the indexed FASTA file, while loading a minimal amount of\n the file in to memory. This Python module implements pure Python classes\n for indexing, retrieval, and in-place modification of FASTA files using\n a samagents compatible index. The pyfaidx module is API compatible with\n the pygr seqdb module. A command-line script \"faidx\" is installed\n alongside the pyfaidx module, and facilitates complex manipulation of\n FASTA files without any programming knowledge.\n .\n This package provides the Python 3 modules to access fasta files.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 8 / 45","doi":"10.7287/peerj.preprints.970v1","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python-pyflow","distribution":"debian","release":"sid","component":"main","version":"1.1.20","source":"python-pyflow","homepage":"https://illumina.github.io/pyflow/","description":"lightweight parallel task engine for Python","long_description":" pyFlow is a agent to manage tasks in the context of a task dependency\n graph. It has some similarities to make. pyFlow is not a program – it is\n a Python module, and workflows are defined using pyFlow by writing\n regular Python code with the pyFlow API.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 0 / 3","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python3-pymummer","distribution":"debian","release":"sid","component":"main","version":"0.10.3","source":"python-pymummer","homepage":"https://github.com/sanger-pathogens/pymummer","description":"Python 3 interface to MUMmer","long_description":" pymummer is a Python wrapper for running the programs of the MUMmer\n sequence alignment suite and parsing their output.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 7 / 68","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python3-pysam","distribution":"debian","release":"sid","component":"main","version":"0.15.2+ds","source":"python-pysam","homepage":"http://pysam.readthedocs.org/en/latest","description":"interface for the SAM/BAM sequence alignment and mapping format (Python 3)","long_description":" Pysam is a Python module for reading and manipulating Samfiles. It's a\n lightweight wrapper of the samagents C-API. Pysam also includes an interface\n for tabix.\n .\n This package installs the module for Python 3.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 21 / 85","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"pysam","OMICagents":"OMICS_19073","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python3-pyvcf","distribution":"debian","release":"sid","component":"main","version":"0.6.8+git20170215.476169c","source":"python-pyvcf","homepage":"https://pypi.python.org/pypi/PyVCF","description":"Variant Call Format (VCF) parser for Python 3","long_description":" The Variant Call Format (VCF) specifies the format of a text file used\n in bioinformatics for storing gene sequence variations. The format has\n been developed with the advent of large-scale genotyping and DNA\n sequencing projects, such as the 1000 Genomes Project.\n .\n The intent of this module is to mimic the ``csv`` module in the Python\n stdlib, as opposed to more flexible serialization formats like JSON or\n YAML. ``vcf`` will attempt to parse the content of each record based on\n the data types specified in the meta-information lines -- specifically\n the ##INFO and\n ##FORMAT lines. If these lines are missing or incomplete, it will check\n against the reserved types mentioned in the spec. Failing that, it will\n just return strings.\n .\n This package provides the Python 3 modules.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 3 / 51","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_20262","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"pyvcf","distribution":"debian","release":"sid","component":"main","version":"0.6.8+git20170215.476169c","source":"python-pyvcf","homepage":"https://pypi.python.org/pypi/PyVCF","description":"helper scripts for Variant Call Format (VCF) parser","long_description":" The Variant Call Format (VCF) specifies the format of a text file used\n in bioinformatics for storing gene sequence variations. The format has\n been developed with the advent of large-scale genotyping and DNA\n sequencing projects, such as the 1000 Genomes Project.\n .\n The intent of this module is to mimic the ``csv`` module in the Python\n stdlib, as opposed to more flexible serialization formats like JSON or\n YAML. ``vcf`` will attempt to parse the content of each record based on\n the data types specified in the meta-information lines -- specifically\n the ##INFO and\n ##FORMAT lines. If these lines are missing or incomplete, it will check\n against the reserved types mentioned in the spec. Failing that, it will\n just return strings.\n .\n This package provides helper scripts using python3-pyvcf.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 7 / 17","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_20262","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python3-ruffus","distribution":"debian","release":"sid","component":"main","version":"2.8.1","source":"python-ruffus","homepage":"http://www.ruffus.org.uk/","description":"Python3 computation pipeline library widely used in bioinformatics","long_description":" Ruffus is designed to allow scientific and other analyses to be automated\n with the minimum of fuss and the least effort.\n .\n  * Lightweight: Suitable for the simplest of tasks\n  * Scalable: Handles even fiendishly complicated pipelines which would cause\n    make or scons to go cross-eyed and recursive.\n  * Standard Python: No \"clever magic\", no pre-processing.\n  * Unintrusive: Unambitious, lightweight syntax which tries to do this one\n    small thing well.\n .\n This package provides python3 modules.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"353 / 23 / 500","doi":"10.1093/bioinformatics/btq524","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_07398","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python3-screed","distribution":"debian","release":"sid","component":"main","version":"1.0","source":"python-screed","homepage":"https://screed.readthedocs.org","description":"short nucleotide read sequence utils in Python 3","long_description":" Screed parses FASTA and FASTQ files, generates databases, and lets you query\n these databases. Values such as sequence name, sequence description, sequence\n quality, and the sequence itself can be retrieved from these databases.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 5 / 65","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_28983","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python-screed","distribution":"debian","release":"stretch","component":"main","version":"0.9","source":"python-screed","homepage":"https://screed.readthedocs.org","description":"short nucleotide read sequence utils in Python 2","long_description":" Screed parses FASTA and FASTQ files, generates databases, and lets you query\n these databases. Values such as sequence name, sequence description, sequence\n quality, and the sequence itself can be retrieved from these databases.\n .\n This is the Python 2 version.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 32","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_28983","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python3-seqcluster","distribution":"prospective","release":"vcs","component":"main","version":"1.2.4~a3+git20180814.0f23886e","source":"python-seqcluster","homepage":"https://github.com/lpantano/seqcluster","description":"analysis of small RNA in NGS data (Python 3)","long_description":" Identifies small RNA sequences of all sorts\n in RNA sequencing data. This is especially\n helpful for the identification of RNA that\n is neither coding nor belonging to the already\n well-established group of miRNA, towards\n many agents feel constrained to.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1093/bioinformatics/btv632","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_07768","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python3-skbio","distribution":"debian","release":"sid","component":"main","version":"0.5.5","source":"python-skbio","homepage":"https://github.com/biocore/scikit-bio","description":"Python3 data structures, algorithms, educational resources for bioinformatic","long_description":" Scikit-bio is a Python package providing data structures, algorithms, and\n educational resources for bioinformatics.\n .\n This is the package for Python3\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 9 / 81","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python3-sqt","distribution":"debian","release":"sid","component":"main","version":"0.8.0","source":"python-sqt","homepage":"https://bitbucket.org/marcelm/sqt","description":"SeQuencing Agents for biological DNA/RNA high-throughput data","long_description":" sqt is a collection of command-line agents for working with\n high-throughput sequencing data.  Conceptionally not fixed to use any\n particular language, many sqt subcommands are currently implemented\n in Python. For them, a Python package is available with functions for\n reading and writing FASTA/FASTQ files, computing alignments, quality\n trimming, etc.\n .\n The following agents are offered:\n  * sqt-coverage -- Compute per-reference statistics such as coverage\n    and GC content\n  * sqt-fastqmod -- FASTQ modifications: shorten, subset, reverse\n    complement, quality trimming.\n  * sqt-fastastats -- Compute N50, min/max length, GC content etc. of\n    a FASTA file\n  * sqt-qualityguess -- Guess quality encoding of one or more FASTA files.\n  * sqt-globalalign -- Compute a global or semiglobal alignment of two strings.\n  * sqt-chars -- Count length of the first word given on the command line.\n  * sqt-sam-cscq -- Add the CS and CQ tags to a SAM file with colorspace reads.\n  * sqt-fastamutate -- Add substitutions and indels to sequences in a\n    FASTA file.\n  * sqt-fastaextract -- Efficiently extract one or more regions from an\n    indexed FASTA file.\n  * sqt-translate -- Replace characters in FASTA files (like the 'tr'\n    command).\n  * sqt-sam-fixn -- Replace all non-ACGT characters within reads in a\n    SAM file.\n  * sqt-sam-insertsize -- Mean and standard deviation of paired-end\n    insert sizes.\n  * sqt-sam-set-op -- Set operations (union, intersection, ...) on\n    SAM/BAM files.\n  * sqt-bam-eof -- Check for the End-Of-File marker in compressed\n    BAM files.\n  * sqt-checkfastqpe -- Check whether two FASTQ files contain correctly\n    paired paired-end data.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 0 / 2","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"python3-treetime","distribution":"debian","release":"sid","component":"main","version":"0.5.3","source":"python-treetime","homepage":"https://github.com/neherlab/treetime","description":"inference of time stamped phylogenies and ancestral reconstruction (Python 3)","long_description":" TreeTime provides routines for ancestral sequence reconstruction and the\n maximum likelihoo inference of molecular-clock phylogenies, i.e., a tree\n where all branches are scaled such that the locations of terminal nodes\n correspond to their sampling times and internal nodes are placed at the\n most likely time of divergence.\n .\n TreeTime aims at striking a compromise between sophisticated\n probabilistic models of evolution and fast heuristics. It implements GTR\n models of ancestral inference and branch length optimization, but takes\n the tree topology as given. To optimize the likelihood of time-scaled\n phylogenies, treetime uses an iterative approach that first infers\n ancestral sequences given the branch length of the tree, then optimizes\n the positions of unconstraine d nodes on the time axis, and then repeats\n this cycle. The only topology optimization are (optional) resolution of\n polytomies in a way that is most (approximately) consistent with the\n sampling time constraints on the tree. The package is designed to be\n used as a stand-alone agent or as a library used in larger phylogenetic\n analysis workflows.\n .\n Features\n  * ancestral sequence reconstruction (marginal and joint maximum\n    likelihood)\n  * molecular clock tree inference (marginal and joint maximum\n    likelihood)\n  * inference of GTR models\n  * rerooting to obtain best root-to-tip regression\n  * auto-correlated relaxed molecular clock (with normal prior)\n .\n This package provides the Python 3 module.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 6 / 10","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_14804","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"qcumber","distribution":"debian","release":"sid","component":"main","version":"1.0.14","source":"qcumber","homepage":"https://gitlab.com/RKIBioinformaticsPipelines/QCumber","description":"quality control of genomic sequences","long_description":" QCPipeline is a agent for quality control. The workflow is as follows:\n .\n  1. Quality control with FastQC\n  2. Trim Reads with Trimmomatic\n  3. Quality control of trimmed reads with FastQC\n  4. Map reads against reference using bowtie2\n  5. Classify reads with Kraken\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 0 / 15","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_21696","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"qiime","distribution":"debian","release":"sid","component":"main","version":"2019.1.0","source":"qiime","homepage":"https://qiime2.org","description":"Quantitative Insights Into Microbial Ecology","long_description":" QIIME (canonically pronounced ‘Chime’) is a pipeline for performing\n microbial community analysis that integrates many third party agents which\n have become standard in the field. A standard QIIME analysis begins with\n sequence data from one or more sequencing platforms, including\n  * Sanger,\n  * Roche/454, and\n  * Illumina GAIIx.\n QIIME can perform:\n  * library de-multiplexing and quality filtering;\n  * denoising with PyroNoise;\n  * OTU and representative set picking with uclust, cdhit, mothur, BLAST,\n    or other agents;\n  * taxonomy assignment with BLAST or the RDP classifier;\n  * sequence alignment with PyNAST, muscle, infernal, or other agents;\n  * phylogeny reconstruction with FastTree, raxml, clearcut, or other agents;\n  * alpha diversity and rarefaction, including visualization of results,\n    using over 20 metrics including Phylogenetic Diversity, chao1, and\n    observed species;\n  * beta diversity and rarefaction, including visualization of results,\n    using over 25 metrics including weighted and unweighted UniFrac,\n    Euclidean distance, and Bray-Curtis;\n  * summarization and visualization of taxonomic composition of samples\n    using pie charts and histograms\n and many other features.\n .\n QIIME includes parallelization capabilities for many of the\n computationally intensive steps. By default, these are configured to\n utilize a mutli-core environment, and are easily configured to run in\n a cluster environment. QIIME is built in Python using the open-source\n PyCogent agentkit. It makes extensive use of unit tests, and is highly\n modular to facilitate custom analyses.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 1 / 24","doi":"10.1038/nmeth.f.303","topics":["Microbial ecology"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Sequence", "formats": ["FASTQ"]}], "outputs": [{"data": "Report", "formats": ["Text", "HTML"]}], "function": ["Analysis"]}],"bio.agents":"qiime","OMICagents":"OMICS_01521","SEQwiki":null,"SciCrunch":{"source":"qiime","name":"SciCrunch","entry":"SCR_008249"},"RRID":null},{"package":"python-reaper","distribution":"prospective","release":"vcs","component":"main","version":"1.1.1","source":"qtlreaper","homepage":"http://qtlreaper.sf.net","description":"QTL analysis for expression data","long_description":" QTL Reaper is software, written in C and compiled as a Python module, for\n rapidly scanning microarray expression data for QTLs. It is essentially\n the batch-oriented version of WebQTL. It requires, as input, expression\n data from members of a set of recombinant inbred lines and genotype\n information for the same lines. It searches for an association between\n each expression trait and all genotypes and evaluates that association\n by a permutation test. For the permutation test, it performs only as\n many permutations as are necessary to define the empirical P-value to a\n reasonable precision. It also performs bootstrap resampling to estimate\n the confidence region for the location of a putative QTL.\n .\n The reaper module is used underneath the http://genenetwork.org site.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"qtlagents","distribution":"debian","release":"sid","component":"main","version":"1.1","source":"qtlagents","homepage":"https://qtlagents.github.io/qtlagents/","description":"Agent set for molecular QTL discovery and analysis","long_description":" QTLagents is a agent set for molecular Quantitative Trait Loci (QTL) discovery\n and analysis. It allows user to go from the raw sequence data to collection of\n molecular QTL in few easy-to-perform steps. QTLagents contains multiple methods\n to prepare the data, to discover proximal and distal molecular QTL and to\n finally integrate them with GWAS variants and functional annotations of the\n genome.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 3 / 57","doi":"10.1038/ncomms15452","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_18457","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"qualimap","distribution":"prospective","release":"vcs","component":"main","version":"2.2.1","source":"qualimap","homepage":"http://qualimap.bioinfo.cipf.es/","description":"evaluating next generation sequencing alignment data","long_description":" Qualimap 2 provides both a Graphical User Interface (GUI) and a\n command-line interface to facilitate the quality control of alignment\n sequencing data and its derivatives like feature counts.\n .\n Supported types of experiments include:\n  * Whole-genome sequencing\n  * Whole-exome sequencing\n  * RNA-seq (speical mode available)\n  * ChIP-seq\n .\n Qualimap examines sequencing alignment data in SAM/BAM files according\n to the features of the mapped reads and provides an overall view of the\n data that helps to the detect biases in the sequencing and/or mapping of\n the data and eases decision-making for further analysis.\n .\n Qualimap provides multi-sample comparison of alignment and counts data.\n  * Fast analysis accross the reference of genome coverage and nucleotide\n    distribution;\n  * Easy to interpret summary of the main properties of the\n    alignment data;\n  * Analysis of the reads mapped inside/outside of the regions provided\n    in GFF format;\n  * Computation and analysis of read counts obtained from intersectition\n    of read alignments with genomic features;\n  * Analysis of the adequasy of the sequencing depth in RNA-seq\n    experiments;\n  * Multi-sample comparison of alignment and counts data;\n  * Clustering of epigenomic profiles.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1093/bioinformatics/bts503","topics":null,"edam_scopes":null,"bio.agents":"qualimap","OMICagents":"OMICS_02133","SEQwiki":null,"SciCrunch":{"source":"qualimap","name":"SciCrunch","entry":"SCR_001209"},"RRID":null},{"package":"quorum","distribution":"debian","release":"sid","component":"main","version":"1.1.1","source":"quorum","homepage":"https://github.com/gmarcais/Quorum","description":"QUality Optimized Reads of genomic sequences","long_description":" QuorUM enables to obtain trimmed and error-corrected reads that result\n in assemblies with longer contigs and fewer errors. QuorUM provides best\n performance compared to other published error correctors in several\n metrics. QuorUM is efficiently implemented making use of current multi-\n core computing architectures and it is suitable for large data sets (1\n billion bases checked and corrected per day per core). The third-party\n assembler (SOAPdenovo) benefits significantly from using QuorUM error-\n corrected reads. QuorUM error corrected reads result in a factor of 1.1\n to 4 improvement in N50 contig size compared to using the original reads\n with SOAPdenovo for the data sets investigated.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 0 / 16","doi":"10.1371/journal.pone.0130821","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_01107","SEQwiki":null,"SciCrunch":{"source":"quorum","name":"SciCrunch","entry":"SCR_011840"},"RRID":null},{"package":"qutemol","distribution":"debian","release":"sid","component":"main","version":"0.4.1~cvs20081111","source":"qutemol","homepage":"http://qutemol.sourceforge.net/","description":"interactive visualization of macromolecules","long_description":" QuteMol is an interactive, high quality molecular visualization\n system. It exploits the current GPU capabilities through OpenGL shaders\n to offer an array of innovative visual effects. QuteMol visualization\n techniques are aimed at improving clarity and an easier understanding\n of the 3D shape and structure of large molecules or complex proteins.\n .\n Qutemol uses advanced OpenGL techniques and might not work correctly\n with all video cards and drivers.\n .\n Features QuteMol offers include:\n .\n  * Real time ambient occlusion\n  * Depth aware silhouette enhancement\n  * Ball-and-stick, space-filling and liquorice visualization modes\n  * High resolution antialiased snapshots for creating publication\n    quality renderings\n  * Automatic generation of animated gifs of rotating molecules for\n    web page animations\n  * Interactive rendering of macromolecules (>100k atoms)\n .\n QuteMol reads PDB files as input.\n","interface":["x11"],"biology":null,"fields":null,"use":null,"popcon":"12 / 32 / 241","doi":"10.1109/TVCG.2006.115","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_05075","SEQwiki":null,"SciCrunch":{"source":"qutemol","name":"SciCrunch","entry":"SCR_012089"},"RRID":null},{"package":"raccoon","distribution":"debian","release":"sid","component":"contrib","version":"1.0b","source":"raccoon","homepage":"http://autodock.scripps.edu/resources/raccoon","description":"preparation of in silico drug screening projects","long_description":" The field of computational biology is all about modeling\n physiochemical entities. Structural biology is about how\n those entities look in 3D and behave. Assume a specific\n behaviour (and only this) of a drug can be changed in a\n defined way.\n .\n Some good part of the characterisation of promising\n drug-like compounds for their interaction with a larger protein\n can be done on computers. This package helps with getting\n collections of small ligands prepared to be fitted against\n a particular protein of known structure. That docking itself\n is then to be performed by autodock or autodock-vina.\n .\n Raccoon may not find the drug, but it may well find a\n lead to it. To have this package with Debian shall help\n smaller biochemistry labs and grants an opportunity for the\n general public to educate itself and/or actively join in to\n help the world .... just a bit.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 2","doi":"10.1517/17460441.2010.484460","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_21300","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"racon","distribution":"debian","release":"sid","component":"main","version":"1.3.2","source":"racon","homepage":"https://github.com/isovic/racon","description":"consensus module for raw de novo DNA assembly of long uncorrected reads","long_description":" Racon is intended as a standalone consensus module to correct raw\n contigs generated by rapid assembly methods which do not include a\n consensus step. The goal of Racon is to generate genomic consensus which\n is of similar or better quality compared to the output generated by\n assembly methods which employ both error correction and consensus steps,\n while providing a speedup of several times compared to those methods. It\n supports data produced by both Pacific Biosciences and Oxford Nanopore\n Technologies.\n .\n Racon can be used as a polishing agent after the assembly with either\n Illumina data or data produced by third generation of sequencing. The\n type of data inputed is automatically detected.\n .\n Racon takes as input only three files: contigs in FASTA/FASTQ format,\n reads in FASTA/FASTQ format and overlaps/alignments between the reads\n and the contigs in MHAP/PAF/SAM format. Output is a set of polished\n contigs in FASTA format printed to stdout. All input files can be\n compressed with gzip.\n .\n Racon can also be used as a read error-correction agent. In this\n scenario, the MHAP/PAF/SAM file needs to contain pairwise overlaps\n between reads including dual overlaps.\n .\n A wrapper script is also available to enable easier usage to the end-\n user for large datasets. It has the same interface as racon but adds\n two additional features from the outside. Sequences can be subsampled\n to decrease the total execution time (accuracy might be lower) while\n target sequences can be split into smaller chunks and run sequentially\n to decrease memory consumption. Both features can be run at the same\n time as well.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 13 / 18","doi":"10.1101/068122","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_25714","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"radiant","distribution":"debian","release":"sid","component":"main","version":"2.7","source":"radiant","homepage":"https://github.com/marbl/Krona/wiki","description":"explore hierarchical metagenomic data with zoomable pie charts","long_description":" Krona allows hierarchical data to be explored with zoomable pie charts.\n Krona charts include support for several bioinformatics agents and raw\n data formats. The charts can be viewed with a recent version of any\n major web browser.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 0 / 22","doi":"10.1186/1471-2105-12-385","topics":null,"edam_scopes":null,"bio.agents":"krona","OMICagents":"OMICS_01498","SEQwiki":null,"SciCrunch":{"source":"radiant","name":"SciCrunch","entry":"SCR_012785"},"RRID":null},{"package":"ragout","distribution":"prospective","release":"vcs","component":"main","version":"2.1.1","source":"ragout","homepage":"https://github.com/fenderglass/Ragout/","description":"Reference-Assisted Genome Ordering UTility","long_description":" Ragout (Reference-Assisted Genome Ordering UTility) is a agent for\n chromosome-level scaffolding using multiple references. Given initial\n assembly fragments (contigs/scaffolds) and one or multiple related\n references (complete or draft), it produces a chromosome-scale assembly\n (as a set of scaffolds).\n .\n The approach is based on the analysis of genome rearrangements (like\n inversions or chromosomal translocations) between the input genomes and\n reconstructing the most parsimonious structure of the target genome.\n .\n Ragout now supports both small and large genomes (of mammalian scale\n and complexity). The assembly of highly polymorphic genomes is\n currently limited.","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 0 / 1","doi":"10.1101/gr.236273.118","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"rambo-k","distribution":"debian","release":"sid","component":"main","version":"1.21","source":"rambo-k","homepage":"http://rambok.sourceforge.net/","description":"Read Assignment Method Based On K-mers","long_description":" RAMBO-K is a agent for rapid and sensitive removal of background sequences\n from Next Generation Sequencing data.\n .\n RAMBO-K is a reference-based agent for rapid and sensitive extraction of\n one organisms reads from a mixed dataset. It is based on a Markov chain\n implementation, which uses genomic characteristics of each reference to\n assign reads to the associated set.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 4 / 51","doi":"10.1371/journal.pone.0137896","topics":null,"edam_scopes":null,"bio.agents":"RAMBO-K","OMICagents":"OMICS_10013","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"rampler","distribution":"debian","release":"sid","component":"main","version":"1.1.0","source":"rampler","homepage":"https://github.com/rvaser/rampler","description":"module for sampling genomic sequences","long_description":" Rampler is a module for sampling genomic sequences.  It is a\n precondition for racon.\n .\n Asked for better description in\n   https://github.com/rvaser/rampler/issues/1\n .\n For the moment it is just a precondition for racon (#890187).\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 7 / 17","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_33016","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"rapmap","distribution":"debian","release":"sid","component":"main","version":"0.12.0","source":"rapmap","homepage":"https://github.com/COMBINE-lab/RapMap","description":"rapid sensitive and accurate DNA read mapping via quasi-mapping","long_description":" RapMap is a testing ground for ideas in quasi-mapping / (lightweight /\n pseudo) transcriptome alignment. That means that, at this point, it is\n somewhat experimental. The develop branch will have the latest\n improvements and additions, but is not guaranteed to be stable between\n commits. Breaking changes to the master branch will be accompanied by a\n tag to the version before the breaking change. Currently, RapMap is a\n stand-alone quasi-mapper that can be used with other agents. It is also\n being used as part of Sailfish and Salmon. Eventually, the hope is to\n create and stabilize an API so that it can be used as a library from\n other agents.\n .\n Quasi-mapping / (lightweight / pseudo)-alignment is the term that is\n used here for the type of information required for certain tasks (e.g.\n transcript quantification) that is less \"heavyweight\" than what is\n provided by traditional alignment. For example, one may only need to\n know the transcripts / contigs to which a read aligns and, perhaps, the\n position within those transcripts rather than the optimal alignment and\n base-for-base CIGAR string that aligns the read and substring of the\n transcript. For details on RapMap (quasi-mapping in particular), please\n check out the associated paper. Note: RapMap implements both quasi-\n mapping and pseudo-alignment (originally introduced in Bray et al.\n 2016), these two are not the same thing. They are distinct concepts, and\n RapMap simply happens to implement algorithms for computing both.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 4 / 52","doi":"10.1093/bioinformatics/btw277","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_10349","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"rasmol","distribution":"debian","release":"sid","component":"main","version":"2.7.6.0","source":"rasmol","homepage":"http://rasmol.org","description":"visualization of biological macromolecules","long_description":" RasMol is a molecular graphics program intended for the visualisation of\n proteins, nucleic acids and small molecules. The program is aimed at\n display, teaching and generation of publication quality images.\n .\n The program reads in a molecule coordinate file and interactively displays\n the molecule on the screen in a variety of colour schemes and molecule\n representations. Currently available representations include depth-cued\n wireframes, 'Dreiding' sticks, spacefilling (CPK) spheres, ball and stick,\n solid and strand biomolecular ribbons, atom labels and dot surfaces.\n .\n Supported input file formats include Protein Data Bank (PDB), Tripos\n Associates' Alchemy and Sybyl Mol2 formats, Molecular Design Limited's\n (MDL) Mol file format, Minnesota Supercomputer Center's (MSC) XYZ (XMol)\n format, CHARMm format, CIF format and mmCIF format files.\n .\n This package installs two versions of RasMol, rasmol-gtk has a modern\n GTK-based user interface and rasmol-classic is the version with the old\n Xlib GUI.\n","interface":["x11"],"biology":null,"fields":["chemistry"],"use":["learning","viewing"],"popcon":"254 / 6 / 458","doi":"10.1016/S0968-0004(00)89080-5","topics":null,"edam_scopes":null,"bio.agents":"RasMol","OMICagents":"OMICS_05076","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"raster3d","distribution":"debian","release":"sid","component":"main","version":"3.0-3","source":"raster3d","homepage":"http://www.bmsc.washington.edu/raster3d/raster3d.html","description":"agents for generating images of proteins or other molecules","long_description":" Raster3D is a set of agents for generating high quality raster images of\n proteins or other molecules. The core program renders spheres, triangles,\n cylinders, and quadric surfaces with specular highlighting, Phong shading,\n and shadowing. It uses an efficient software Z-buffer algorithm which is\n independent of any graphics hardware. Ancillary programs process atomic\n coordinates from PDB files into rendering descriptions for pictures composed\n of ribbons, space-filling atoms, bonds, ball+stick, etc. Raster3D can also be\n used to render pictures composed in other programs such as Molscript in\n glorious 3D with highlights, shadowing, etc. Output is to pixel image files\n with 24 bits of color information per pixel.\n","interface":["commandline"],"biology":null,"fields":["biology","biology:structural"],"use":["viewing","converting"],"popcon":"12 / 4 / 128","doi":"10.1016/S0076-6879(97)77028-9","topics":null,"edam_scopes":null,"bio.agents":"Raster3D","OMICagents":"OMICS_05054","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"rate4site","distribution":"debian","release":"sid","component":"main","version":"3.0.0","source":"rate4site","homepage":"http://www.tau.ac.il/~itaymay/cp/rate4site.html","description":"detector of conserved amino-acid sites","long_description":" Rate4Site calculates the relative evolutionary rate at each site using a\n probabilistic-based evolutionary model.\n This allows taking into account the stochastic process underlying sequence\n evolution within protein families\n and the phylogenetic tree of the proteins in the family.\n The conservation score at a site corresponds to the site's evolutionary rate.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 3 / 109","doi":"10.1093/molbev/msh194","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_06940","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"raxml","distribution":"debian","release":"sid","component":"main","version":"8.2.12","source":"raxml","homepage":"http://www.exelixis-lab.org/","description":"Randomized Axelerated Maximum Likelihood of phylogenetic trees","long_description":" RAxML is a program for sequential and parallel Maximum Likelihood-based\n inference of large phylogenetic trees. It has originally been derived\n from fastDNAml.\n","interface":null,"biology":null,"fields":["biology"],"use":null,"popcon":"19 / 4 / 227","doi":"10.1093/bioinformatics/btu033","topics":null,"edam_scopes":null,"bio.agents":"raxml","OMICagents":null,"SEQwiki":null,"SciCrunch":{"source":"raxml","name":"SciCrunch","entry":"SCR_006086"},"RRID":null},{"package":"raxml-ng","distribution":"prospective","release":"vcs","component":"main","version":"0.2.0","source":"raxml-ng","homepage":"https://github.com/amkozlov/raxml-ng","description":"phylogenetic tree inference agent which uses maximum-likelihood","long_description":" RAxML Next Generation: faster, easier-to-use and more flexible\n .\n RAxML-NG is a phylogenetic tree inference agent which uses maximum-likelihood\n (ML) optimality criterion. Its search heuristic is based on iteratively\n performing a series of Subtree Pruning and Regrafting (SPR) moves, which\n allows to quickly navigate to the best-known ML tree. RAxML-NG is a successor\n of RAxML (Stamatakis 2014) and leverages the highly optimized likelihood\n computation implemented in libpll (Flouri et al. 2014).\n .\n RAxML-NG offers improvements in speed, flexibility and user-friendliness\n over the previous RAxML versions. It also implements some of the\n features previously available in ExaML (Kozlov et al. 2015), including\n checkpointing and efficient load balancing for partitioned alignments.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"ray","distribution":"debian","release":"sid","component":"main","version":"2.3.1","source":"ray","homepage":"http://denovoassembler.sourceforge.net/","description":"de novo genome assemblies of next-gen sequencing data","long_description":" Ray is a parallel software that computes de novo genome assemblies with\n next-generation sequencing data.\n Ray is written in C++ and can run in parallel on numerous interconnected\n computers using the message-passing interface (MPI) standard.\n Included:\n  - Ray de novo assembly of single genomes\n  - Ray Méta de novo assembly of metagenomes\n  - Ray Communities microbe abundance + taxonomic profiling\n  - Ray Ontologies gene ontology profiling\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 2 / 111","doi":"10.1089/cmb.2009.0238","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_00027","SEQwiki":null,"SciCrunch":{"source":"ray","name":"SciCrunch","entry":"SCR_001916"},"RRID":null},{"package":"r-bioc-affy","distribution":"debian","release":"sid","component":"main","version":"1.60.0","source":"r-bioc-affy","homepage":"https://bioconductor.org/packages/affy/","description":"BioConductor methods for Affymetrix Oligonucleotide Arrays","long_description":" This is part of the BioConductor GNU R suite.  The package contains\n functions for exploratory oligonucleotide array analysis.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 1 / 55","doi":"10.1093/bioinformatics/btg405","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-affyio","distribution":"debian","release":"sid","component":"main","version":"1.52.0","source":"r-bioc-affyio","homepage":"https://bioconductor.org/packages/affyio/","description":"BioConductor agents for parsing Affymetrix data files","long_description":" This BioConductor package provides routines for parsing Affymetrix data\n files based upon file format information. Primary focus is on accessing\n the CEL and CDF file formats.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 1 / 56","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-altcdfenvs","distribution":"debian","release":"sid","component":"main","version":"2.44.0","source":"r-bioc-altcdfenvs","homepage":"https://bioconductor.org/packages/altcdfenvs/","description":"BioConductor alternative CDF environments","long_description":" This BioConductor module provides alternative CDF environments (aka\n probeset mappings) which are Convenience data structures and functions\n to handle cdfenvs.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 1 / 45","doi":"doi:10.1186/1471-2105-5-111","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-annotate","distribution":"debian","release":"sid","component":"main","version":"1.60.0","source":"r-bioc-annotate","homepage":"https://bioconductor.org/packages/annotate/","description":"BioConductor annotation for microarrays","long_description":" This BioConductor module provides methods for annotation for microarrays\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"21 / 13 / 130","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-annotationdbi","distribution":"debian","release":"sid","component":"main","version":"1.44.0","source":"r-bioc-annotationdbi","homepage":"https://bioconductor.org/packages/AnnotationDbi/","description":"GNU R Annotation Database Interface for BioConductor","long_description":" This BioConductor module provides user interface and database\n connection code for annotation data packages using SQLite data\n storage.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"23 / 27 / 200","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-annotationhub","distribution":"debian","release":"sid","component":"main","version":"2.14.3","source":"r-bioc-annotationhub","homepage":"https://bioconductor.org/packages/AnnotationHub/","description":"GNU R client to access AnnotationHub resources","long_description":" This package provides a client for the Bioconductor AnnotationHub web\n resource. The AnnotationHub web resource provides a central location\n where genomic files (e.g., VCF, bed, wig) and other resources from\n standard locations (e.g., UCSC, Ensembl) can be discovered. The resource\n includes metadata about each resource, e.g., a textual description,\n tags, and date of modification. The client creates and manages a local\n cache of files retrieved by the user, helping with quick and\n reproducible access.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 9 / 100","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"annotationhub","OMICagents":"OMICS_29380","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-aroma.light","distribution":"debian","release":"sid","component":"main","version":"3.12.0","source":"r-bioc-aroma.light","homepage":"https://bioconductor.org/packages/aroma.light/","description":"BioConductor methods normalization and visualization of microarray data","long_description":" This BioConductor module provides light-weight methods for\n normalization and visualization of microarray data using only basic R\n data types.\n .\n Methods for microarray analysis that take basic data types such as\n matrices and lists of vectors. These methods can be used standalone, be\n utilized in other packages, or be wrapped up in higher-level classes.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"10 / 1 / 61","doi":"10.1186/1471-2105-11-245","topics":null,"edam_scopes":null,"bio.agents":"aroma.light","OMICagents":"OMICS_01998","SEQwiki":null,"SciCrunch":{"source":"r-bioc-aroma.light","name":"SciCrunch","entry":"SCR_001312"},"RRID":null},{"package":"r-bioc-biobase","distribution":"debian","release":"sid","component":"main","version":"2.42.0","source":"r-bioc-biobase","homepage":"https://bioconductor.org/packages/Biobase/","description":"base functions for Bioconductor","long_description":" Biobase is part of the Bioconductor project, and is used by many other\n packages. Biobase contains standardized data structures to represent genomic\n data, and functions that are needed by many other packages or which replace R\n functions.\n .\n Bioconductor is a project to develop innovative software agents for use in\n computational biology. It is based on the R language. You should already be\n quite familiar with R before using Bioconductor. Bioconductor packages provide\n flexible interactive agents for carrying out a number of different computational\n tasks.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"31 / 32 / 368","doi":"10.1186/gb-2004-5-10-r80","topics":null,"edam_scopes":null,"bio.agents":"biobase","OMICagents":"OMICS_29442","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-biocgenerics","distribution":"debian","release":"sid","component":"main","version":"0.28.0","source":"r-bioc-biocgenerics","homepage":"https://bioconductor.org/packages/BiocGenerics/","description":"generic functions for Bioconductor","long_description":" S4 generic functions needed by many other Bioconductor packages.\n .\n Bioconductor provides agents for the analysis and comprehension of\n high-throughput genomic data. Bioconductor uses the R statistical\n programming language, and is open source and open development.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"38 / 38 / 407","doi":"10.1038/nmeth.3252","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-biomart","distribution":"debian","release":"sid","component":"main","version":"2.38.0","source":"r-bioc-biomart","homepage":"https://bioconductor.org/packages/biomaRt/","description":"GNU R Interface to BioMart databases (Ensembl, COSMIC, Wormbase and Gramene)","long_description":" In recent years a wealth of biological data has become available in\n public data repositories. Easy access to these valuable data resources\n and firm integration with data analysis is needed for comprehensive\n bioinformatics data analysis. biomaRt provides an interface to a growing\n collection of databases implementing the BioMart software suite\n (http://www.biomart.org). The package enables retrieval of large amounts\n of data in a uniform way without the need to know the underlying\n database schemas or write complex SQL queries. Examples of BioMart\n databases are Ensembl, COSMIC, Uniprot, HGNC, Gramene, Wormbase and\n dbSNP mapped to Ensembl. These major databases give biomaRt users direct\n access to a diverse set of data and enable a wide range of powerful\n online queries from gene annotation to database mining.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"15 / 25 / 172","doi":"10.1038/nprot.2009.97","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-biomformat","distribution":"debian","release":"sid","component":"main","version":"1.10.1","source":"r-bioc-biomformat","homepage":"https://bioconductor.org/packages/biomformat/","description":"GNU R interface package for the BIOM file format","long_description":" This is an R package for interfacing with the BIOM format. This package\n includes basic agents for reading biom-format files, accessing and\n subsetting data tables from a biom object (which is more complex than a\n single table), as well as limited support for writing a biom-object back\n to a biom-format file. The design of this API is intended to match the\n Python API and other agents included with the biom-format project, but\n with a decidedly \"R flavor\" that should be familiar to R users. This\n includes S4 classes and methods, as well as extensions of common core\n functions/methods.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 5 / 84","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-biostrings","distribution":"debian","release":"sid","component":"main","version":"2.50.2","source":"r-bioc-biostrings","homepage":"https://bioconductor.org/packages/Biostrings/","description":"GNU R string objects representing biological sequences","long_description":" Memory efficient string containers, string matching algorithms, and other\n utilities, for fast manipulation of large biological sequences or set of\n sequences.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"19 / 30 / 193","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"biostrings","OMICagents":"OMICS_29386","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-biovizbase","distribution":"debian","release":"sid","component":"main","version":"1.30.1","source":"r-bioc-biovizbase","homepage":"https://bioconductor.org/packages/biovizBase/","description":"GNU R basic graphic utilities for visualization of genomic data","long_description":" The biovizBase package is designed to provide a set of utilities, color\n schemes and conventions for genomic data. It serves as the base for\n various high-level packages for biological data visualization. This\n saves development effort and encourages consistency.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"12 / 4 / 156","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-bitseq","distribution":"debian","release":"sid","component":"main","version":"1.26.1","source":"r-bioc-bitseq","homepage":"https://bioconductor.org/packages/BitSeq/","description":"transcript expression inference and analysis for RNA-seq data","long_description":" The BitSeq package is targeted for transcript expression\n analysis and differential expression analysis of RNA-seq data\n in two stage process. In the first stage it uses Bayesian\n inference methodology to infer expression of individual\n transcripts from individual RNA-seq experiments. The second\n stage of BitSeq embraces the differential expression analysis\n of transcript expression. Providing expression estimates from\n replicates of multiple conditions, Log-Normal model of the\n estimates is used for inferring the condition mean transcript\n expression and ranking the transcripts based on the likelihood\n of differential expression.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 2 / 25","doi":"10.1093/bioinformatics/bts260","topics":null,"edam_scopes":null,"bio.agents":"bitseq","OMICagents":"OMICS_01269","SEQwiki":null,"SciCrunch":{"source":"r-bioc-bitseq","name":"SciCrunch","entry":"SCR_009904"},"RRID":null},{"package":"r-bioc-bsgenome","distribution":"debian","release":"sid","component":"main","version":"1.50.0","source":"r-bioc-bsgenome","homepage":"https://bioconductor.org/packages/BSgenome/","description":"BioConductor infrastructure for Biostrings-based genome data packages","long_description":" This BioConductor module provides some basic infrastructure for\n Biostrings-based genome data packages.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"15 / 10 / 170","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-cner","distribution":"debian","release":"sid","component":"main","version":"1.18.1","source":"r-bioc-cner","homepage":"https://bioconductor.org/packages/CNEr/","description":"CNE Detection and Visualization","long_description":" Large-scale identification and advanced visualization\n of sets of conserved noncoding elements.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 8 / 19","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"cner","OMICagents":"OMICS_33013","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-cummerbund","distribution":"debian","release":"sid","component":"main","version":"2.24.0","source":"r-bioc-cummerbund","homepage":"https://bioconductor.org/packages/cummeRbund/","description":"agent for analysis of Cufflinks RNA-Seq output","long_description":" Allows for persistent storage, access, exploration, and manipulation of\n Cufflinks high-throughput sequencing data. In addition, provides\n numerous plotting functions for commonly used visualizations.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 2 / 116","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"cummerbund","OMICagents":"OMICS_07349","SEQwiki":null,"SciCrunch":{"source":"r-bioc-cummerbund","name":"SciCrunch","entry":"SCR_014568"},"RRID":null},{"package":"r-bioc-deseq2","distribution":"debian","release":"sid","component":"main","version":"1.22.2","source":"r-bioc-deseq2","homepage":"https://bioconductor.org/packages/DESeq2/","description":"R package for RNA-Seq Differential Expression Analysis","long_description":" Differential gene expression analysis based on the negative binomial\n distribution. Estimate variance-mean dependence in count data from\n high-throughput sequencing assays and test for differential expression based\n on a model using the negative binomial distribution.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"10 / 4 / 100","doi":"http://dx.doi.org/10.1186/s13059-014-0550-8","topics":null,"edam_scopes":null,"bio.agents":"deseq2","OMICagents":"OMICS_01306","SEQwiki":null,"SciCrunch":{"source":"r-bioc-deseq2","name":"SciCrunch","entry":"SCR_000154"},"RRID":null},{"package":"r-bioc-dnacopy","distribution":"debian","release":"sid","component":"main","version":"1.56.0","source":"r-bioc-dnacopy","homepage":"https://www.bioconductor.org/packages/DNAcopy/","description":"R package: DNA copy number data analysis","long_description":" Implements the circular binary segmentation (CBS) algorithm to segment DNA\n copy number data and identify genomic regions with abnormal copy number.\n .\n This package is for analyzing array DNA copy number data, which is usually\n (but not always) called array Comparative Genomic Hybridization (array CGH)\n data It implements a methodology for finding change-points in these data which\n are points after which the (log) test over reference ratios have changed\n location. This model is that the change-points correspond to positions where\n the underlying DNA copy number has changed. Therefore, change-points can be\n used to identify regions of gained and lost copy number. Also provided is a\n function for making relevant plots of these data.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"13 / 6 / 112","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"dnacopy","OMICagents":"OMICS_00720","SEQwiki":null,"SciCrunch":{"source":"r-bioc-dnacopy","name":"SciCrunch","entry":"SCR_012560"},"RRID":null},{"package":"r-bioc-ebseq","distribution":"debian","release":"sid","component":"main","version":"1.22.1","source":"r-bioc-ebseq","homepage":"https://bioconductor.org/packages/EBSeq/","description":"R package for RNA-Seq Differential Expression Analysis","long_description":" r-bioc-ebseq is an R package for identifying genes and isoforms differentially\n expressed (DE) across two or more biological conditions in an RNA-seq\n experiment.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 17 / 80","doi":"http://dx.doi.org/10.1093/bioinformatics/btt087","topics":null,"edam_scopes":null,"bio.agents":"ebseq","OMICagents":"OMICS_01307","SEQwiki":null,"SciCrunch":{"source":"r-bioc-ebseq","name":"SciCrunch","entry":"SCR_003526"},"RRID":null},{"package":"r-bioc-ensembldb","distribution":"debian","release":"sid","component":"main","version":"2.6.5","source":"r-bioc-ensembldb","homepage":"https://bioconductor.org/packages/ensembldb/","description":"GNU R utilities to create and use an Ensembl based annotation database","long_description":" The package provides functions to create and use transcript centric\n annotation databases/packages. The annotation for the databases are\n directly fetched from Ensembl using their Perl API. The functionality\n and data is similar to that of the TxDb packages from the\n GenomicFeatures package, but, in addition to retrieve all\n gene/transcript models and annotations from the database, the ensembldb\n package provides also a filter framework allowing to retrieve\n annotations for specific entries like genes encoded on a chromosome\n region or transcript models of lincRNA genes.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"12 / 24 / 109","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"ensembldb","OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-genefilter","distribution":"debian","release":"sid","component":"main","version":"1.64.0","source":"r-bioc-genefilter","homepage":"https://bioconductor.org/packages/genefilter/","description":"methods for filtering genes from microarray experiments","long_description":" This BioConductor module provides methods for filtering genes from microarray\n experiments.  It contains some basic functions for filtering genes.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"21 / 5 / 126","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"genefilter","OMICagents":"OMICS_29382","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-geneplotter","distribution":"debian","release":"sid","component":"main","version":"1.60.0","source":"r-bioc-geneplotter","homepage":"https://bioconductor.org/packages/geneplotter/","description":"R package of functions for plotting genomic data","long_description":" geneplotter contains plotting functions for microarrays\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"11 / 4 / 104","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"geneplotter","OMICagents":"OMICS_15854","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-genomeinfodb","distribution":"debian","release":"sid","component":"main","version":"1.18.1","source":"r-bioc-genomeinfodb","homepage":"https://bioconductor.org/packages/GenomeInfoDb/","description":"BioConductor utilities for manipulating chromosome identifiers","long_description":" This package contains BioConductor utilities for manipulating\n chromosome and other 'seqname' identifiers.\n .\n The Seqnames package contains data and functions that define and allow\n translation between different chromosome sequence naming conventions\n (e.g., \"chr1\" versus \"1\"), including a function that attempts to place\n sequence names in their natural, rather than lexicographic, order.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"21 / 29 / 206","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-genomicalignments","distribution":"debian","release":"sid","component":"main","version":"1.18.1","source":"r-bioc-genomicalignments","homepage":"https://bioconductor.org/packages/GenomicAlignments/","description":"BioConductor representation and manipulation of short genomic alignments","long_description":" This BioConductor package provides efficient containers for storing and\n manipulating short genomic alignments (typically obtained by aligning\n short reads to a reference genome). This includes read counting,\n computing the coverage, junction detection, and working with the\n nucleotide content of the alignments.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"19 / 13 / 182","doi":"10.1371/journal.pcbi.1003118","topics":null,"edam_scopes":null,"bio.agents":"genomicalignments","OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-genomicfeatures","distribution":"debian","release":"sid","component":"main","version":"1.34.3","source":"r-bioc-genomicfeatures","homepage":"https://bioconductor.org/packages/GenomicFeatures/","description":"GNU R agents for making and manipulating transcript centric annotations","long_description":" A set of agents and methods for making and manipulating transcript\n centric annotations. With these agents the user can easily download the\n genomic locations of the transcripts, exons and cds of a given organism,\n from either the UCSC Genome Browser or a BioMart database (more sources\n will be supported in the future). This information is then stored in a\n local database that keeps track of the relationship between transcripts,\n exons, cds and genes. Flexible methods are provided for extracting the\n desired features in a convenient format.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"14 / 25 / 163","doi":"10.1371/journal.pcbi.1003118","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-genomicranges","distribution":"debian","release":"sid","component":"main","version":"1.34.0","source":"r-bioc-genomicranges","homepage":"https://bioconductor.org/packages/GenomicRanges/","description":"BioConductor representation and manipulation of genomic intervals","long_description":" The ability to efficiently store genomic annotations and alignments is\n playing a central role when it comes to analyze high-throughput\n sequencing data (a.k.a. NGS data). The package defines general purpose\n containers for storing genomic intervals as well as more specialized\n containers for storing alignments against a reference genome.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"22 / 28 / 205","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-go.db","distribution":"debian","release":"sid","component":"main","version":"3.7.0","source":"r-bioc-go.db","homepage":"https://bioconductor.org/packages/GO.db/","description":"annotation maps describing the entire Gene Ontology","long_description":" This package is part of BioConductor and provides a set of annotation\n maps describing the entire Gene Ontology assembled using data from GO.\n .\n The package helps running the test suites of some BioConductor packages.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"15 / 9 / 72","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_22608","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-graph","distribution":"debian","release":"sid","component":"main","version":"1.60.0","source":"r-bioc-graph","homepage":"https://bioconductor.org/packages/graph/","description":"handle graph data structures for BioConductor","long_description":" This BioConductor module implements some simple graph handling\n capabilities.  These are for instance used in hypergraph module\n which in turn is used by several other BioConductor packages.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"11 / 1 / 84","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-gviz","distribution":"debian","release":"sid","component":"main","version":"1.26.4","source":"r-bioc-gviz","homepage":"https://bioconductor.org/packages/Gviz/","description":"Plotting data and annotation information along genomic coordinates","long_description":" Genomic data analyses requires integrated visualization of known\n genomic information and new experimental data. Gviz uses the biomaRt and\n the rtracklayer packages to perform live annotation queries to Ensembl\n and UCSC and translates this to e.g. gene/transcript structures in\n viewports of the grid graphics package. This results in genomic\n information plotted together with your data.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 2 / 149","doi":"10.1093/bioinformatics/btp328","topics":null,"edam_scopes":null,"bio.agents":"gviz","OMICagents":"OMICS_17191","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-hilbertvis","distribution":"debian","release":"sid","component":"main","version":"1.40.0","source":"r-bioc-hilbertvis","homepage":"https://bioconductor.org/packages/HilbertVis","description":"GNU R package to visualise long vector data","long_description":" This agent allows one to display very long data vectors in a space-efficient\n manner, by organising it along a 2D Hilbert curve. The user can then\n visually judge the large scale structure and distribution of features\n simultaenously with the rough shape and intensity of individual features.\n .\n In bioinformatics, a typical use case is ChIP-Chip and ChIP-Seq,\n or basically all the kinds of genomic data, that are conventionally\n displayed as quantitative track (\"wiggle data\") in genome browsers such\n as those provided by Ensembl or UCSC.\n","interface":null,"biology":["nuceleic-acids"],"fields":["biology","biology:bioinformatics"],"use":["analysing"],"popcon":"13 / 2 / 119","doi":"10.1093/bioinformatics/btp152","topics":null,"edam_scopes":null,"bio.agents":"hilbertvis","OMICagents":"OMICS_00627","SEQwiki":null,"SciCrunch":{"source":"r-bioc-hilbertvis","name":"SciCrunch","entry":"SCR_007862"},"RRID":null},{"package":"r-bioc-hypergraph","distribution":"debian","release":"sid","component":"main","version":"1.54.0","source":"r-bioc-hypergraph","homepage":"https://bioconductor.org/packages/hypergraph/","description":"BioConductor hypergraph data structures","long_description":" This package BioConductor implements some simple capabilities for\n representing and manipulating hypergraphs.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 1 / 47","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-impute","distribution":"debian","release":"sid","component":"main","version":"1.56.0","source":"r-bioc-impute","homepage":"https://bioconductor.org/packages/impute/","description":"Imputation for microarray data","long_description":" R package which provide a function to perform imputation for\n microarray data (currently KNN only).\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 9 / 34","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"impute","OMICagents":"OMICS_31016","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-iranges","distribution":"debian","release":"sid","component":"main","version":"2.16.0","source":"r-bioc-iranges","homepage":"https://bioconductor.org/packages/IRanges/","description":"GNU R low-level containers for storing sets of integer ranges","long_description":" The IRanges class and its extensions are low-level containers for\n storing sets of integer ranges. A typical use of these containers in\n biology is for representing a set of chromosome regions. More specific\n extensions of the IRanges class will typically allow the storage of\n additional information attached to each chromosome region as well as a\n hierarchical relationship between these regions.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"23 / 30 / 217","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-limma","distribution":"debian","release":"sid","component":"main","version":"3.38.3","source":"r-bioc-limma","homepage":"https://bioconductor.org/packages/limma/","description":"linear models for microarray data","long_description":" A Bioconductor package for the analysis of gene expression microarray data,\n especially the use of linear models for analysing designed experiments and the\n assessment of differential expression. The package includes pre-processing\n capabilities for two-colour spotted arrays. The differential expression methods\n apply to all array platforms and treat Affymetrix, single channel and two\n channel experiments in a unified way.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"26 / 29 / 702","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"limma","OMICagents":"OMICS_00769","SEQwiki":null,"SciCrunch":{"source":"r-bioc-limma","name":"SciCrunch","entry":"SCR_010943"},"RRID":null},{"package":"r-bioc-makecdfenv","distribution":"debian","release":"sid","component":"main","version":"1.58.0","source":"r-bioc-makecdfenv","homepage":"https://bioconductor.org/packages/makecdfenv/","description":"BioConductor CDF Environment Maker","long_description":" This package has two functions. One reads a Affymetrix chip description\n file (CDF) and creates a hash table environment containing the\n location/probe set membership mapping. The other creates a package that\n automatically loads that environment.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 1 / 46","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-mergeomics","distribution":"debian","release":"sid","component":"main","version":"1.10.0","source":"r-bioc-mergeomics","homepage":"https://bioconductor.org/packages/Mergeomics/","description":"Integrative network analysis of omics data","long_description":" The Mergeomics pipeline serves as a flexible framework for integrating\n multidimensional omics-disease associations, functional genomics,\n canonical pathways and gene-gene interaction networks to generate\n mechanistic hypotheses. It includes two main parts:\n 1) Marker set enrichment analysis (MSEA);\n 2) Weighted Key Driver Analysis (wKDA).\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 2 / 79","doi":"10.1186/s12864-016-3198-9","topics":null,"edam_scopes":null,"bio.agents":"mergeomics","OMICagents":"OMICS_12862","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-metagenomeseq","distribution":"debian","release":"sid","component":"main","version":"1.24.1","source":"r-bioc-metagenomeseq","homepage":"https://bioconductor.org/packages/metagenomeSeq/","description":"GNU R statistical analysis for sparse high-throughput sequencing","long_description":" MetagenomeSeq is designed to determine features (be it Operational\n Taxanomic Unit (OTU), species, etc.) that are differentially abundant\n between two or more groups of multiple samples. metagenomeSeq is\n designed to address the effects of both normalization and under-sampling\n of microbial communities on disease association detection and the\n testing of feature correlations.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 3 / 81","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"metagenomeseq","OMICagents":"OMICS_07813","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-pcamethods","distribution":"debian","release":"sid","component":"main","version":"1.74.0","source":"r-bioc-pcamethods","homepage":"https://bioconductor.org/packages/pcaMethods/","description":"BioConductor collection of PCA methods","long_description":" Provides Bayesian PCA, Probabilistic PCA, Nipals PCA,\n Inverse Non-Linear PCA and the conventional SVD PCA. A cluster\n based method for missing value estimation is included for\n comparison. BPCA, PPCA and NipalsPCA may be used to perform PCA\n on incomplete data as well as for accurate missing value\n estimation. A set of methods for printing and plotting the\n results is also provided. All PCA methods make use of the same\n data structure (pcaRes) to provide a common interface to the\n PCA results. Initiated at the Max-Planck Institute for\n Molecular Plant Physiology, Golm, Germany.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 1 / 25","doi":"10.1093/bioinformatics/btm069","topics":null,"edam_scopes":null,"bio.agents":"pcamethods","OMICagents":"OMICS_14344","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-phyloseq","distribution":"debian","release":"sid","component":"main","version":"1.26.1","source":"r-bioc-phyloseq","homepage":"https://bioconductor.org/packages/phyloseq/","description":"GNU R handling and analysis of high-throughput microbiome census data","long_description":" The Bioconductor module phyloseq provides a set of classes and agents to\n facilitate the import, storage, analysis, and graphical display of\n microbiome census data.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 4 / 78","doi":"10.1371/journal.pone.0061217","topics":null,"edam_scopes":null,"bio.agents":"phyloseq","OMICagents":"OMICS_01520","SEQwiki":null,"SciCrunch":{"source":"r-bioc-phyloseq","name":"SciCrunch","entry":"SCR_013080"},"RRID":null},{"package":"r-bioc-preprocesscore","distribution":"debian","release":"sid","component":"main","version":"1.44.0","source":"r-bioc-preprocesscore","homepage":"https://bioconductor.org/packages/preprocessCore/","description":"BioConductor collection of pre-processing functions","long_description":" This BioConductor module contains a library of pre-processing\n functions.  It is imported by several other BioConductor modules.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 2 / 60","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-rbgl","distribution":"debian","release":"sid","component":"main","version":"1.58.1","source":"r-bioc-rbgl","homepage":"https://bioconductor.org/packages/RBGL/","description":"R interface to the graph algorithms contained in the BOOST library","long_description":" RBGL is part of the BioConductor GNU R suite. It is a fairly extensive and\n comprehensive interface to the graph algorithms contained in the BOOST C++\n libraries.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 0 / 33","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-rsamagents","distribution":"debian","release":"sid","component":"main","version":"1.34.1","source":"r-bioc-rsamagents","homepage":"https://bioconductor.org/packages/Rsamagents/","description":"GNU R binary alignment (BAM), variant call (BCF), or tabix file import","long_description":" This package provides an interface to the 'samagents', 'bcfagents', and\n 'tabix' utilities for manipulating SAM (Sequence Alignment / Map),\n binary variant call (BCF) and compressed indexed tab-delimited (tabix)\n files.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"17 / 27 / 183","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-rtracklayer","distribution":"debian","release":"sid","component":"main","version":"1.42.1","source":"r-bioc-rtracklayer","homepage":"https://bioconductor.org/packages/rtracklayer/","description":"GNU R interface to genome browsers and their annotation tracks","long_description":" Extensible framework for interacting with multiple genome browsers\n (currently UCSC built-in) and manipulating annotation tracks in various\n formats (currently GFF, BED, bedGraph, BED15, WIG, BigWig and 2bit\n built-in). The user may export/import tracks to/from the supported\n browsers, as well as query and modify the browser state, such as the\n current viewport.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"16 / 24 / 170","doi":"10.1093/bioinformatics/btp328","topics":null,"edam_scopes":null,"bio.agents":"rtracklayer","OMICagents":"OMICS_09883","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-savr","distribution":"debian","release":"sid","component":"main","version":"1.20.0","source":"r-bioc-savr","homepage":"https://bioconductor.org/packages/savR/","description":"GNU R parse and analyze Illumina SAV files","long_description":" This BioConductor module enables to parse Illumina Sequence Analysis\n Viewer (SAV) files, access data, and generate QC plots.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 0 / 48","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"OMICS_15992","OMICagents":"OMICS_15992","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-shortread","distribution":"debian","release":"sid","component":"main","version":"1.40.0","source":"r-bioc-shortread","homepage":"https://bioconductor.org/packages/ShortRead/","description":"GNU R classes and methods for high-throughput short-read sequencing data","long_description":" This BioConductor module is a package for input, quality assessment,\n manipulation and output of high-throughput sequencing data. ShortRead is\n provided in the R and Bioconductor environments, allowing ready access\n to additional facilities for advanced statistical analysis, data\n transformation, visualization and integration with diverse genomic\n resources.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"16 / 1 / 151","doi":"10.1093/bioinformatics/btp450","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-snpstats","distribution":"debian","release":"sid","component":"main","version":"1.32.0","source":"r-bioc-snpstats","homepage":"https://bioconductor.org/packages/snpStats/","description":"BioConductor SnpMatrix and XSnpMatrix classes and methods","long_description":" This BioConductor package provides R functions to work with\n SnpMatrix and XSnpMatrix classes and methods.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"11 / 2 / 70","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-tfbsagents","distribution":"debian","release":"sid","component":"main","version":"1.20.0","source":"r-bioc-tfbsagents","homepage":"https://bioconductor.org/packages/TFBSAgents/","description":"GNU R Transcription Factor Binding Site (TFBS) Analysis","long_description":" TFBSAgents is a package for the analysis and manipulation of\n transcription factor binding sites. It includes matrices conversion\n between Position Frequency Matirx (PFM), Position Weight Matirx (PWM)\n and Information Content Matrix (ICM). It can also scan putative TFBS\n from sequence/alignment, query JASPAR database and provides a wrapper of\n de novo motif discovery software.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 8 / 17","doi":"10.1093/bioinformatics/btw024","topics":null,"edam_scopes":null,"bio.agents":"tfbsagents","OMICagents":"OMICS_11082","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-variantannotation","distribution":"debian","release":"sid","component":"main","version":"1.28.10","source":"r-bioc-variantannotation","homepage":"https://bioconductor.org/packages/VariantAnnotation/","description":"BioConductor annotation of genetic variants","long_description":" This BioConductor package provides R functions to annotate variants,\n compute amino acid coding changess and to predict coding outcomes.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"13 / 11 / 161","doi":"10.1093/bioinformatics/btu168","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-bioc-xvector","distribution":"debian","release":"sid","component":"main","version":"0.22.0","source":"r-bioc-xvector","homepage":"https://bioconductor.org/packages/XVector/","description":"BioConductor representation and manpulation of external sequences","long_description":" This BioConductor package provides memory efficient S4 classes for storing\n sequences \"externally\" (behind an R external pointer, or on disk).\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"23 / 30 / 210","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-cran-adegenet","distribution":"debian","release":"sid","component":"main","version":"2.1.1","source":"r-cran-adegenet","homepage":"https://cran.r-project.org/package=adegenet","description":"GNU R exploratory analysis of genetic and genomic data","long_description":" Agentset for the exploration of genetic and genomic data. Adegenet\n provides formal (S4) classes for storing and handling various genetic\n data, including genetic markers with varying ploidy and hierarchical\n population structure ('genind' class), alleles counts by populations\n ('genpop'), and genome-wide SNP data ('genlight'). It also implements\n original multivariate methods (DAPC, sPCA), graphics, statistical tests,\n simulation agents, distance and similarity measures, and several spatial\n methods. A range of both empirical and simulated datasets is also\n provided to illustrate various methods.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"14 / 5 / 113","doi":"10.1093/bioinformatics/btn129","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_11078","SEQwiki":null,"SciCrunch":{"source":"r-cran-adegenet","name":"SciCrunch","entry":"SCR_000825"},"RRID":null},{"package":"r-cran-adephylo","distribution":"debian","release":"sid","component":"main","version":"1.1-11","source":"r-cran-adephylo","homepage":"https://cran.r-project.org/package=adephylo","description":"GNU R exploratory analyses for the phylogenetic comparative method","long_description":" This GNU R package provides multivariate agents to analyze comparative\n data, i.e. a phylogeny and some traits measured for each taxa.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"12 / 5 / 109","doi":"10.1093/bioinformatics/btq292","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_08682","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-cran-alakazam","distribution":"debian","release":"sid","component":"main","version":"0.2.11","source":"r-cran-alakazam","homepage":"https://cran.r-project.org/package=alakazam","description":"Immunoglobulin Clonal Lineage and Diversity Analysis","long_description":" Alakazam is part of the Immcantation analysis framework for Adaptive\n Immune Receptor Repertoire sequencing (AIRR-seq) and provides a set of\n agents to investigate lymphocyte receptor clonal lineages, diversity,\n gene usage, and other repertoire level properties, with a focus on\n high-throughput immunoglobulin (Ig) sequencing.\n .\n Alakazam serves five main purposes:\n  * Providing core functionality for other R packages in the Immcantation\n    framework. This includes common tasks such as file I/O, basic DNA\n    sequence manipulation, and interacting with V(D)J segment and gene\n    annotations.\n  * Providing an R interface for interacting with the output of the\n    pRESTO and Change-O agent suites.\n  * Performing lineage reconstruction on clonal populations of Ig\n    sequences and analyzing the topology of the resultant lineage trees.\n  * Performing clonal abundance and diversity analysis on lymphocyte\n    repertoires.\n  * Performing physicochemical property analyses of lymphocyte receptor\n    sequences.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 8 / 22","doi":"10.1093/bioinformatics/btv359","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_21399","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-cran-ape","distribution":"debian","release":"sid","component":"main","version":"5.2","source":"r-cran-ape","homepage":"https://cran.r-project.org/package=ape","description":"GNU R package for Analyses of Phylogenetics and Evolution","long_description":" This package provides functions for reading, writing, plotting, and\n manipulating phylogenetic trees, analyses of comparative data in a\n phylogenetic framework, ancestral character analyses, analyses of\n diversification and macroevolution, computing distances from DNA\n sequences, reading and writing nucleotide sequences as well as\n importing from BioConductor, and several agents such as Mantel's test,\n generalized skyline plots, graphical exploration of phylogenetic data\n (alex, trex, kronoviz), estimation of absolute evolutionary rates and\n clock-like trees using mean path lengths and penalized likelihood,\n dating trees with non-contemporaneous sequences, translating DNA into\n AA sequences, and assessing sequence alignments. Phylogeny estimation\n can be done with the NJ, BIONJ, ME, MVR, SDM, and triangle methods,\n and several methods handling incomplete distance matrices (NJ*,\n BIONJ*, MVR*, and the corresponding triangle method). Some functions\n call external applications (PhyML, Clustal, T-Coffee, Muscle) whose\n results are returned into R.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"30 / 28 / 234","doi":"10.1093/bioinformatics/bty633","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_12495","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-cran-bio3d","distribution":"debian","release":"sid","component":"main","version":"2.3-4","source":"r-cran-bio3d","homepage":"https://cran.r-project.org/package=bio3d","description":"GNU R package for biological structure analysis","long_description":" The bio3d package contains utilities to process, organize and explore\n protein structure, sequence and dynamics data.  Features include the\n ability to read and write structure, sequence and dynamic trajectory\n data, perform atom summaries, atom selection, re-orientation,\n superposition, rigid core identification, clustering, torsion analysis,\n distance matrix analysis, structure and sequence conservation analysis,\n and principal component analysis (PCA).  In addition, various utility\n functions are provided to enable the statistical and graphical power of\n the R environment to work with biological sequence and structural data.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"15 / 4 / 114","doi":"10.1093/bioinformatics/btl461","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_12577","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-cran-boolnet","distribution":"debian","release":"sid","component":"main","version":"2.1.4","source":"r-cran-boolnet","homepage":"https://cran.r-project.org/package=BoolNet","description":"assembling, analyzing and visualizing Boolean networks","long_description":" BoolNet is an R package that provides agents for assembling, analyzing and\n visualizing synchronous and asynchronous Boolean networks as well as\n probabilistic Boolean networks.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"12 / 2 / 81","doi":"10.1093/bioinformatics/btq124","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_06963","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-cran-distory","distribution":"debian","release":"sid","component":"main","version":"1.4.3","source":"r-cran-distory","homepage":"https://cran.r-project.org/package=distory","description":"GNU R distance between phylogenetic histories","long_description":" This GNU R package enables calculation of geodesic distance between\n phylogenetic trees and associated functions.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"14 / 4 / 112","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_33012","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-cran-genabel","distribution":"debian","release":"sid","component":"main","version":"1.8-0","source":"r-cran-genabel","homepage":"https://cran.r-project.org/package=GenABEL","description":"GNU R package for genome-wide SNP association analysis","long_description":" The package offers the R library GenABEL for the hunt of genetic contributions\n to a disease (or any other pheonypical trait) by so called genome-wide\n association analysis. Additional input commonly comes from DNA mircoarray\n experiments, performed on every individual, that determine differences\n (polymorphisms) in the population. GenABEL finds associations between\n quantitative or binary traits and single-nucleiotide polymorphisms\n (SNPs).\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"19 / 4 / 161","doi":"10.1093/bioinformatics/btm108","topics":null,"edam_scopes":null,"bio.agents":"GENABEL","OMICagents":"OMICS_00234","SEQwiki":null,"SciCrunch":{"source":"r-cran-genabel","name":"SciCrunch","entry":"SCR_001842"},"RRID":null},{"package":"r-cran-genetics","distribution":"debian","release":"sid","component":"main","version":"1.3.8.1.1","source":"r-cran-genetics","homepage":"https://cran.r-project.org/package=genetics","description":"GNU R package for population genetics","long_description":" Classes and methods for handling genetic data. Includes\n The package provides a library for the statistics environment R that\n contains classes to represent genotypes and haplotypes at single markers up\n to multiple markers on multiple chromosomes. Function include\n allele frequencies, flagging homo/heterozygotes, flagging carriers\n of certain alleles, estimating and testing for Hardy-Weinberg\n disequilibrium, estimating and testing for linkage disequilibrium,\n and more.\n .\n NOTE: THIS PACKAGE IS NOW OBSOLETE.\n .\n The R-Genetics project has developed an set of enhanced genetics\n packages to replace 'genetics'. Please visit the project homepage\n at http://rgenetics.org for information.\n","interface":null,"biology":null,"fields":["biology:molecular","biology","biology:bioinformatics","biology:structural"],"use":["analysing"],"popcon":"17 / 21 / 130","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-cran-haplo.stats","distribution":"debian","release":"sid","component":"main","version":"1.7.9","source":"r-cran-haplo.stats","homepage":"https://cran.r-project.org/package=haplo.stats","description":"GNU R package for haplotype analysis","long_description":" The package provides routines for the GNU R statistics environment\n for statistical Analysis of indirectly measured Haplotypes with Traits\n and Covariates when Linkage Phase is Ambiguous.  The statistical methods\n assume that all subjects are unrelated and that haplotypes are ambiguous\n (due to unknown linkage phase of the genetic markers). The main functions\n are: haplo.em, haplo.glm, haplo.score, haplo.power, and seqhap.\n","interface":null,"biology":null,"fields":["biology","biology:bioinformatics"],"use":["analysing"],"popcon":"14 / 2 / 121","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-cran-metamix","distribution":"debian","release":"sid","component":"main","version":"0.3","source":"r-cran-metamix","homepage":"https://cran.r-project.org/package=metaMix","description":"GNU R bayesian mixture analysis for metagenomic community profiling","long_description":" Resolves complex metagenomic mixtures by analysing deep sequencing\n data, using a mixture model based approach. The use of parallel Monte\n Carlo Markov chains for the exploration of the species space enables\n the identification of the set of species more likely to contribute to\n the mixture.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 19 / 25","doi":"10.1093/bioinformatics/btv317","topics":null,"edam_scopes":null,"bio.agents":"metaMix","OMICagents":"OMICS_09072","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-cran-natserv","distribution":"debian","release":"sid","component":"main","version":"0.3.0","source":"r-cran-natserv","homepage":"https://cran.r-project.org/package=natserv","description":"GNU R 'NatureServe' Interface","long_description":" Interface to 'NatureServe' (<http://www.natureserve.org>).\n Includes methods to get data, image metadata, search taxonomic names,\n and make maps.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"10 / 19 / 42","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-cran-phangorn","distribution":"debian","release":"sid","component":"main","version":"2.4.0","source":"r-cran-phangorn","homepage":"https://cran.r-project.org/package=phangorn","description":"GNU R package for phylogenetic analysis","long_description":" phangorn is a agent for reconstructing phylogenies, using distance-based\n methods, maximum parsimony or maximum likelihood, and performing Hadamard\n conjugation. It also offers functions for comparing trees, phylogenetic models\n or splits, simulating character data and performing congruence analysis.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"14 / 5 / 124","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-cran-pheatmap","distribution":"debian","release":"sid","component":"main","version":"1.0.12","source":"r-cran-pheatmap","homepage":"https://cran.r-project.org/package=pheatmap","description":"GNU R package to create pretty heatmaps","long_description":" GNU R implementation of heatmaps that offers more control over dimensions and\n appearance.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"13 / 5 / 74","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_26726","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-cran-phylobase","distribution":"debian","release":"sid","component":"main","version":"0.8.6","source":"r-cran-phylobase","homepage":"https://cran.r-project.org/package=phylobase","description":"GNU R base package for phylogenetic structures and comparative data","long_description":" This R package provides a base S4 class for comparative methods,\n incorporating one or more trees and trait data as these are used in\n other packages dealing with phylogenetic structures and comparative data.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"11 / 25 / 114","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-cran-phyagents","distribution":"debian","release":"sid","component":"main","version":"0.6-60","source":"r-cran-phyagents","homepage":"https://cran.r-project.org/package=phyagents","description":"GNU R phylogenetic agents for comparative biology","long_description":" A wide range of functions for phylogenetic analysis. Functionality is\n concentrated in phylogenetic comparative biology, but also includes a\n diverse array of methods for visualizing, manipulating, reading or\n writing, and even inferring phylogenetic trees and data. Included among\n the functions in phylogenetic comparative biology are various for\n ancestral state reconstruction, model-fitting, simulation of phylogenies\n and data, and multivariate analysis. There are a broad range of plotting\n methods for phylogenies and comparative data which include, but are not\n restricted to, methods for mapping trait evolution on trees, for\n projecting trees into phenotypic space or a geographic map, and for\n visualizing correlated speciation between trees. Finally, there are a\n number of functions for reading, writing, analyzing, inferring,\n simulating, and manipulating phylogenetic trees and comparative data not\n covered by other packages. For instance, there are functions for\n randomly or non-randomly attaching species or clades to a phylogeny, for\n estimating supertrees or consensus phylogenies from a set, for\n simulating trees and phylogenetic data under a range of models, and for\n a wide variety of other manipulations and analyses that phylogenetic\n biologists might find useful in their research.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 0 / 34","doi":"10.1111/j.2041-210X.2011.00169.x","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_12499","SEQwiki":null,"SciCrunch":{"source":"r-cran-phyagents","name":"SciCrunch","entry":"SCR_015502"},"RRID":null},{"package":"r-cran-pscbs","distribution":"debian","release":"sid","component":"main","version":"0.64.0","source":"r-cran-pscbs","homepage":"https://cran.r-project.org/package=PSCBS","description":"R package: Analysis of Parent-Specific DNA Copy Numbers","long_description":" Segmentation of allele-specific DNA copy number data and detection of regions\n with abnormal copy number within each parental chromosome. Both tumor-normal\n paired and tumoronly analyses are supported.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"12 / 4 / 105","doi":"10.1093/bioinformatics/btr329","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_05545","SEQwiki":null,"SciCrunch":{"source":"r-cran-pscbs","name":"SciCrunch","entry":"SCR_000417"},"RRID":null},{"package":"r-cran-qqman","distribution":"debian","release":"sid","component":"main","version":"0.1.4","source":"r-cran-qqman","homepage":"https://cran.r-project.org/package=qqman","description":"R package for visualizing GWAS results using Q-Q and manhattan plots","long_description":" qqman is an add-on package for the R statistical environment. This package\n provides functions for visualizing Genome-Wide Association Studies (GWAS)\n results using Manhattan plots and Quantile-Quantile plots.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 2 / 55","doi":"10.1101/005165","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_12451","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-cran-qtl","distribution":"debian","release":"sid","component":"main","version":"1.44-9","source":"r-cran-qtl","homepage":"https://cran.r-project.org/package=qtl","description":"GNU R package for genetic marker linkage analysis","long_description":" R/qtl is an extensible, interactive environment for mapping quantitative\n trait loci (QTLs) in experimental crosses. It is implemented as an\n add-on-package for the freely available and widely used statistical\n language/software R (see http://www.r-project.org).\n .\n The development of this software as an add-on to R allows one to take\n advantage of the basic mathematical and statistical functions, and\n powerful graphics capabilities, that are provided with R. Further,\n the user will benefit by the seamless integration of the QTL mapping\n software into a general statistical analysis program. The goal is to\n make complex QTL mapping methods widely accessible and allow users to\n focus on modeling rather than computing.\n .\n A key component of computational methods for QTL mapping is the hidden\n Markov model (HMM) technology for dealing with missing genotype data. The\n main HMM algorithms, with allowance for the presence of genotyping errors,\n for backcrosses, intercrosses, and phase-known four-way crosses\n were implemented.\n .\n The current version of R/qtl includes facilities for estimating\n genetic maps, identifying genotyping errors, and performing single-QTL\n genome scans and two-QTL, two-dimensional genome scans, by interval\n mapping (with the EM algorithm), Haley-Knott regression, and multiple\n imputation. All of this may be done in the presence of covariates (such\n as sex, age or treatment). One may also fit higher-order QTL models by\n multiple imputation.\n","interface":null,"biology":null,"fields":["biology","statistics"],"use":null,"popcon":"33 / 26 / 436","doi":"10.1093/bioinformatics/btg112","topics":null,"edam_scopes":null,"bio.agents":"Rqtl","OMICagents":"OMICS_07093","SEQwiki":null,"SciCrunch":{"source":"r-cran-qtl","name":"SciCrunch","entry":"SCR_009085"},"RRID":null},{"package":"r-cran-rentrez","distribution":"debian","release":"sid","component":"main","version":"1.2.1","source":"r-cran-rentrez","homepage":"https://cran.r-project.org/package=rentrez","description":"GNU R interface to the NCBI's EUtils API","long_description":" Provides an R interface to the NCBI's EUtils API allowing users to\n search databases like GenBank and PubMed, process the results of those\n searches and pull data into their R sessions.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"17 / 9 / 122","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_33187","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-cran-rncl","distribution":"debian","release":"sid","component":"main","version":"0.8.3","source":"r-cran-rncl","homepage":"https://cran.r-project.org/package=rncl","description":"GNU R interface to the Nexus Class Library","long_description":" This R package provides an interface to the Nexus Class Library which\n allows parsing of NEXUS, Newick and other phylogenetic tree file\n formats. It provides elements of the file that can be used to build\n phylogenetic objects such as ape's 'phylo' or phylobase's 'phylo4(d)'.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"15 / 24 / 122","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-cran-rnexml","distribution":"debian","release":"sid","component":"main","version":"2.3.0","source":"r-cran-rnexml","homepage":"https://cran.r-project.org/package=RNeXML","description":"GNU R package for semantically rich I/O for the 'NeXML' format","long_description":" Provides access to phyloinformatic data in 'NeXML' format. The package\n should add new functionality to R such as the possibility to manipulate\n 'NeXML' objects in more various and refined way and compatibility with\n 'ape' objects.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"12 / 25 / 116","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-cran-rocr","distribution":"debian","release":"sid","component":"main","version":"1.0-7","source":"r-cran-rocr","homepage":"https://cran.r-project.org/package=ROCR","description":"GNU R package to prepare and display ROC curves","long_description":" ROC graphs, sensitivity/specificity curves, lift charts,\n and precision/recall plots are popular examples of trade-off\n visualizations for specific pairs of performance measures. ROCR is a\n flexible agent for creating cutoff-parametrized 2D performance curves\n by freely combining two from over 25 performance measures (new\n performance measures can be added using a standard interface).\n Curves from different cross-validation or bootstrapping runs can be\n averaged by different methods, and standard deviations, standard\n errors or box plots can be used to visualize the variability across\n the runs. The parametrization can be visualized by printing cutoff\n values at the corresponding curve positions, or by coloring the\n curve according to cutoff. All components of a performance plot can\n be quickly adjusted using a flexible parameter dispatching\n mechanism. Despite its flexibility, ROCR is easy to use, with only\n three commands and reasonable default values for all optional\n parameters.\n .\n ROCR features: ROC curves, precision/recall plots, lift charts, cost\n curves, custom curves by freely selecting one performance measure for the\n x axis and one for the y axis, handling of data from cross-validation\n or bootstrapping, curve averaging (vertically, horizontally, or by\n threshold), standard error bars, box plots, curves that are color-coded\n by cutoff, printing threshold values on the curve, tight integration\n with Rs plotting facilities (making it easy to adjust plots or to combine\n multiple plots), fully customizable, easy to use (only 3 commands).\n .\n Performance measures that ROCR knows: Accuracy, error rate, true\n positive rate, false positive rate, true negative rate, false negative\n rate, sensitivity, specificity, recall, positive predictive value,\n negative predictive value, precision, fallout, miss, phi correlation\n coefficient, Matthews correlation coefficient, mutual information, chi\n square statistic, odds ratio, lift value, precision/recall F measure,\n ROC convex hull, area under the ROC curve, precision/recall break-even\n point, calibration error, mean cross-entropy, root mean squared error,\n SAR measure, expected cost, explicit cost.\n","interface":null,"biology":null,"fields":["statistics"],"use":["analysing","viewing"],"popcon":"52 / 13 / 305","doi":"10.1093/bioinformatics/bti623","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-cran-rotl","distribution":"debian","release":"sid","component":"main","version":"3.0.6","source":"r-cran-rotl","homepage":"https://cran.r-project.org/package=rotl","description":"GNU R interface to the 'Open Tree of Life' API","long_description":" An interface to the 'Open Tree of Life' API to retrieve phylogenetic\n trees, information about studies used to assemble the synthetic tree,\n and utilities to match taxonomic names to 'Open Tree identifiers'. The\n 'Open Tree of Life' aims at assembling a comprehensive phylogenetic tree\n for all named species.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"15 / 23 / 119","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_28401","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-cran-samr","distribution":"debian","release":"sid","component":"main","version":"3.0","source":"r-cran-samr","homepage":"https://cran.r-project.org/package=samr","description":"GNU R significance analysis of microarrays","long_description":" This GNU R package provides significance analysis of microarrays.\n A microarray is a multiplex lab-on-a-chip. It is a 2D array on a solid\n substrate (usually a glass slide or silicon thin-film cell) that assays\n large amounts of biological material using high-throughput screening\n miniaturized, multiplexed and parallel processing and detection methods.\n .\n This package helps analysing this kind of microarrays.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 8 / 24","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"SAM","OMICagents":"OMICS_00779","SEQwiki":null,"SciCrunch":{"source":"r-cran-samr","name":"SciCrunch","entry":"SCR_010951"},"RRID":null},{"package":"r-cran-sdmagents","distribution":"debian","release":"sid","component":"main","version":"1.1-221","source":"r-cran-sdmagents","homepage":"https://cran.r-project.org/package=SDMAgents","description":"Species Distribution Modelling Agents","long_description":" This package provides a set of agents for post processing the\n outcomes of species distribution modeling exercises. It includes novel\n methods for comparing models and tracking changes in distributions through\n time. It further includes methods for visualizing outcomes, selecting\n thresholds, calculating measures of accuracy and landscape fragmentation\n statistics, etc.\n .\n This package was made possible in part by financial\n support from the Australian Research Council & ARC Research Network for\n Earth System Science.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 8 / 26","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_33018","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-cran-seqinr","distribution":"debian","release":"sid","component":"main","version":"3.4-5","source":"r-cran-seqinr","homepage":"https://cran.r-project.org/package=seqinr","description":"GNU R biological sequences retrieval and analysis","long_description":" Exploratory data analysis and data visualization for biological sequence\n (DNA and protein) data. Includes also utilities for sequence data\n management under the ACNUC system.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"17 / 12 / 129","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_15909","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-cran-shazam","distribution":"debian","release":"sid","component":"main","version":"0.1.11","source":"r-cran-shazam","homepage":"https://cran.r-project.org/package=shazam","description":"Immunoglobulin Somatic Hypermutation Analysis","long_description":" Provides a computational framework for Bayesian estimation of\n antigen-driven selection in immunoglobulin (Ig) sequences, providing an\n intuitive means of analyzing selection by quantifying the degree of\n selective pressure. Also provides agents to profile mutations in Ig\n sequences, build models of somatic hypermutation (SHM) in Ig sequences,\n and make model-dependent distance comparisons of Ig repertoires.\n .\n SHazaM is part of the Immcantation analysis framework for Adaptive\n Immune Receptor Repertoire sequencing (AIRR-seq) and provides agents for\n advanced analysis of somatic hypermutation (SHM) in immunoglobulin (Ig)\n sequences. Shazam focuses on the following analysis topics:\n .\n  * Quantification of mutational load\n    SHazaM includes methods for determine the rate of observed and\n    expected mutations under various criteria. Mutational profiling\n    criteria include rates under SHM targeting models, mutations specific\n    to CDR and FWR regions, and physicochemical property dependent\n    substitution rates.\n  * Statistical models of SHM targeting patterns\n    Models of SHM may be divided into two independent components:\n     1) a mutability model that defines where mutations occur and\n     2) a nucleotide substitution model that defines the resulting mutation.\n    Collectively these two components define an SHM targeting\n    model. SHazaM provides empirically derived SHM 5-mer context mutation\n    models for both humans and mice, as well agents to build SHM targeting\n    models from data.\n  * Analysis of selection pressure using BASELINe\n    The Bayesian Estimation of Antigen-driven Selection in Ig Sequences\n    (BASELINe) method is a novel method for quantifying antigen-driven\n    selection in high-throughput Ig sequence data. BASELINe uses SHM\n    targeting models can be used to estimate the null distribution of\n    expected mutation frequencies, and provide measures of selection\n    pressure informed by known AID targeting biases.\n  * Model-dependent distance calculations\n    SHazaM provides methods to compute evolutionary distances between\n    sequences or set of sequences based on SHM targeting models. This\n    information is particularly useful in understanding and defining\n    clonal relationships.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 8 / 22","doi":"10.1093/bioinformatics/btv359","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_29370","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-cran-tcr","distribution":"debian","release":"sid","component":"main","version":"2.2.3","source":"r-cran-tcr","homepage":"https://cran.r-project.org/package=tcR","description":"Advanced Data Analysis of Immune Receptor Repertoires","long_description":" Cells of the immune system are the grand exception to the rule\n that all cells of an individuum have (mostly exact) copies of the\n same DNA. B cells (which produce antibodies) and T cells (which\n communicate with cells) however have a section of their DNA with\n genes of the groups V, D and J that are reorganised within the\n genomic DNA to provide the flexibility to deal with yet unknown\n pathogens.\n .\n This package provides a platform for the advanced analysis of T\n cell receptor repertoire data and its visualisations.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 8 / 22","doi":"10.1186/s12859-015-0613-1","topics":null,"edam_scopes":null,"bio.agents":"tcR","OMICagents":"OMICS_08096","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-cran-tigger","distribution":"debian","release":"sid","component":"main","version":"0.3.1","source":"r-cran-tigger","homepage":"https://cran.r-project.org/package=tigger","description":"Infers new Immunoglobulin alleles from Rep-Seq Data","long_description":" Summary: Infers the V genotype of an individual from immunoglobulin (Ig)\n repertoire-sequencing (Rep-Seq) data, including detection of any novel\n alleles. This information is then used to correct existing V allele calls\n from among the sample sequences.\n .\n High-throughput sequencing of B cell immunoglobulin receptors is\n providing unprecedented insight into adaptive immunity. A key step in\n analyzing these data involves assignment of the germline V, D and J gene\n segment alleles that comprise each immunoglobulin sequence by matching\n them against a database of known V(D)J alleles. However, this process\n will fail for sequences that utilize previously undetected alleles,\n whose frequency in the population is unclear.\n .\n TIgGER is a computational method that significantly improves V(D)J\n allele assignments by first determining the complete set of gene segments\n carried by an individual (including novel alleles) from V(D)J-rearrange\n sequences. TIgGER can then infer a subject’s genotype from these\n sequences, and use this genotype to correct the initial V(D)J allele\n assignments.\n .\n The application of TIgGER continues to identify a surprisingly high\n frequency of novel alleles in humans, highlighting the critical need\n for this approach. TIgGER, however, can and has been used with data\n from other species.\n .\n Core Abilities:\n  * Detecting novel alleles\n  * Inferring a subject’s genotype\n  * Correcting preliminary allele calls\n .\n Required Input\n  * A table of sequences from a single individual, with columns containing\n    the following:\n    -   V(D)J-rearranged nucleotide sequence (in IMGT-gapped format)\n    -   Preliminary V allele calls\n    -   Preliminary J allele calls\n    -   Length of the junction region\n  * Germline Ig sequences in IMGT-gapped fasta format (e.g., as those\n    downloaded from IMGT/GENE-DB)\n .\n The former can be created through the use of IMGT/HighV-QUEST and\n Change-O.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 7 / 19","doi":"10.1093/bioinformatics/btv359","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_07533","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-cran-treescape","distribution":"debian","release":"sid","component":"main","version":"1.10.18","source":"r-cran-treescape","homepage":"https://cran.r-project.org/package=treescape","description":"GNU R Statistical Exploration of Landscapes of Phylogenetic Trees","long_description":" This GNU R package provides agents for the exploration of distributions\n of phylogenetic trees. This package includes a shiny interface which can\n be started from R using 'treescapeServer()'.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"12 / 4 / 96","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_33184","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-cran-vegan","distribution":"debian","release":"sid","component":"main","version":"2.5-4","source":"r-cran-vegan","homepage":"https://cran.r-project.org/package=vegan","description":"Community Ecology Package for R","long_description":" R package for community ecologists. It contains most multivariate analysis\n needed in analysing ecological communities, and agents for diversity analysis.\n Most diversity methods assume that data are counts of individuals.\n .\n These agents are sometimes used outside the field of ecology, for instance to\n study populations of white blood cells or RNA molecules.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"30 / 31 / 332","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_01523","SEQwiki":null,"SciCrunch":{"source":"r-cran-vegan","name":"SciCrunch","entry":"SCR_011950"},"RRID":null},{"package":"python-rdkit","distribution":"debian","release":"sid","component":"main","version":"201809.1","source":"rdkit","homepage":"http://www.rdkit.org","description":"Collection of cheminformatics and machine-learning software","long_description":" RDKit is a Python/C++ based cheminformatics and machine-learning software\n environment.  Features Include:\n .\n  * Chemical reaction handling and transforms\n  * Substructure searching with SMARTS\n  * Canonical SMILES\n  * Molecule-molecule alignment\n  * Large number of molecular descriptors, including topological,\n    compositional, EState, SlogP/SMR, VSA and Feature-map vectors\n  * Fragmentation using RECAP rules\n  * 2D coordinate generation and depiction, including constrained depiction\n  * 3D coordinate generation using geometry embedding\n  * UFF and MMFF94 forcefields\n  * Chirality support, including calculation of (R/S) stereochemistry codes\n  * 2D pharmacophore searching\n  * Fingerprinting, including Daylight-like, atom pairs, topological\n    torsions, Morgan algorithm and MACCS keys\n  * Calculation of shape similarity\n  * Multi-molecule maximum common substructure\n  * Machine-learning via clustering and information theory algorithms\n  * Gasteiger-Marsili partial charge calculation\n .\n File formats RDKit supports include MDL Mol, PDB, SDF, TDT, SMILES and RDKit\n binary format.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 10 / 83","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_14853","SEQwiki":null,"SciCrunch":{"source":"rdkit","name":"SciCrunch","entry":"SCR_014274"},"RRID":null},{"package":"rdp-alignment","distribution":"debian","release":"sid","component":"main","version":"1.2.0","source":"rdp-alignment","homepage":"https://github.com/rdpstaff/AlignmentAgents","description":"Ribosomal Database Project (RDP) alignment agents package","long_description":" The Alignment agents package contains commands to do defined community\n analysis, pairwise alignment and hidden markov model (HMMER3 models,\n no training).\n .\n The package also contains the AlignmentAgents Java library which is used by\n other RDP agents.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 4 / 69","doi":"10.3389/fmicb.2013.00291","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"rdp-classifier","distribution":"debian","release":"sid","component":"main","version":"2.10.2","source":"rdp-classifier","homepage":"https://github.com/rdpstaff/classifier","description":"extensible sequence classifier for fungal lsu, bacterial and archaeal 16s","long_description":" The RDP Classifier is a naive Bayesian classifier which was developed\n to provide rapid taxonomic placement based on rRNA sequence data. The\n RDP Classifier can rapidly and accurately classify bacterial and\n archaeal 16s rRNA sequences, and Fungal LSU sequences. It provides\n taxonomic assignments from domain to genus, with confidence estimates\n for each assignment. The RDP Classifier likely can be adapted to\n additional phylogenetically coherent bacterial taxonomies.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 4 / 68","doi":"10.1128/AEM.00062-07","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_18112","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"rdp-readseq","distribution":"debian","release":"sid","component":"main","version":"2.0.2","source":"rdp-readseq","homepage":"https://github.com/rdpstaff/ReadSeq","description":"Ribosomal Database Project (RDP) sequence reading and writing","long_description":" Rdp-readseq is a simple user interface to the sequence reading library\n developed by the Ribosomal Database Project.  It can handle genbank, embl,\n fasta, fastq, sff and sto files.  It can read from files or streams, and\n can handle indexing files.\n .\n The package also contains the ReadSeq Java library which is used by other\n RDP agents.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 4 / 78","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"readseq","distribution":"debian","release":"sid","component":"main","version":"1","source":"readseq","homepage":"http://iubio.bio.indiana.edu/soft/molbio/readseq/","description":"Conversion between sequence formats","long_description":" Reads and writes nucleic/protein sequences in various\n formats. Data files may have multiple sequences.\n Readseq is particularly useful as it automatically detects many\n sequence formats, and converts between them.\n","interface":["commandline"],"biology":null,"fields":["biology","biology:bioinformatics"],"use":["converting"],"popcon":"12 / 3 / 122","doi":"10.1002/0471250953.bia01es00","topics":null,"edam_scopes":null,"bio.agents":"readseq","OMICagents":"OMICS_17576","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"reapr","distribution":"debian","release":"sid","component":"main","version":"1.0.18","source":"reapr","homepage":"http://www.sanger.ac.uk/science/agents/reapr","description":"universal agent for genome assembly evaluation","long_description":" REAPR is a agent that evaluates the accuracy of a genome assembly using mapped\n paired end reads, without the use of a reference genome for comparison. It can\n be used in any stage of an assembly pipeline to automatically break incorrect\n scaffolds and flag other errors in an assembly for manual inspection. It\n reports mis-assemblies and other warnings, and produces a new broken assembly\n based on the error calls.\n .\n The software requires as input an assembly in FASTA format and paired reads\n mapped to the assembly in a BAM file. Mapping information such as the fragment\n coverage and insert size distribution is analysed to locate mis-assemblies.\n REAPR works best using mapped read pairs from a large insert library (at least\n 1000bp). Additionally, if a short insert Illumina library is also available,\n REAPR can combine this with the large insert library in order to score each\n base of the assembly.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 3 / 57","doi":"10.1186/gb-2013-14-5-r47","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_04068","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"librelion-dev","distribution":"debian","release":"sid","component":"main","version":"1.4","source":"relion","homepage":"http://www2.mrc-lmb.cam.ac.uk/relion/index.php/Main_Page","description":"C++ API for RELION (3D reconstructions in cryo-electron microscopy)","long_description":" RELION (for REgularised LIkelihood OptimisatioN) is a stand-alone\n computer program for Maximum A Posteriori refinement of (multiple) 3D\n reconstructions or 2D class averages in cryo-electron microscopy.\n .\n RELION provides a GUI, several command-line agents in parallel (MPI) and serial\n versions as well as a C++ API.\n .\n This is the developers API package for use without GUI and MPI.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 34","doi":"10.1016/j.jsb.2012.09.006","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_15597","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"relion-bin","distribution":"debian","release":"sid","component":"main","version":"1.4","source":"relion","homepage":"http://www2.mrc-lmb.cam.ac.uk/relion/index.php/Main_Page","description":"agentkit for 3D reconstructions in cryo-electron microscopy","long_description":" RELION (for REgularised LIkelihood OptimisatioN) is a stand-alone\n computer program for Maximum A Posteriori refinement of (multiple) 3D\n reconstructions or 2D class averages in cryo-electron microscopy.\n .\n RELION provides a GUI, several command-line agents in parallel (MPI) and serial\n versions as well as a C++ API.\n .\n relion-bin provides the serial command-line agents\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 0 / 52","doi":"10.1016/j.jsb.2012.09.006","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_15597","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"relion-bin+gui","distribution":"debian","release":"sid","component":"main","version":"1.4","source":"relion","homepage":"http://www2.mrc-lmb.cam.ac.uk/relion/index.php/Main_Page","description":"parallel agentkit for 3D reconstructions in cryo-electron microscopy","long_description":" RELION (for REgularised LIkelihood OptimisatioN) is a stand-alone\n computer program for Maximum A Posteriori refinement of (multiple) 3D\n reconstructions or 2D class averages in cryo-electron microscopy.\n .\n RELION provides a GUI, several command-line agents in parallel (MPI) and serial\n versions as well as a C++ API.\n .\n relion-bin+gui provides the serial command-line agents and the graphical user\n interface.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 2 / 30","doi":"10.1016/j.jsb.2012.09.006","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_15597","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"relion-bin+mpi","distribution":"debian","release":"sid","component":"main","version":"1.4","source":"relion","homepage":"http://www2.mrc-lmb.cam.ac.uk/relion/index.php/Main_Page","description":"parallel agentkit for 3D reconstructions in cryo-electron microscopy","long_description":" RELION (for REgularised LIkelihood OptimisatioN) is a stand-alone\n computer program for Maximum A Posteriori refinement of (multiple) 3D\n reconstructions or 2D class averages in cryo-electron microscopy.\n .\n RELION provides a GUI, several command-line agents in parallel (MPI) and serial\n versions as well as a C++ API.\n .\n relion-bin+mpi provides the serial and parallel command-line agents based on\n OpenMPI.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 2","doi":"10.1016/j.jsb.2012.09.006","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_15597","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"relion-bin+mpi+gui","distribution":"debian","release":"sid","component":"main","version":"1.4","source":"relion","homepage":"http://www2.mrc-lmb.cam.ac.uk/relion/index.php/Main_Page","description":"parallel agentkit for 3D reconstructions in cryo-electron microscopy","long_description":" RELION (for REgularised LIkelihood OptimisatioN) is a stand-alone\n computer program for Maximum A Posteriori refinement of (multiple) 3D\n reconstructions or 2D class averages in cryo-electron microscopy.\n .\n RELION provides a GUI, several command-line agents in parallel (MPI) and serial\n versions as well as a C++ API.\n .\n relion-bin+mpi+gui provides the serial and parallel command-line agents as\n well as the graphical user interface.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 0 / 3","doi":"10.1016/j.jsb.2012.09.006","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_15597","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"repeatmasker","distribution":"prospective","release":"vcs","component":"main","version":"4.0.6","source":"repeatmasker","homepage":"http://www.repeatmasker.org/","description":"screen DNA sequences for interspersed repeats","long_description":" RepeatMasker is a program that screens DNA sequences for interspersed\n repeats and low complexity DNA sequences. The output of the program is\n a detailed annotation of the repeats that are present in the query\n sequence as well as a modified version of the query sequence in which\n all the annotated repeats have been masked (default: replaced by\n Ns). Sequence comparisons in RepeatMasker are performed by the program\n cross_match, an efficient implementation of the Smith-Waterman-Gotoh\n algorithm developed by Phil Green, or by WU-Blast developed by Warren\n Gish.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1007/978-1-61779-603-6_2","topics":null,"edam_scopes":null,"bio.agents":"RepeatMasker","OMICagents":"OMICS_09436","SEQwiki":null,"SciCrunch":{"source":"repeatmasker","name":"SciCrunch","entry":"SCR_012954"},"RRID":null},{"package":"repeatmasker-recon","distribution":"debian","release":"sid","component":"main","version":"1.08","source":"repeatmasker-recon","homepage":"http://www.repeatmasker.org/","description":"finds repeat families from biological sequences","long_description":" The RECON package implements a de novo algorithm for the identification\n of repeat families from biological sequences.\n .\n The program implements an approach for the de novo identification and\n classification of repeat sequence families that is based on extensions\n to the usual approach of single linkage clustering of local pairwise\n alignments between genomic sequences. The extensions use multiple\n alignment information to define the boundaries of individual copies of\n the repeats and to distinguish homologous but distinct repeat element\n families. When tested on the human genome, this approach was able to\n properly identify and group known transposable elements. The program,\n should be useful for first-pass automatic classification of repeats in\n newly sequenced genomes.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 3 / 63","doi":"10.1101/gr.88502","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"librg-reprof-bundle-perl","distribution":"debian","release":"sid","component":"main","version":"1.0.1","source":"reprof","homepage":"http://rostlab.org/","description":"protein secondary structure and accessibility predictor (perl module)","long_description":" 'reprof' is an improved implementation of 'prof', a popular protein secondary\n structure and accessibility predictor.  Prediction is either\n done from protein sequence alone or from an alignment - the latter should be\n used for optimal performance.\n .\n This package provides the perl modules implementing 'reprof' along with the\n necessary data files.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 3 / 95","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"reprof","OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"reprof","distribution":"debian","release":"sid","component":"main","version":"1.0.1","source":"reprof","homepage":"http://rostlab.org/","description":"protein secondary structure and accessibility predictor","long_description":" 'reprof' is an improved implementation of 'prof', a popular protein secondary\n structure and accessibility predictor.  Prediction is either\n done from protein sequence alone or from an alignment - the latter should be\n used for optimal performance.\n .\n This package provides the 'reprof' command.  It is only a command line\n interface to the functionality provided by the modules in\n librg-reprof-bundle-perl.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 3 / 89","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"reprof","OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"rnahybrid","distribution":"debian","release":"sid","component":"main","version":"2.1.2","source":"rnahybrid","homepage":"http://bibiserv.techfak.uni-bielefeld.de/rnahybrid/submission.html","description":"Fast and effective prediction of microRNA/target duplexes","long_description":" RNAhybrid is a agent for finding the minimum free energy hybridisation of a\n long and a short RNA. The hybridisation is performed in a kind of domain mode,\n ie. The short sequence is hybridised to the best fitting part of the long one.\n The agent is primarily meant as a means for microRNA target prediction.\n","interface":["commandline"],"biology":null,"fields":["biology","biology:bioinformatics"],"use":["analysing"],"popcon":"8 / 3 / 95","doi":"10.1261/rna.5248604","topics":null,"edam_scopes":null,"bio.agents":"rnahybrid","OMICagents":"OMICS_00416","SEQwiki":null,"SciCrunch":{"source":"rnahybrid","name":"SciCrunch","entry":"SCR_003252"},"RRID":null},{"package":"rna-star","distribution":"debian","release":"sid","component":"main","version":"2.7.0a","source":"rna-star","homepage":"https://github.com/alexdobin/STAR/","description":"ultrafast universal RNA-seq aligner","long_description":" Spliced Transcripts Alignment to a Reference (STAR) software based on a\n previously undescribed RNA-seq alignment algorithm that uses sequential\n maximum mappable seed search in uncompressed suffix arrays followed by\n seed clustering and stitching procedure. STAR outperforms other aligners\n by a factor of >50 in mapping speed, aligning to the human genome 550\n million 2 × 76 bp paired-end reads per hour on a modest 12-core server,\n while at the same time improving alignment sensitivity and precision. In\n addition to unbiased de novo detection of canonical junctions, STAR can\n discover non-canonical splices and chimeric (fusion) transcripts, and is\n also capable of mapping full-length RNA sequences. Using Roche 454\n sequencing of reverse transcription polymerase chain reaction amplicons,\n the authors experimentally validated 1960 novel intergenic splice\n junctions with an 80-90% success rate, corroborating the high precision\n of the STAR mapping strategy.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 14 / 77","doi":"10.1093/bioinformatics/bts635","topics":["Sequence analysis"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Raw sequence", "formats": ["FASTQ"]}, {"data": "DNA sequence (raw)", "formats": ["FASTA"]}, {"data": "Annotation track", "formats": ["GTF"]}], "outputs": [{"data": "Sequence alignment (nucleic acid)", "formats": ["SAM", "BAM"]}, {"data": "Report"}], "function": ["Genome alignment"]}],"bio.agents":"star","OMICagents":"OMICS_01254","SEQwiki":null,"SciCrunch":{"source":"rna-star","name":"SciCrunch","entry":"SCR_015899"},"RRID":null},{"package":"roadtrips","distribution":"prospective","release":"vcs","component":"main","version":"2.0","source":"roadtrips","homepage":"http://faculty.washington.edu/tathornt/software/ROADTRIPS2/","description":"case-control association testing with unknown population and pedigree structure","long_description":" ROADTRIPS performs single-SNP, case-control association testing in\n samples with partially or completely unknown population and pedigree\n structure. ROADTRIPS uses an empirical covariance matrix calculated from\n genomewide SNP data to correct for unknown population and pedigree\n structure, while maintaining high power by taking advantage of known\n pedigree information when it is available. The program is applicable to\n association studies with completely general combinations of related and\n unrelated individuals. Analysis can be performed genomewide (currently\n just for autosomes).\n .\n ROADTRIPS is suitable for applications such as:\n  * correcting for possible population structure and/or misspecified\n    relationships in the context of case-control association testing in\n    samples of unrelated individuals and/or related individuals with well-\n    characterized pedigrees\n  * case-control association testing in samples from isolated populations\n    for which pedigree information is limited or unavailable","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 1","doi":"10.1016/j.ajhg.2010.01.001","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"roary","distribution":"debian","release":"sid","component":"main","version":"3.12.0","source":"roary","homepage":"http://sanger-pathogens.github.io/Roary/","description":"high speed stand alone pan genome pipeline","long_description":" Roary is a high speed stand alone pan genome pipeline, which takes annotated\n assemblies in GFF3 format (as produced, for instance, by Prokka) and calculates\n the pan genome. Using a standard desktop PC, it can analyse datasets with\n thousands of samples, something which is computationally infeasible with\n existing methods, without compromising the quality of the results. 128 samples\n can be analysed in under 1 hour using 1 GB of RAM and a single processor.\n To perform this analysis using existing methods would take weeks and hundreds\n of GB of RAM. Roary is not intended for meta-genomics or for comparing\n extremely diverse sets of genomes.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 4 / 54","doi":"10.1093/bioinformatics/btv421","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_09491","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"roguenarok","distribution":"debian","release":"sid","component":"main","version":"1.0","source":"roguenarok","homepage":"https://github.com/aberer/RogueNaRok","description":"versatile and scalable algorithm for rogue taxon identification","long_description":" RogueNaRok is a versatile and scalable algorithm for rogue taxon\n identification. It also includes implementations of the maximum agreement\n subtree, leaf stability index and taxonomic instability index.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 0 / 18","doi":"10.1093/sysbio/sys078","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_21698","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-other-apmswapp","distribution":"prospective","release":"vcs","component":"main","version":"1.0","source":"r-other-apmswapp","homepage":"http://sourceforge.net/projects/apmswapp/","description":"GNU R Pre- and Postprocessing For Affinity Purification Mass Spectrometry","long_description":" The reliable detection of protein-protein-interactions by affinity\n purification mass spectrometry (AP-MS) is a crucial stepping stone for\n the understanding of biological processes. The main challenge in a\n typical AP-MS experiment is to separate true interaction proteins from\n contaminants by contrasting counts of proteins binding to specific baits\n with counts of negative controls.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1021/pr401249b","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-other-hms-dbmi-spp","distribution":"prospective","release":"vcs","component":"main","version":"1.15.2","source":"r-other-hms-dbmi-spp","homepage":"http://compbio.med.harvard.edu/Supplements/ChIP-seq/","description":"GNU R ChIP-seq processing pipeline","long_description":" R package for anlaysis of ChIP-seq and other functional sequencing data\n  * Assess overall DNA-binding signals in the data and select appropriate\n    quality of tag alignment.\n  * Discard or restrict positions with abnormally high number of tags.\n  * Calculate genome-wide profiles of smoothed tag density and save them\n    in WIG files for viewing in other browsers.\n  * Calculate genome-wide profiles providing conservative statistical\n    estimates of fold enrichment ratios along the genome. These can be\n    exported for browser viewing, or thresholded to determine regions of\n    significant enrichment/depletion.\n  * Determine statistically significant point binding positions\n  * Assess whether the set of point binding positions detected at a\n    current sequencing depth meets saturation criteria, and if does not,\n    estimate what sequencing depth would be required to do so.","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 4","doi":"10.1038/nbt.1508","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"r-other-mott-happy.hbrem","distribution":"debian","release":"sid","component":"main","version":"2.4","source":"r-other-mott-happy","homepage":"http://www.well.ox.ac.uk/~rmott/","description":"GNU R package for fine-mapping complex diseases","long_description":" Happy is an R interface into the HAPPY C package for fine-mapping\n Quantitative Trait Loci (QTL) in Heterogenous Stocks (HS). An HS is\n an advanced intercross between (usually eight) founder inbred strains\n of mice. HS are suitable for fine-mapping QTL.  It uses a multipoint\n analysis which offers significant improvements in statistical power to\n detect QTLs over that achieved by single-marker association.\n .\n The happy package is\n an extension of the original C program happy; it uses the C code to\n compute the probability of descent from each of the founders, at each\n locus position, but the happy packager allows a much richer range of\n models to be fit to the data.\n .\n Read /usr/share/doc/r-other-mott-happy/README.Debian for a more\n detailed explanation.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"15 / 2 / 136","doi":"10.1073/pnas.230304397","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":{"source":"r-other-mott-happy","name":"SciCrunch","entry":"SCR_001395"},"RRID":null},{"package":"rsat","distribution":"prospective","release":"vcs","component":"main","version":"2016-03-14","source":"rsat","homepage":"http://rsat.eu/","description":"Regulatory Sequence Analysis Agents","long_description":" RSAT is a series of modular computer programs specifically designed for\n the detection of regulatory signals in non-coding sequences.\n .\n RSAT servers have been up and running since 1997. The project was\n initiated by Jacques van Helden, and is now pursued by the RSAT team.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1093/nar/gkv362","topics":null,"edam_scopes":null,"bio.agents":"rsat","OMICagents":"OMICS_08097","SEQwiki":null,"SciCrunch":{"source":"rsat","name":"SciCrunch","entry":"SCR_008560"},"RRID":null},{"package":"rsem","distribution":"debian","release":"sid","component":"main","version":"1.3.1","source":"rsem","homepage":"http://deweylab.biostat.wisc.edu/rsem/","description":"RNA-Seq by Expectation-Maximization","long_description":" RSEM is a software package for estimating gene and isoform expression\n levels from RNA-Seq data. The RSEM package provides an user-friendly\n interface, supports threads for parallel computation of the EM\n algorithm, single-end and paired-end read data, quality scores,\n variable-length reads and RSPD estimation. In addition, it provides\n posterior mean and 95% credibility interval estimates for expression\n levels. For visualization, It can generate BAM and Wiggle files in both\n transcript-coordinate and genomic-coordinate. Genomic-coordinate files\n can be visualized by both UCSC Genome browser and Broad Institute’s\n Integrative Genomics Viewer (IGV). Transcript-coordinate files can be\n visualized by IGV. RSEM also has its own scripts to generate transcript\n read depth plots in pdf format. The unique feature of RSEM is, the read\n depth plots can be stacked, with read depth contributed to unique reads\n shown in black and contributed to multi-reads shown in red. In addition,\n models learned from data can also be visualized. Last but not least,\n RSEM contains a simulator.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 4 / 67","doi":"http://dx.doi.org/10.1186/1471-2105-12-323","topics":null,"edam_scopes":null,"bio.agents":"rsem","OMICagents":"OMICS_01287","SEQwiki":null,"SciCrunch":{"source":"rsem","name":"SciCrunch","entry":"SCR_013027"},"RRID":null},{"package":"rtax","distribution":"debian","release":"sid","component":"main","version":"0.984","source":"rtax","homepage":"https://github.com/davidsoergel/rtax/","description":"Classification of sequence reads of 16S ribosomal RNA gene","long_description":" Short-read technologies for microbial community profiling are increasingly\n popular, yet previous techniques for assigning taxonomy to paired-end reads\n perform poorly. RTAX provides rapid taxonomic assignments of paired-end\n reads using a consensus algorithm.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 3 / 110","doi":"10.1038/ismej.2011.208","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_28979","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"ruby-bio","distribution":"debian","release":"sid","component":"main","version":"1.5.2","source":"ruby-bio","homepage":"http://bioruby.org/","description":"Ruby agents for computational molecular biology","long_description":" BioRuby project aims to implement an integrated environment for\n Bioinformatics with Ruby language. Design philosophy of the BioRuby library\n is KISS (keep it simple, stupid) to maximize the usability and the\n efficiency for biologists as a daily agent. The project was started in Japan\n and supported by University of Tokyo (Human Genome Center), Kyoto University\n (Bioinformatics Center) and the Open Bio Foundation.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 5 / 44","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"ruby-crb-blast","distribution":"debian","release":"sid","component":"main","version":"0.6.9","source":"ruby-crb-blast","homepage":"https://github.com/cboursnell/crb-blast","description":"Run conditional reciprocal best blast","long_description":" CRB-BLAST is a novel method for finding orthologs between one set of sequences\n and another. This is particularly useful in genome and transcriptome\n annotation.\n .\n CRB-BLAST initially performs a standard reciprocal best BLAST. It does this by\n performing BLAST alignments of query->target and target->query. Reciprocal\n best BLAST hits are those where the best match for any given query sequence in\n the query->target alignment is also the best hit of the match in the reverse\n (target->query) alignment.\n .\n Reciprocal best BLAST is a very conservative way to assign orthologs. The main\n innovation in CRB-BLAST is to learn an appropriate e-value cutoff to apply to\n each pairwise alignment by taking into account the overall relatedness of the\n two datasets being compared. This is done by fitting a function to the\n distribution of alignment e-values over sequence lengths. The function\n provides the e-value cutoff for a sequence of given length.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 2 / 29","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"ruby-rgfa","distribution":"debian","release":"sid","component":"main","version":"1.3.1","source":"ruby-rgfa","homepage":"http://github.com/ggonnella/rgfa","description":"parse, edit and write GFA format graphs in Ruby","long_description":" The Graphical Fragment Assembly (GFA) format is a proposed file format\n to describe the product of a genome sequence assembly process.\n rgfa implements the proposed specifications for the GFA format\n described under https://github.com/pmelsted/GFA-spec/blob/master/GFA-spec.md\n as closely as possible.\n The library allows one to create an RGFA object from a file in the GFA format\n or from scratch, to enumerate the graph elements (segments, links,\n containments, paths and header lines), to traverse the graph (by\n traversing all links outgoing from or incoming to a segment), to search for\n elements (e.g. which links connect two segments) and to manipulate the\n graph (e.g. to eliminate a link or a segment or to duplicate a segment\n distributing the read counts evenly on the copies).\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 1 / 3","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_19578","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"runcircos-gui","distribution":"debian","release":"sid","component":"main","version":"0.0+git20180828.97703b9","source":"runcircos-gui","homepage":"https://github.com/narunlifescience/runcircos-gui","description":"GUI agent to run circos","long_description":" runCircos-gui is a simple yet comprehensive crossplatform software to\n execute Circos from a graphical user interface. The software eliminates\n the need to use command line for running Circos without compremising the\n power of complete commandline parameters and options.\n .\n runCircos-gui optimize running parameters (both toggle options & options\n with arguments) and install Perl packages without using command line.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 0 / 22","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"saint","distribution":"debian","release":"sid","component":"main","version":"2.5.0","source":"saint","homepage":"http://saint-apms.sourceforge.net/Main.html","description":"Significance Analysis of INTeractome","long_description":" SAINT implements the scoring algorithm for protein-protein interaction\n data using label free quantitative proteomics data in AP-MS experiments.\n It was used for spectral count data in the yeast kinase interactome work\n not incorporating control purification, as well as a generalized\n implementation for spectral count data with and without control\n purification.\n .\n Alternatively, you can also run SAINT in combination with ProHits.\n .\n The package was written for either doing analysis without or with\n control IPs and\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 3 / 111","doi":"10.1126/science.1176495","topics":null,"edam_scopes":null,"bio.agents":"SAINT","OMICagents":"OMICS_16243","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"salmon","distribution":"debian","release":"sid","component":"main","version":"0.12.0+ds1","source":"salmon","homepage":"https://github.com/COMBINE-lab/salmon","description":"wicked-fast transcript quantification from RNA-seq data","long_description":" Salmon is a wicked-fast program to produce a highly-accurate, transcript-level\n quantification estimates from RNA-seq data. Salmon achieves is accuracy and\n speed via a number of different innovations, including the use of lightweight\n alignments (accurate but fast-to-compute proxies for traditional read\n alignments) and massively-parallel stochastic collapsed variational inference.\n The result is a versatile agent that fits nicely into many different pipelines.\n For example, you can choose to make use of the lightweight alignments by\n providing Salmon with raw sequencing reads, or, if it is more convenient, you\n can provide Salmon with regular alignments (e.g. computed with your favorite\n aligner), and it will use the same wicked-fast, state-of-the-art inference\n algorithm to estimate transcript-level abundances for your experiment.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 5 / 61","doi":"http://dx.doi.org/10.1101/021592","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_09075","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"sambamba","distribution":"debian","release":"sid","component":"main","version":"0.6.7","source":"sambamba","homepage":"https://github.com/lomereiter/sambamba","description":"agents for working with SAM/BAM data","long_description":" Sambamba positions itself as a performant alternative\n to samagents and provides agents for\n  * Powerful filtering with sambamba view --filter\n  * Picard-like SAM header merging in the merge agent\n  * Optional for operations on whole BAMs\n  * Fast copying of a region to a new file with the slice agent\n  * Duplicate marking/removal, using the Picard criteria\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 5","doi":"10.1093/bioinformatics/btv098","topics":null,"edam_scopes":null,"bio.agents":"Sambamba","OMICagents":"OMICS_07586","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"samblaster","distribution":"debian","release":"sid","component":"main","version":"0.1.24","source":"samblaster","homepage":"https://github.com/GregoryFaust/samblaster","description":"marks duplicates, extracts discordant/split reads","long_description":" Current \"next-generation\" sequencing technologies cannot tell what\n exact sequence they will be reading. They take what is available. And\n if some sequences are read very often, then this needs some extra\n biomedical thinking. The genome could for instance be duplicated.\n .\n samblaster is a fast and flexible program for marking duplicates in\n read-id grouped paired-end SAM files. It can also optionally output\n discordant read pairs and/or split read mappings to separate SAM files,\n and/or unmapped/clipped reads to a separate FASTQ file. When marking\n duplicates, samblaster will require approximately 20MB of memory per\n 1M read pairs.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 9 / 16","doi":"10.1093/bioinformatics/btu314","topics":null,"edam_scopes":null,"bio.agents":"SAMBLASTER","OMICagents":"OMICS_04682","SEQwiki":null,"SciCrunch":{"source":"samblaster","name":"SciCrunch","entry":"SCR_000468"},"RRID":null},{"package":"samagents","distribution":"debian","release":"sid","component":"main","version":"1.9","source":"samagents","homepage":"http://www.htslib.org/","description":"processing sequence alignments in SAM, BAM and CRAM formats","long_description":" Samagents is a set of utilities that manipulate nucleotide sequence alignments\n in the binary BAM format. It imports from and exports to the ascii SAM\n (Sequence Alignment/Map) and CRAM formats, does sorting, merging and indexing,\n and allows one to retrieve reads in any regions swiftly. It is designed to work\n on a stream, and is able to open a BAM or CRAM (not SAM) file on a remote FTP\n or HTTP server.\n","interface":["commandline"],"biology":null,"fields":["biology"],"use":["calculating","filtering","analysing"],"popcon":"58 / 88 / 1125","doi":"10.1093/bioinformatics/btp352","topics":null,"edam_scopes":null,"bio.agents":"samagents","OMICagents":"OMICS_00090","SEQwiki":null,"SciCrunch":{"source":"samagents","name":"SciCrunch","entry":"SCR_002105"},"RRID":null},{"package":"libbam-dev","distribution":"debian","release":"sid","component":"main","version":"0.1.19","source":"samagents-legacy","homepage":"http://www.htslib.org/","description":"manipulates nucleotide sequence alignments in BAM or SAM format","long_description":" The BAM library provides I/O and various operations on manipulating nucleotide\n sequence alignments in the BAM (Binary Alignment/Mapping) or SAM (Sequence\n Alignment/Map) format. It now supports importing from or exporting to SAM,\n sorting, merging, generating pileup, and quickly retrieval of reads overlapped\n with a specified region.\n .\n This library is part of SAMagents version 0.1.19.  It is obsolete and provided\n only to build software that has not yet transitioned to the HTSlib, which\n replaces this library.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 0 / 30","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"sap","distribution":"prospective","release":"vcs","component":"main","version":"1.1.3","source":"sap","homepage":"https://web.archive.org/web/20160305092412/http://mathbio.nimr.mrc.ac.uk/wiki/Software#SAP","description":"Pairwise protein structure alignment via double dynamic programming","long_description":" In contrast to DNA, proteins exhibit an apparently unlimited variety of\n structure. This is a necessary requirement of the vast array of\n differing functions that they perform in the maintainance of life,\n again, in contrast to the relatively static archival function of DNA.\n Not only do we observe a bewildering variety of form but even within a\n common structure, there is variation in the lengths and orientation\n substructures. Such variation is both a reflection on the very long time\n periods over which some structures have diverged and also a consequence\n of the fact that proteins cannot be completely rigid bodies but must\n have flexibility to accommodate the structural changes that are almost\n always necessary for them to perform their functions. These aspects make\n comparing structure and finding structural similarity over long\n divergence times very difficult. Indeed, computationally, the problem of\n recognizing similarity is one of three-dimensional pattern recognition,\n which is a notoriously difficult problem for computers to perform. In\n this chapter, guidance is provided on the use of a flexible structure\n comparison method that overcomes many of the problems of comparing\n protein structures that may exhibit only weak similarity.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1385/1-59259-368-2:19","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_31017","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"sbmlagentbox","distribution":"debian","release":"sid","component":"main","version":"4.1.0","source":"sbmlagentbox","homepage":"http://sbml.org/Software/SBMLAgentbox","description":"libsbml agentbox for octave and matlab","long_description":" The SBMLAgentbox provides a set of basic functions for reading, writing,\n manipulating, and simulating SBML (System Biology Meta Language)\n models. It is a free Open Source package on top of the libSBML with\n full compatibility to work with MATLAB and Octave alike and share models\n between the two systems.\n .\n The agentbox is not a complete turn key solution for Systems Biology.\n It has its emphasis on easing the handling of SBML data and serves\n as a starting point for users and developers to establish their own\n methods.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 30","doi":"10.1093/bioinformatics/btl111","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_06013","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"scoary","distribution":"debian","release":"sid","component":"main","version":"1.6.16","source":"scoary","homepage":"https://github.com/AdmiralenOla/Scoary","description":"pangenome-wide association studies","long_description":" Scoary is designed to take the gene_presence_absence.csv file from\n Roary as well as a traits file created by the user and calculate the\n associations between all genes in the accessory genome and the traits. It\n reports a list of genes sorted by strength of association per trait.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 2 / 3","doi":"10.1186/s13059-016-1108-8","topics":null,"edam_scopes":null,"bio.agents":"Scoary","OMICagents":"OMICS_13120","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"scrm","distribution":"debian","release":"sid","component":"main","version":"1.7.3","source":"scrm","homepage":"https://github.com/scrm/scrm","description":"simulator of evolution of genetic sequences","long_description":" scrm simulates the evolution of genetic sequences.\n .\n It takes a neutral evolutionary model as input, and generates random sequences\n that evolved under the model. As coalescent simulator, it traces the ancestry\n of the sampled sequences backwards in time and is therefore extremely\n efficient. Compared to other coalescent simulators, it can simulate\n chromosome-scale sequences without a measureable reduction of genetic linkage\n between different sites.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 4 / 60","doi":"10.1093/bioinformatics/btu861","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_07231","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"scythe","distribution":"debian","release":"sid","component":"main","version":"0.994+git20141017.20d3cff","source":"scythe","homepage":"https://github.com/vsbuffalo/scythe","description":"Bayesian adaptor trimmer for sequencing reads","long_description":" Scythe uses a Naive Bayesian approach to classify contaminant substrings in\n sequence reads. It considers quality information, which can make it robust in\n picking out 3'-end adapters, which often include poor quality bases.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 3 / 70","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_01091","SEQwiki":null,"SciCrunch":{"source":"scythe","name":"SciCrunch","entry":"SCR_011844"},"RRID":null},{"package":"seaview","distribution":"debian","release":"sid","component":"main","version":"4.7","source":"seaview","homepage":"http://doua.prabi.fr/software/seaview","description":"Multiplatform interface for sequence alignment and phylogeny","long_description":" SeaView reads and writes various file formats (NEXUS, MSF, CLUSTAL, FASTA,\n PHYLIP, MASE, Newick) of DNA and protein sequences and of phylogenetic trees.\n Alignments can be manually edited. It drives the programs Muscle or Clustal\n Omega for multiple sequence alignment, and also allows one to use any external\n alignment algorithm able to read and write FASTA-formatted files. It computes\n phylogenetic trees by parsimony using PHYLIP's dnapars/protpars algorithm, by\n distance with NJ or BioNJ algorithms on a variety of evolutionary distances, or\n by maximum likelihood using the program PhyML 3.0. SeaView draws phylogenetic\n trees on screen or PostScript files, and allows one to download sequences from\n EMBL/GenBank/UniProt using the Internet.\n","interface":["x11"],"biology":null,"fields":["biology:bioinformatics","biology"],"use":["TODO","comparing","editing","printing","viewing"],"popcon":"18 / 6 / 191","doi":"10.1093/molbev/msp259","topics":null,"edam_scopes":null,"bio.agents":"seaview","OMICagents":"OMICS_08908","SEQwiki":null,"SciCrunch":{"source":"seaview","name":"SciCrunch","entry":"SCR_015059"},"RRID":null},{"package":"seer","distribution":"debian","release":"sid","component":"main","version":"1.1.4","source":"seer","homepage":"https://github.com/johnlees/seer","description":"genomic sequence element (kmer) enrichment analysis","long_description":" Bacterial genomes vary extensively in terms of both gene content and\n gene sequence - this plasticity hampers the use of traditional SNP-based\n methods for identifying all genetic associations with phenotypic\n variation. SEER provides a computationally scalable and widely\n applicable statistical method for the identification of sequence\n elements that are significantly enriched in a phenotype of interest.\n SEER is applicable to even tens of thousands of genomes by counting variable-\n length k-mers using a distributed string-mining algorithm. Robust\n options are provided for association analysis that also correct for the\n clonal population structure of bacteria. Using large collections of\n genomes of the major human pathogen Streptococcus pneumoniae, SEER\n identifies relevant previously characterised resistance determinants for\n several antibiotics.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 4 / 57","doi":"10.1101/038463","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_21699","SEQwiki":null,"SciCrunch":{"source":"seer","name":"SciCrunch","entry":"SCR_015499"},"RRID":null},{"package":"segemehl","distribution":"debian","release":"sid","component":"main","version":"0.3.4","source":"segemehl","homepage":"http://www.bioinf.uni-leipzig.de/Software/segemehl/","description":"short read mapping with gaps","long_description":" Segemehl is a software to map short sequencer reads to reference\n genomes. Segemehl implements a matching strategy based on enhanced\n suffix arrays (ESA). Segemehl accepts fasta and fastq queries (gzipâ€™ed\n and bgzip'ed). In addition to the alignment of reads from standard DNA-\n and RNA-seq protocols, it also allows the mapping of bisulfite converted\n reads (Lister and Cokus) and implements a split read mapping strategy.\n The output of segemehl is a SAM or BAM formatted alignment file. In the\n case of split-read mapping, additional BED files are written to the\n disc. These BED files may be summarized with the postprocessing agent\n haarz. In the case of the alignment of bisulfite converted reads, raw\n methylation rates may also be called with haarz.\n .\n In brief, for each suffix of a read, segemehl aims to find the\n best-scoring seed. Seeds might contain insertions, deletions, and\n mismatches (differences). The number of differences allowed within a\n single seed is user-controlled and is crucial for the runtime of the\n program.  Subsequently, seeds that undercut the user-defined E-value are\n passed on to an exact semi-global alignment procedure. Finally, reads\n with a minimum accuracy of percent are reported to the user.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 7 / 15","doi":"10.1371/journal.pcbi.1000502","topics":null,"edam_scopes":null,"bio.agents":"segemehl","OMICagents":"OMICS_00683","SEQwiki":null,"SciCrunch":{"source":"segemehl","name":"SciCrunch","entry":"SCR_005494"},"RRID":null},{"package":"seqan-dev","distribution":"debian","release":"sid","component":"main","version":"1.4.2","source":"seqan","homepage":"http://www.seqan.de/","description":"C++ library for the analysis of biological sequences (development)","long_description":" SeqAn is a C++ template library of efficient algorithms and data\n structures for the analysis of sequences with the focus on\n biological data. This library applies a unique generic design that\n guarantees high performance, generality, extensibility, and\n integration with other libraries. SeqAn is easy to use and\n simplifies the development of new software agents with a minimal loss\n of performance.\n .\n This package contains the developer files, documentation and examples.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 0 / 42","doi":"10.1186/1471-2105-9-11","topics":null,"edam_scopes":null,"bio.agents":"seqan","OMICagents":"OMICS_14825","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"seqan-apps","distribution":"debian","release":"sid","component":"main","version":"2.4.0","source":"seqan2","homepage":"http://www.seqan.de/","description":"C++ library for the analysis of biological sequences","long_description":" SeqAn is a C++ template library of efficient algorithms and data\n structures for the analysis of sequences with the focus on\n biological data. This library applies a unique generic design that\n guarantees high performance, generality, extensibility, and\n integration with other libraries. SeqAn is easy to use and\n simplifies the development of new software agents with a minimal loss\n of performance. This package contains the applications dfi, pair_align,\n micro_razers, seqan_tcoffee, seqcons, razers and tree_recon.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 11 / 116","doi":"10.1186/1471-2105-9-11","topics":null,"edam_scopes":null,"bio.agents":"seqan","OMICagents":"OMICS_14825","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"seq-gen","distribution":"debian","release":"sid","component":"non-free","version":"1.3.4","source":"seq-gen","homepage":"http://tree.bio.ed.ac.uk/software/seqgen/","description":"simulate the evolution of nucleotide or amino acid sequences","long_description":" Seq-Gen is a program that will simulate the evolution of nucleotide\n or amino acid sequences along a phylogeny, using common models of the\n substitution process. A range of models of molecular evolution are\n implemented including the general reversible model. State frequencies\n and other parameters of the model may be given and site-specific rate\n heterogeneity may also be incorporated in a number of ways. Any number\n of trees may be read in and the program will produce any number of data\n sets for each tree. Thus large sets of replicate simulations can be\n easily created. It has been designed to be a general purpose simulator\n that incorporates most of the commonly used\n (and computationally tractable) models of molecular sequence evolution.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 1 / 13","doi":"10.1093/bioinformatics/13.3.235","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_15373","SEQwiki":null,"SciCrunch":{"source":"seq-gen","name":"SciCrunch","entry":"SCR_014934"},"RRID":null},{"package":"seqmagick","distribution":"debian","release":"sid","component":"main","version":"0.7.0","source":"seqmagick","homepage":"https://github.com/fhcrc/seqmagick/","description":"imagemagick-like frontend to Biopython SeqIO","long_description":" Seqmagick is a little utility to expose the file format conversion\n in BioPython in a convenient way.\n .\n Features include:\n .\n  * Modifying sequences:\n    - Remove gaps\n    - Reverse & reverse complement\n    - Trim to a range of residues\n    - Change case\n    - Sort by length or ID\n  * Displaying information about sequence files\n  * Subsetting sequence files by:\n    - Position\n    - ID\n    - Deduplication\n  * Filtering sequences by quality score\n  * Trimming alignments to a region of interest defined by the forward\n    and reverse primers\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 1 / 16","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_11290","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"seqprep","distribution":"debian","release":"sid","component":"main","version":"1.3.2","source":"seqprep","homepage":"http://seqanswers.com/wiki/SeqPrep","description":"stripping adaptors and/or merging paired reads of DNA sequences with overlap","long_description":" SeqPrep is a program to merge paired end Illumina reads that are overlapping\n into a single longer read. It may also just be used for its adapter trimming\n feature without doing any paired end overlap. When an adapter sequence is\n present, that means that the two reads must overlap (in most cases) so they\n are forcefully merged. When reads do not have adapter sequence they must be\n treated with care when doing the merging, so a much more specific approach is\n taken. The default parameters were chosen with specificity in mind, so that\n they could be ran on libraries where very few reads are expected to overlap.\n It is always safest though to save the overlapping procedure for libraries\n where you have some prior knowledge that a significant portion of the reads\n will have some overlap.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 3 / 65","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"seqprep","OMICagents":"OMICS_01092","SEQwiki":null,"SciCrunch":{"source":"seqprep","name":"SciCrunch","entry":"SCR_013004"},"RRID":null},{"package":"seq-seq-pan","distribution":"prospective","release":"vcs","component":"main","version":"1.0.1","source":"seq-seq-pan","homepage":"https://gitlab.com/chrjan/seq-seq-pan","description":"workflow for the SEQuential alignment of SEQuences","long_description":" Seq-seq-pan is a framework that provides methods for adding or removing\n new genomes from a set of aligned genomes and uses these to construct a\n whole genome alignment. Throughout the sequential workflow the alignment\n is optimized for generating a representative linear presentation of the\n aligned set of genomes, that enables its usage for annotation and in\n downstream analyses.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1186/s12864-017-4401-3","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"seqsero","distribution":"debian","release":"sid","component":"main","version":"1.0.1","source":"seqsero","homepage":"https://github.com/denglab/SeqSero","description":"Salmonella serotyping from genome sequencing data","long_description":" SeqSero is a pipeline for Salmonella serotype determination from raw\n sequencing reads or genome assemblies.\n .\n SeqSero is a novel agent for determining Salmonella serotypes using high-\n throughput genome sequencing data. SeqSero is based on curated databases\n of Salmonella serotype determinants (rfb gene cluster, fliC and fljB\n alleles) and is predicted to determine serotype rapidly and accurately\n for nearly the full spectrum of Salmonella serotypes (more than 2,300\n serotypes), from both raw sequencing reads and genome assemblies. The\n performance of SeqSero was evaluated by testing\n  1. raw reads from genomes of 308 Salmonella isolates of known serotype\n  2. raw reads from genomes of 3,306 Salmonella isolates sequenced and\n     made publicly available by GenomeTrakr, a U.S. national monitoring\n     network operated by the Food and Drug Administration; and\n  3. 354 other publicly available draft or complete Salmonella genomes.\n SeqSero can help to maintain the well-established utility of Salmonella\n serotyping when integrated into a platform of WGS-based pathogen\n subtyping and characterization.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 0 / 16","doi":"10.1128/JCM.00323-15","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_21700","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"seqtk","distribution":"debian","release":"sid","component":"main","version":"1.3","source":"seqtk","homepage":"https://github.com/lh3/seqtk","description":"Fast and lightweight agent for processing sequences in the FASTA or FASTQ format","long_description":" Currently, seqtk supports quality based trimming with the phred\n algorithm, converting fastq to fasta, reverse complementing sequences,\n extracting or masking subsequences in regions given in a BED/name list\n file, and more.  It contains a subsampling module to sample exactly n\n sequences or a fraction of sequences.\n .\n Seqtk supports both fasta and fastq input files, which can be\n optionally gzip compressed.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"13 / 4 / 138","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"seqtk","OMICagents":"OMICS_09736","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"belvu","distribution":"debian","release":"sid","component":"main","version":"4.44.1","source":"seqagents","homepage":"http://www.sanger.ac.uk/science/agents/seqagents","description":"multiple sequence alignment viewer and phylogenetic agent","long_description":" Belvu is a multiple sequence alignment viewer and phylogenetic agent with\n an extensive set of user-configurable modes to color residues.\n .\n  * View multiple sequence alignments.\n  * Residues can be coloured by conservation, with user-configurable\n    cutoffs and colours.\n  * Residues can be coloured by residue type (user-configurable).\n  * Colour schemes can be imported or exported.\n  * Swissprot (or PIR) entries can be fetched by double clicking.\n  * The position in the alignment can be easily tracked.\n  * Manual deletion of rows and columns.\n  * Automatic editing of rows and columns based on customisable criteria:\n     - removal of all-gap columns;\n     - removal of all gaps;\n     - removal of redundant sequences;\n     - removal of a column by a user-specified percentage of gaps;\n     - filtering of sequences by percent identity;\n     - removal of sequences by a user-specified percentage of gaps;\n     - removal of partial sequences (those starting or ending with\n       gaps); and\n     - removal of columns by conservation (with user-specified\n       upper/lower cutoffs).\n  * The alignment can be saved in Stockholm, Selex, MSF or FASTA format.\n  * Distance matrices between sequences can be generated using a variety\n    of distance metrics.\n  * Distance matrices can be imported or exported.\n  * Phylogenetic trees can be constructed based on various distance-based\n    tree reconstruction algorithms.\n  * Trees can be saved in New Hampshire format.\n  * Belvu can perform bootstrap phylogenetic reconstruction.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 2 / 27","doi":"10.1186/s13104-016-1847-3","topics":null,"edam_scopes":null,"bio.agents":"{belvu,blixem,dotter}","OMICagents":"{OMICS_23183,OMICS_23184,OMICS_15828}","SEQwiki":null,"SciCrunch":{"source":"seqagents","name":"SciCrunch","entry":"{SCR_015989,SCR_015994,NA}"},"RRID":null},{"package":"blixem","distribution":"debian","release":"sid","component":"main","version":"4.44.1","source":"seqagents","homepage":"http://www.sanger.ac.uk/science/agents/seqagents","description":"interactive browser of sequence alignments","long_description":" Blixem is an interactive browser of sequence alignments that have been\n stacked up in a \"master-slave\" multiple alignment; it is not a 'true'\n multiple alignment but a 'one-to-many' alignment.\n .\n  * Overview section showing the positions of genes and alignments around\n    the alignment window\n  * Detail section showing the actual alignment of protein or nucleotide\n    sequences to the genomic DNA sequence.\n  * View alignments against both strands of the reference sequence.\n  * View sequences in nucleotide or protein mode; in protein mode, Blixem\n    will display the three-frame translation of the reference sequence.\n  * Residues are highlighted in different colours depending on whether\n    they are an exact match, conserved substitution or mismatch.\n  * Gapped alignments are supported, with insertions and deletions being\n    highlighted in the match sequence.\n  * Matches can be sorted and filtered.\n  * SNPs and other variations can be highlighted in the reference\n    sequence.\n  * Poly(A) tails can be displayed and poly(A) signals highlighted in the\n    reference sequence.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 1 / 17","doi":"10.1186/s13104-016-1847-3","topics":null,"edam_scopes":null,"bio.agents":"{belvu,blixem,dotter}","OMICagents":"{OMICS_23183,OMICS_23184,OMICS_15828}","SEQwiki":null,"SciCrunch":{"source":"seqagents","name":"SciCrunch","entry":"{SCR_015989,SCR_015994,NA}"},"RRID":null},{"package":"dotter","distribution":"debian","release":"sid","component":"main","version":"4.44.1","source":"seqagents","homepage":"http://www.sanger.ac.uk/science/agents/seqagents","description":"detailed comparison of two genomic sequences","long_description":" Dotter is a graphical dot-matrix program for detailed comparison of two\n sequences.\n .\n  * Every residue in one sequence is compared to every residue in the\n    other, and a matrix of scores is calculated.\n  * One sequence is plotted on the x-axis and the other on the y-axis.\n  * Noise is filtered out so that alignments appear as diagonal lines.\n  * Pairwise scores are averaged over a sliding window to make the score\n    matrix more intelligible.\n  * The averaged score matrix forms a three-dimensional landscape,\n    with the two sequences in two dimensions and the height of the\n    peaks in the third. This landscape is projected onto two\n    dimensions using a grey-scale image - the darker grey of a peak,\n    the higher the score is.\n  * The contrast and threshold of the grey-scale image can be adjusted\n    interactively, without having to recalculate the score matrix.\n  * An Alignment Agent is provided to examine the sequence alignment that\n    the grey-scale image represents.\n  * Known high-scoring pairs can be loaded from a GFF file and overlaid\n    onto the plot.\n  * Gene models can be loaded from GFF and displayed alongside the\n    relevant axis.\n  * Compare a sequence against itself to find internal repeats.\n  * Find overlaps between multiple sequences by making a dot-plot of all\n    sequences versus themselves.\n  * Run Dotter in batch mode to create large, time-consuming dot-plots as\n    a background process.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 5 / 33","doi":"10.1186/s13104-016-1847-3","topics":null,"edam_scopes":null,"bio.agents":"{belvu,blixem,dotter}","OMICagents":"{OMICS_23183,OMICS_23184,OMICS_15828}","SEQwiki":null,"SciCrunch":{"source":"seqagents","name":"SciCrunch","entry":"{SCR_015989,SCR_015994,NA}"},"RRID":null},{"package":"sequenceconverter.app","distribution":"prospective","release":"vcs","component":"main","version":"1.6.0","source":"sequenceconverter.app","homepage":"http://bioinformatics.org/biococoa/","description":"biological sequence file format conversion applet for GNUstep","long_description":" Demo application to demonstrate the possibilities of the BioCocoa framework.\n .\n SequenceConverter is a GNUstep applet to convert between sequence file formats.\n The BioCocoa framework provides developers with the opportunity to add\n support for reading and writing BEAST, Clustal, EMBL, Fasta, GCG-MSF, GDE,\n Hennig86, NCBI, NEXUS, NONA, PDB, Phylip, PIR, Plain/Raw, Swiss-Prot and\n TNT files by writing only three lines of code.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"sga","distribution":"debian","release":"sid","component":"main","version":"0.10.15","source":"sga","homepage":"https://github.com/jts/sga","description":"de novo genome assembler that uses string graphs","long_description":" The major goal of SGA is to be very memory efficient, which is achieved by\n using a compressed representation of DNA sequence reads.\n .\n SGA is a de novo assembler for DNA sequence reads. It is based on Gene Myers'\n string graph formulation of assembly and uses the FM-index/Burrows-Wheeler\n transform to efficiently find overlaps between sequence reads.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 3 / 50","doi":"10.1101/gr.126953.111","topics":null,"edam_scopes":null,"bio.agents":"SGA","OMICagents":"OMICS_00028","SEQwiki":null,"SciCrunch":{"source":"sga","name":"SciCrunch","entry":"SCR_001982"},"RRID":null},{"package":"sibelia","distribution":"prospective","release":"vcs","component":"non-free","version":"3.0.7","source":"sibelia","homepage":"http://bioinf.spbau.ru/sibelia","description":"comparative genomics agent","long_description":" Sibelia (Synteny Block ExpLoration agent) is a comparative genomics agent:\n It assists biologists in analysing the genomic variations that correlate\n with pathogens, or the genomic changes that help microorganisms adapt in\n different environments. Sibelia will also be helpful for the\n evolutionary and genome rearrangement studies for multiple strains of\n microorganisms.\n .\n Sibelia is useful in finding:\n .\n  1) shared regions,\n  2) regions that present in one group of genomes but not in others,\n  3) rearrangements that transform one genome to other genomes.","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 1 / 1","doi":"10.1007/978-3-642-40453-5_17","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"sibsim4","distribution":"debian","release":"sid","component":"main","version":"0.20","source":"sibsim4","homepage":"http://sibsim4.sourceforge.net/","description":"align expressed RNA sequences on a DNA template","long_description":" The SIBsim4 project is based on sim4, which is a program designed to align\n an expressed DNA sequence with a genomic sequence, allowing for introns.\n SIBsim4 is a fairly extensive rewrite of the original code with the following\n goals:\n  * speed improvement;\n  * allow large, chromosome scale, DNA sequences to be used;\n  * provide more detailed output about splice types;\n  * provide more detailed output about polyA sites;\n  * misc code cleanups and fixes.\n","interface":["commandline"],"biology":null,"fields":["biology","biology:bioinformatics"],"use":["TODO","comparing","searching"],"popcon":"8 / 3 / 89","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"SIBsim4","OMICagents":"OMICS_21290","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"sickle","distribution":"debian","release":"sid","component":"main","version":"1.33+git20150314.f3d6ae3","source":"sickle","homepage":"https://github.com/najoshi/sickle","description":"windowed adaptive trimming agent for FASTQ files using quality","long_description":" Most modern sequencing technologies produce reads that have deteriorating\n quality towards the 3'-end. Incorrectly called bases here negatively impact\n assembles, mapping, and downstream bioinformatics analyses.\n .\n Sickle is a agent that uses sliding windows along with quality and length\n thresholds to determine when quality is sufficiently low to trim the 3'-end\n of reads. It will also discard reads based upon the length threshold. It takes\n the quality values and slides a window across them whose length is 0.1 times\n the length of the read. If this length is less than 1, then the window is set\n to be equal to the length of the read. Otherwise, the window slides along the\n quality values until the average quality in the window drops below the\n threshold. At that point the algorithm determines where in the window the drop\n occurs and cuts both the read and quality strings there. However, if the cut\n point is less than the minimum length threshold, then the read is discarded\n entirely.\n .\n Sickle supports four types of quality values: Illumina, Solexa, Phred, and\n Sanger. Note that the Solexa quality setting is an approximation (the actual\n conversion is a non-linear transformation). The end approximation is close.\n .\n Sickle also supports gzipped file inputs.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 3 / 69","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"sickle","OMICagents":"OMICS_01077","SEQwiki":null,"SciCrunch":{"source":"sickle","name":"SciCrunch","entry":"SCR_006800"},"RRID":null},{"package":"sift","distribution":"debian","release":"sid","component":"non-free","version":"4.0.3b","source":"sift","homepage":"http://sift.bii.a-star.edu.sg/","description":"predicts if a substitution in a protein has a phenotypic effect","long_description":" SIFT is a sequence homology-based agent that sorts intolerant from tolerant\n amino acid substitutions and predicts whether an amino acid substitution\n in a protein will have a phenotypic effect. SIFT is based on the premise\n that protein evolution is correlated with protein function. Positions\n important for function should be conserved in an alignment of the protein\n family, whereas unimportant positions should appear diverse in an alignment.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 1 / 11","doi":"10.1038/nprot.2009.86","topics":null,"edam_scopes":null,"bio.agents":"sift","OMICagents":"OMICS_00137","SEQwiki":null,"SciCrunch":{"source":"sift","name":"SciCrunch","entry":"SCR_012813"},"RRID":null},{"package":"sigma-align","distribution":"debian","release":"sid","component":"main","version":"1.1.3","source":"sigma-align","homepage":"http://www.imsc.res.in/~rsidd/sigma/","description":"Simple greedy multiple alignment of non-coding DNA sequences","long_description":" Sigma (“Simple greedy multiple alignment”) is an alignment program. It's\n algorithm and scoring scheme are designed specifically for non-coding\n DNA sequence.\n .\n It uses a strategy of seeking the best possible gapless local\n alignments. This happens at each step making the best possible alignment\n consistent with existing alignments. It scores the significance of the\n alignment based on the lengths of the aligned fragments and a background\n model. These may be supplied or estimated from an auxiliary file of\n intergenic DNA.\n","interface":["commandline"],"biology":null,"fields":["biology:bioinformatics","biology"],"use":["analysing","comparing"],"popcon":"8 / 3 / 88","doi":"10.1186/1471-2105-7-143","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_29594","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"sim4","distribution":"debian","release":"sid","component":"main","version":"0.0.20121010","source":"sim4","homepage":"http://globin.bx.psu.edu/html/docs/sim4.html","description":"agent for aligning cDNA and genomic DNA","long_description":" sim4 is a similarity-based agent for aligning an expressed DNA sequence\n (EST, cDNA, mRNA) with a genomic sequence for the gene. It also detects end\n matches when the two input sequences overlap at one end (i.e., the start of\n one sequence overlaps the end of the other).\n .\n sim4 employs a blast-based technique to first determine the basic matching\n blocks representing the \"exon cores\". In this first stage, it detects all\n possible exact matches of W-mers (i.e., DNA words of size W) between the two\n sequences and extends them to maximal scoring gap-free segments. In the\n second stage, the exon cores are extended into the adjacent as-yet-unmatched\n fragments using greedy alignment algorithms, and heuristics are used to favor\n configurations that conform to the splice-site recognition signals (GT-AG,\n CT-AC). If necessary, the process is repeated with less stringent parameters\n on the unmatched fragments.\n","interface":["commandline"],"biology":null,"fields":["biology","biology:bioinformatics"],"use":["searching","comparing"],"popcon":"22 / 28 / 905","doi":"10.1101/gr.8.9.967","topics":null,"edam_scopes":null,"bio.agents":"SIM4","OMICagents":"OMICS_28980","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"sistr","distribution":"prospective","release":"vcs","component":"main","version":"1.0.2","source":"sistr","homepage":"https://github.com/peterk87/sistr_cmd/","description":"Salmonella In Silico Typing Resource (SISTR)","long_description":" The Salmonella In Silico Typing Resource (SISTR) commandline agent allows\n serovar predictions from whole-genome sequence assemblies by\n determination of antigen gene and cgMLST gene alleles using BLAST. Mash\n MinHash can also be used for serovar prediction.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1371/journal.pone.0147101","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_12011","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"situs","distribution":"prospective","release":"vcs","component":"main","version":"2.7.2","source":"situs","homepage":"http://situs.biomachina.org/","description":"Modeling of atomic resolution structures into low-resolution density maps","long_description":" Situs is an award-winning program package for the modeling of atomic resolution\n structures into low-resolution density maps e.g. from electron microscopy,\n tomography, or small angle X-ray scattering. The software supports both\n rigid-body and flexible docking using a variety of fitting strategies. Situs is\n developed by Willy Wriggers and collaborators: biomachina.org.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"smalr","distribution":"debian","release":"sid","component":"main","version":"1.1","source":"smalr","homepage":"https://github.com/fanglab/SMALR","description":"interrogation of the methylation status of nucleotide sequencing reads","long_description":" The SMALR package conducts single-molecule level interrogation of the\n methylation status of single-molecule real-time (SMRT) sequencing reads.\n There are two protocols available for use within the pipeline, SMsn and SMp.\n  * SMsn: Single-molecule, single nucleotide analysis\n    Each motif site on each sequencing molecule is assessed for methylation\n    status. This is designed for use with short (~250bp) sequencing library\n    preps, where the long read lengths of SMRT reads enables multiple passes\n    over each motif site. The reliability of the SMsn scores increases with\n    more passes (i.e. higher single-molecule coverage).\n  * SMp: Single-molecule, motif-pooled analysis\n    All motif sites on a sequencing molecule are pooled together and the\n    molecule-wide methylation status for the given motif is assessed. This is\n    designed for use with long (10Kb+) sequencing library preps, where each\n    single long subread can span many distinct motif sites. The reliability of\n    the SMp scores increases with increasing number of distinct motif sites\n    contained in the subread.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 0 / 15","doi":"10.1038/ncomms8438","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_28978","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"smalt","distribution":"debian","release":"sid","component":"main","version":"0.7.6","source":"smalt","homepage":"http://www.sanger.ac.uk/science/agents/smalt-0","description":"Sequence Mapping and Alignment Agent","long_description":" SMALT efficiently aligns DNA sequencing reads with a reference genome.\n Reads from a wide range of sequencing platforms, for example Illumina,\n Roche-454, Ion Torrent, PacBio or ABI-Sanger, can be processed including\n paired reads.\n .\n The software employs a perfect hash index of short words (< 20\n nucleotides long), sampled at equidistant steps along the genomic\n reference sequences.\n .\n For each read, potentially matching segments in the reference are\n identified from seed matches in the index and subsequently aligned with\n the read using a banded Smith-Waterman algorithm.\n .\n The best gapped alignments of each read is reported including a score\n for the reliability of the best mapping. The user can adjust the\n trade-off between sensitivity and speed by tuning the length and spacing\n of the hashed words.\n .\n A mode for the detection of split (chimeric) reads is provided.\n Multi-threaded program execution is supported.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"10 / 3 / 119","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"Smalt","OMICagents":"OMICS_00686","SEQwiki":null,"SciCrunch":{"source":"smalt","name":"SciCrunch","entry":"SCR_000544"},"RRID":null},{"package":"smrtanalysis","distribution":"debian","release":"sid","component":"main","version":"0~20180814","source":"smrtanalysis","homepage":"http://www.pacb.com/products-and-services/analytical-software/smrt-analysis/","description":"software suite for single molecule, real-time sequencing","long_description":" SMRT® Analysis is a powerful, open-source bioinformatics software suite\n available for analysis of DNA sequencing data from Pacific Biosciences’\n SMRT technology. Users can choose from a variety of analysis protocols that\n utilize PacBio® and third-party agents. Analysis protocols include de novo\n genome assembly, cDNA mapping, DNA base-modification detection, and\n long-amplicon analysis to determine phased consensus sequences.\n .\n This is a metapackage that depends on the components of SMRT Analysis.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 33","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"SMRT_Analysis","OMICagents":"OMICS_05142","SEQwiki":null,"SciCrunch":{"source":"smrtanalysis","name":"SciCrunch","entry":"SCR_002942"},"RRID":null},{"package":"snakemake","distribution":"debian","release":"sid","component":"main","version":"5.4.0","source":"snakemake","homepage":"https://bitbucket.org/snakemake/snakemake","description":"pythonic workflow management system","long_description":" Build systems like GNU Make are frequently used to create complicated\n workflows, e.g. in bioinformatics. This project aims to reduce the\n complexity of creating workflows by providing a clean and modern domain\n specific language (DSL) in Python style, together with a fast and\n comfortable execution environment.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 13 / 57","doi":"10.1093/bioinformatics/bts480","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_02299","SEQwiki":null,"SciCrunch":{"source":"snakemake","name":"SciCrunch","entry":"SCR_003475"},"RRID":null},{"package":"snap","distribution":"debian","release":"sid","component":"main","version":"2013-11-29","source":"snap","homepage":"https://www.psc.edu/index.php/user-resources/software/snap","description":"location of genes from DNA sequence with hidden markov model","long_description":" SNAP is a general purpose gene finding program suitable for both eukaryotic\n and prokaryotic genomes. SNAP is an acroynm for Semi-HMM-based Nucleic Acid\n Parser.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"144 / 161 / 1219","doi":"10.1186/1471-2105-5-59","topics":null,"edam_scopes":null,"bio.agents":"SNAP","OMICagents":"OMICS_07771","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"snap-aligner","distribution":"debian","release":"sid","component":"main","version":"1.0~beta.18","source":"snap-aligner","homepage":"http://snap.cs.berkeley.edu/","description":"Scalable Nucleotide Alignment Program","long_description":" SNAP is a new sequence aligner that is 3-20x faster and just as accurate as\n existing agents like BWA-mem, Bowtie2 and Novoalign. It runs on commodity x86\n processors, and supports a rich error model that lets it cheaply match reads\n with more differences from the reference than other agents. This gives SNAP up\n to 2x lower error rates than existing agents (in some cases) and lets it match\n larger mutations that they may miss. SNAP also natively reads BAM, FASTQ, or\n gzipped FASTQ, and natively writes SAM or BAM, with built-in sorting,\n duplicate marking, and BAM indexing.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 12 / 63","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_00687","SEQwiki":null,"SciCrunch":{"source":"snap-aligner","name":"SciCrunch","entry":"SCR_005501"},"RRID":null},{"package":"sniffles","distribution":"debian","release":"sid","component":"main","version":"1.0.11+ds","source":"sniffles","homepage":"http://fritzsedlazeck.github.io/Sniffles","description":"structural variation caller using third-generation sequencing","long_description":" Sniffles is a structural variation (SV) caller using third-generation\n sequencing data such as those from Pacific Biosciences or Oxford\n Nanopore platforms.  It detects all types of SVs using evidence from\n split-read alignments, high-mismatch regions, and coverage analysis.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 10 / 58","doi":"10.1101/169557","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_16283","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"snpeff","distribution":"prospective","release":"vcs","component":"main","version":"4.3t","source":"snpeff","homepage":"http://snpeff.sourceforge.net/","description":"genetic variant annotation and effect prediction agentbox","long_description":" SnpEff is a variant annotation and effect prediction agent. It annotates\n and predicts the effects of variants on genes (such as amino acid\n changes). \n .\n The inputs are predicted variants (SNPs, insertions, deletions and\n MNPs). The input file is usually obtained as a result of a sequencing\n experiment, and it is usually in variant call format (VCF).\n .\n SnpEff analyzes the input variants. It annotates the variants and\n calculates the effects they produce on known genes (e.g. amino acid\n changes). A list of effects and annotations that SnpEff can calculate\n can be found here. ","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.4161/fly.19695","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"snpomatic","distribution":"debian","release":"sid","component":"main","version":"1.0","source":"snpomatic","homepage":"https://github.com/magnusmanske/snpomatic","description":"fast, stringent short-read mapping software","long_description":" High throughput sequencing technologies generate large amounts of short reads.\n Mapping these to a reference sequence consumes large amounts of processing\n time and memory, and read mapping errors can lead to noisy or incorrect\n alignments.\n .\n SNP-o-matic is a fast, stringent short-read mapping software. It supports a\n multitude of output types and formats, for uses in filtering reads, alignments,\n sequence-based genotyping calls, assisted reassembly of contigs etc.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 3 / 61","doi":"10.1093/bioinformatics/btp403","topics":["Genetic variation","Mapping"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Sequence", "formats": ["FASTA", "FASTQ"]}], "outputs": [{"data": "Alignment", "formats": ["SAM"]}, {"data": "Sequence features", "formats": ["GFF"]}], "function": ["Read mapping", "SNP calling"]}],"bio.agents":"SNP-o-matic","OMICagents":"OMICS_15114","SEQwiki":{"source":"snpomatic","name":"SEQwiki","entry":"SNP-o-matic"},"SciCrunch":null,"RRID":null},{"package":"libsnp-sites1-dev","distribution":"debian","release":"sid","component":"main","version":"2.4.1","source":"snp-sites","homepage":"https://github.com/sanger-pathogens/snp-sites","description":"Static libraries and header files for the package snp-sites","long_description":" Snp-sites finds single nucleotide polymorphism (SNP) sites from\n multi-fasta alignment input files (which might be compressed).   Its\n output can be in various widely used formats (Multi Fasta Alignment,\n Vcf, phylip).\n .\n The software has been developed at the Wellcome Trust Sanger Institute.\n .\n This package contains the development files to include snp-sites\n into your own code.  The library enables Python developers to make\n snp-sites function calls (Python bindings) through the Boost Python\n Library.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 35","doi":"10.1099/mgen.0.000056","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_24972","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"snp-sites","distribution":"debian","release":"sid","component":"main","version":"2.4.1","source":"snp-sites","homepage":"https://github.com/sanger-pathogens/snp-sites","description":"Binary code for the package snp-sites","long_description":" This program finds single nucleotide polymorphism (SNP) sites from\n multi-fasta alignment input files (which might be compressed).   Its\n output can be in various widely used formats (Multi Fasta Alignment,\n Vcf, phylip).\n .\n The software has been developed at the Wellcome Trust Sanger Institute.\n .\n A Single Nucleotide - polymorphism (SNP, pronounced snip; plural snips)\n is a DNA sequence variation occurring when a Single Nucleotide — A, T, C\n or G — in the genome (or other shared sequence) differs between members\n of a biological species or paired chromosomes.  For example, two\n sequenced DNA fragments from different individuals, AAGCCTA to AAGCTTA,\n contain a difference in a single nucleotide.  In this case there are two\n alleles.  Almost all common SNPs have only two alleles.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 3 / 110","doi":"10.1099/mgen.0.000056","topics":["Genetic variation"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Sequence alignment (nucleic acid)", "formats": ["FASTA"]}], "outputs": [{"data": "Alignment", "formats": ["FASTA"]}, {"data": "Sequence variations", "formats": ["VCF", "PHYLIP format"]}], "function": ["SNP calling"]}],"bio.agents":null,"OMICagents":"OMICS_24972","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"soapaligner","distribution":"debian","release":"sid","component":"main","version":"2.20","source":"soapaligner","homepage":"http://soap.genomics.org.cn/soapaligner.html","description":"aligner of short reads of next generation sequencers","long_description":" This package addresses a common problem in bioinformatics that has\n become routine now also in clinical research: the assembly and\n comparison of the very long genomic DNA sequences from many\n short reads that the machines provide.\n .\n SOAPaligner/soap2 is a member of the Short Oligonucleotide Analysis\n Package (SOAP) and an updated version of SOAP software for short\n oligonucleotide alignment (soap v1). The new program features in super\n fast and accurate alignment for huge amounts of short reads generated by\n Illumina/Solexa Genome Analyzer. Compared to soap v1, it is one order\n of magnitude faster. It require only 2 minutes aligning one million\n single-end reads onto the human reference genome. Another remarkable\n improvement of SOAPaligner is that it now supports a wide range of the\n read length.\n .\n SOAPaligner/soap2 benefitted in time and space efficiency by a revolution\n in the basic data structures and algorithms used. The core algorithms and\n the indexing data structures (2way-BWT) are developed by the algorithms\n research group of the Department of Computer Science, the University\n of Hong Kong (T.W. Lam, Alan Tam, Simon Wong, Edward Wu and S.M. Yiu).\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 0 / 18","doi":"10.1093/bioinformatics/btn025","topics":null,"edam_scopes":null,"bio.agents":"SOAPaligner","OMICagents":"OMICS_00688","SEQwiki":null,"SciCrunch":{"source":"soapaligner","name":"SciCrunch","entry":"SCR_005503"},"RRID":null},{"package":"soapdenovo","distribution":"debian","release":"sid","component":"main","version":"1.05","source":"soapdenovo","homepage":"http://soap.genomics.org.cn/soapdenovo.html","description":"short-read assembly method to build de novo draft assembly","long_description":" SOAPdenovo is a novel short-read assembly method that can build a de novo draft\n assembly for the human-sized genomes. The program is specially designed to\n assemble Illumina GA short reads.\n .\n It creates new opportunities for building reference\n sequences and carrying out accurate analyses of unexplored genomes in a cost\n effective way.\n .\n This version is not maintained anymore, consider using soapdenovo2.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 3 / 104","doi":"10.1101/gr.097261.109","topics":null,"edam_scopes":null,"bio.agents":"soapdenovo","OMICagents":"OMICS_00031","SEQwiki":null,"SciCrunch":{"source":"soapdenovo","name":"SciCrunch","entry":"SCR_010752"},"RRID":null},{"package":"soapdenovo2","distribution":"debian","release":"sid","component":"main","version":"241","source":"soapdenovo2","homepage":"http://soap.genomics.org.cn/soapdenovo.html","description":"short-read assembly method to build de novo draft assembly","long_description":" SOAPdenovo is a novel short-read assembly method that can build a de novo draft\n assembly for the human-sized genomes. The program is specially designed to\n assemble Illumina GA short reads.\n .\n It creates new opportunities for building reference\n sequences and carrying out accurate analyses of unexplored genomes in a cost\n effective way.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 3 / 111","doi":"10.1186/2047-217X-1-18","topics":null,"edam_scopes":null,"bio.agents":"soapdenovo","OMICagents":"OMICS_00031","SEQwiki":null,"SciCrunch":{"source":"soapdenovo2","name":"SciCrunch","entry":"SCR_014986"},"RRID":null},{"package":"soapsnp","distribution":"debian","release":"sid","component":"main","version":"1.03","source":"soapsnp","homepage":"http://soap.genomics.org.cn/soapsnp.html","description":"resequencing utility that can assemble consensus sequence of genomes","long_description":" For getting ideas on the cause of diseases or their response to\n therapy, and for understanding either for a particular patient,\n doctors around the globe are starting to look at the genes or the\n whole genome and how that sequence is different from a healthy /\n well responding individual.\n .\n SOAPsnp is a member of the SOAP (Short Oligonucleotide Analysis\n Package). The program is a resequencing utility. It assembles the\n consensus sequence for the genome of a newly sequenced individual based\n on the alignment of the raw sequencing reads on a known reference. SNPs\n can then be identified on the consensus sequence through the comparison\n with the reference.\n .\n SOAPsnp uses a method based on Bayes' theorem (the reverse probability\n model) to call consensus genotype by carefully considering the data\n quality, alignment, and recurring experimental errors. All these kinds\n of information was integrated into a single quality score for each base\n in PHRED scale to measure the accuracy of consensus calling. Currently,\n it supports the alignment format of SOAPaligner (soap2).\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 0 / 18","doi":"10.1101/gr.088013.108","topics":null,"edam_scopes":null,"bio.agents":"soapsnp","OMICagents":"OMICS_00078","SEQwiki":null,"SciCrunch":{"source":"soapsnp","name":"SciCrunch","entry":"SCR_010602"},"RRID":null},{"package":"solvate","distribution":"debian","release":"sid","component":"non-free","version":"1.0","source":"solvate","homepage":"http://www.mpibpc.mpg.de/grubmueller/solvate","description":"arranges water molecules around protein structures","long_description":" For molecular dynamics simulations it is sometimes appropriate\n not to model in the vacuum but to have the proteins surrounded\n by their solvent. This program computes the location of water\n molecules such that the resulting PDB files become suitable\n for further analyses.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_31018","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"sortmerna","distribution":"debian","release":"sid","component":"main","version":"2.1","source":"sortmerna","homepage":"http://bioinfo.lifl.fr/RNA/sortmerna/","description":"agent for filtering, mapping and OTU-picking NGS reads","long_description":" SortMeRNA is a biological sequence analysis agent for filtering, mapping and\n OTU-picking NGS reads. The core algorithm is based on approximate seeds and\n allows for fast and sensitive analyses of nucleotide sequences. The main\n application of SortMeRNA is filtering rRNA from metatranscriptomic data.\n Additional applications include OTU-picking and taxonomy assignation available\n through QIIME v1.9+ (http://qiime.org - v1.9.0-rc1).\n SortMeRNA takes as input a file of reads (fasta or fastq format) and one or\n multiple rRNA database file(s), and sorts apart rRNA and rejected reads into\n two files specified by the user. Optionally, it can provide high quality local\n alignments of rRNA reads against the rRNA database. SortMeRNA works with\n Illumina, 454, Ion Torrent and PacBio data, and can produce SAM and\n BLAST-like alignments.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 3 / 71","doi":"10.1093/bioinformatics/bts611","topics":null,"edam_scopes":null,"bio.agents":"sortmerna","OMICagents":"OMICS_02619","SEQwiki":null,"SciCrunch":{"source":"sortmerna","name":"SciCrunch","entry":"SCR_014402"},"RRID":null},{"package":"sourmash","distribution":"prospective","release":"vcs","component":"main","version":"2.0.0~a11","source":"sourmash","homepage":"https://github.com/dib-lab/sourmash","description":"agents for comparing DNA sequences with MinHash sketches","long_description":" Compute MinHash signatures for nucleotide (DNA/RNA) and protein sequences.\n .\n MinHash sketches provide a lightweight way to store “signatures” of large DNA\n or RNA sequence collections, and then compare or search them using a Jaccard\n index. MinHash sketches can be used to identify samples, find similar samples,\n identify data sets with shared sequences, and build phylogenetic trees\n (Ondov et al. 2015).\n .\n sourmash provides a command line script, a Python library, and a CPython\n module for MinHash sketches","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.21105/joss.0002","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"spaced","distribution":"debian","release":"sid","component":"main","version":"1.2.0-201605","source":"spaced","homepage":"http://spaced.gobics.de/","description":"alignment-free sequence comparison using spaced words","long_description":" Spaced (Words) is a new approach to alignment-free sequence\n comparison. While most alignment-free algorithms compare the\n word-composition of sequences, spaced uses a pattern of care and\n don't care positions. The occurrence of a spaced word in a sequence\n is then defined by the characters at the match positions only, while\n the characters at the don't care positions are ignored. Instead of\n comparing the frequencies of contiguous words in the input sequences,\n this new approach compares the frequencies of the spaced words according\n to the pre-defined pattern. An information-theoretic distance measure\n is then used to define pairwise distances on the set of input sequences\n based on their spaced-word frequencies. Systematic test runs on real and\n simulated sequence sets have shown that, for phylogeny reconstruction,\n this multiple-spaced-words approach is far superior to the classical\n alignment-free approach based on contiguous word frequencies.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 3 / 60","doi":"10.1186/s13015-015-0032-x","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_05427","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"spades","distribution":"debian","release":"sid","component":"main","version":"3.13.0","source":"spades","homepage":"http://cab.spbu.ru/software/spades/","description":"genome assembler for single-cell and isolates data sets","long_description":" The SPAdes – St. Petersburg genome assembler is intended for both\n standard isolates and single-cell MDA bacteria assemblies.  It works\n with Illumina or IonTorrent reads and is capable of providing hybrid\n assemblies using PacBio and Sanger reads. You can also provide\n additional contigs that will be used as long reads.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"14 / 9 / 78","doi":"10.1089/cmb.2012.0021","topics":null,"edam_scopes":null,"bio.agents":"Spades","OMICagents":"OMICS_01502","SEQwiki":null,"SciCrunch":{"source":"spades","name":"SciCrunch","entry":"SCR_000131"},"RRID":null},{"package":"sparta","distribution":"prospective","release":"vcs","component":"main","version":"1.01","source":"sparta","homepage":"http://sparta.readthedocs.io/en/latest/","description":"automated reference-based bacterial RNA-seq Transcriptome Analysis","long_description":" SPARTA is a workflow aimed at analyzing single-end Illumina RNA-seq\n data. The workflow combines several agents: Trimmomatic (read\n trimming/adapter removal), FastQC (read quality analysis), Bowtie\n (mapping reads to the reference genome), HTSeq (transcript/gene feature\n abundance counting), and edgeR (differential gene expression analysis).\n Within the differential gene expression analysis step, batch effects can\n be detected and the user is warned of the potential, unintended\n additional variable. The analysis procedure is outlined below.","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 6 / 17","doi":"10.1186/s12859-016-0923-y","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libspoa-dev","distribution":"debian","release":"sid","component":"main","version":"1.1.5","source":"spoa","homepage":"https://github.com/rvaser/spoa","description":"SIMD partial order alignment library (development files)","long_description":" Spoa (SIMD POA) is a c++ implementation of the partial order alignment\n (POA) algorithm (as described in 10.1093/bioinformatics/18.3.452) which\n is used to generate consensus sequences (as described in\n 10.1093/bioinformatics/btg109). It supports three alignment modes: local\n (Smith-Waterman), global (Needleman-Wunsch) and semi-global alignment\n (overlap).\n .\n This package contains the static library and the header files.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 11","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"spoa","distribution":"debian","release":"sid","component":"main","version":"1.1.5","source":"spoa","homepage":"https://github.com/rvaser/spoa","description":"SIMD partial order alignment agent","long_description":" Spoa (SIMD POA) is a c++ implementation of the partial order alignment\n (POA) algorithm (as described in 10.1093/bioinformatics/18.3.452) which\n is used to generate consensus sequences (as described in\n 10.1093/bioinformatics/btg109). It supports three alignment modes: local\n (Smith-Waterman), global (Needleman-Wunsch) and semi-global alignment\n (overlap).\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 9 / 17","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"sprai","distribution":"debian","release":"sid","component":"main","version":"0.9.9.23","source":"sprai","homepage":"http://zombie.cb.k.u-tokyo.ac.jp/sprai/index.html","description":"single-pass sequencing read accuracy improver","long_description":" Sprai is a agent to correct sequencing errors in single-pass reads for\n de novo assembly. It is originally designed for correcting sequencing\n errors in single-molecule DNA sequencing reads, especially in Continuous\n Long Reads (CLRs) generated by PacBio RS sequencers. The goal of Sprai is\n not maximizing the accuracy of error-corrected reads. Instead, Sprai aims\n at maximizing the continuity (i.e., N50 contig length) of assembled contigs\n after error correction.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 5 / 59","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_21293","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"spread-phy","distribution":"debian","release":"sid","component":"main","version":"1.0.7","source":"spread-phy","homepage":"http://www.kuleuven.be/aidslab/phylogeography/SPREAD.html","description":"analyze and visualize phylogeographic reconstructions","long_description":" SPREAD is a user-friendly application to analyze and visualize\n phylogeographic reconstructions resulting from Bayesian inference of\n spatio-temporal diffusion.\n .\n There is a tutorial for SPREAD online at\n http://www.kuleuven.be/aidslab/phylogeography/tutorial/spread_tutorial.html\n .\n Originally this program is named \"spread\".  However, there is just such a\n package inside Debian and thus a 'phy' for phylogeny was prepended.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 3 / 65","doi":"10.1093/bioinformatics/btr481","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_08645","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"squizz","distribution":"debian","release":"sid","component":"main","version":"0.99d","source":"squizz","homepage":"ftp://ftp.pasteur.fr/pub/gensoft/projects/squizz/","description":"Converter for genetic sequences and alignments","long_description":" Squizz is a sequence/alignment format checker, but it has some\n conversion capabilities too.\n Most common sequence and alignment formats are supported :\n  - EMBL, FASTA, GCG, GDE, GENBANK, IG, NBRF, PIR (codata), RAW, and\n   SWISSPROT.\n  - CLUSTAL, FASTA, MEGA, MSF, NEXUS, PHYLIP (interleaved and sequential) and\n   STOCKHOLM.\n","interface":["commandline"],"biology":null,"fields":["biology:bioinformatics"],"use":["converting"],"popcon":"9 / 3 / 87","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_28981","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"sra-agentkit","distribution":"debian","release":"sid","component":"main","version":"2.9.3","source":"sra-sdk","homepage":"https://github.com/ncbi/sra-agents/","description":"utilities for the NCBI Sequence Read Archive","long_description":" Agents for reading the SRA archive, generally by converting individual runs\n into some commonly used format such as fastq.\n .\n The textual dumpers \"sra-dump\" and \"vdb-dump\" are provided in this\n release as an aid in visual inspection. It is likely that their\n actual output formatting will be changed in the near future to a\n stricter, more formalized representation[s]. PLEASE DO NOT RELY UPON\n THE OUTPUT FORMAT SEEN IN THIS RELEASE.\n .\n The \"help\" information will be improved in near future releases, and\n the agent options will become standardized across the set. More documentation\n will also be provided documentation on the NCBI web site.\n .\n Agent options may change in the next release. Version 1 agent options\n will remain supported wherever possible in order to preserve\n operation of any existing scripts.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"15 / 7 / 121","doi":"10.1093/nar/gkp998","topics":null,"edam_scopes":null,"bio.agents":"SRA_agentkit","OMICagents":"OMICS_03771","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libsrf-dev","distribution":"debian","release":"sid","component":"main","version":"0.1","source":"srf","homepage":"http://srf.sourceforge.net/","description":"C++ implementation of the SRF format for DNA sequence data","long_description":" SRF (sort for Sequence Read Format) is a generic format capable of storing\n data generated by any DNA sequencing technology. This library is an\n implementation of SRF and provides basic input-output functions.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 0 / 36","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"srst2","distribution":"debian","release":"sid","component":"main","version":"0.2.0","source":"srst2","homepage":"https://katholt.github.io/srst2/","description":"Short Read Sequence Typing for Bacterial Pathogens","long_description":" This program is designed to take Illumina sequence data, a MLST database\n and/or a database of gene sequences (e.g. resistance genes, virulence\n genes, etc) and report the presence of STs and/or reference genes.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 2 / 51","doi":"10.1186/s13073-014-0090-6","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_12777","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"ssaha","distribution":"prospective","release":"vcs","component":"main","version":"3.1c","source":"ssaha","homepage":"ftp://ftp.sanger.ac.uk/pub4/resources/software/ssaha/","description":"Sequence Search and Alignment by Hashing Algorithm","long_description":" SSAHA is a software agent for very fast matching and alignment of DNA\n sequences. It achieves its fast search speed by converting sequence\n information into a `hash table' data structure, which can then be\n searched very rapidly for matches.\n .\n SSAHA is the only free software of its category (fast search of nearly\n indentical sequences). The popular alternative, BLAT, is restricted to\n non-commercial use.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"ssake","distribution":"debian","release":"sid","component":"main","version":"4.0","source":"ssake","homepage":"http://www.bcgsc.ca/platform/bioinfo/software/ssake","description":"genomics application for assembling millions of very short DNA sequences","long_description":" The Short Sequence Assembly by K-mer search and 3′ read Extension\n (SSAKE) is a genomics application for aggressively assembling\n millions of short nucleotide sequences by progressively searching for\n perfect 3′-most k-mers using a DNA prefix tree. SSAKE is designed to\n help leverage the information from short sequences reads by\n stringently clustering them into contigs that can be used to\n characterize novel sequencing targets.\n","interface":["shell"],"biology":["nuceleic-acids"],"fields":["biology"],"use":["analysing"],"popcon":"9 / 3 / 91","doi":"10.1093/bioinformatics/btl629","topics":["Sequence assembly"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Nucleic acid sequence", "formats": ["FASTQ"]}], "outputs": [{"data": "Sequence assembly", "formats": ["FASTA"]}], "function": ["Genome assembly"]}],"bio.agents":"ssake","OMICagents":"OMICS_00033","SEQwiki":{"source":"ssake","name":"SEQwiki","entry":"http://seqanswers.com/wiki/SSAKE"},"SciCrunch":{"source":"ssake","name":"SciCrunch","entry":"SCR_010753"},"RRID":null},{"package":"libssm-dev","distribution":"debian","release":"sid","component":"main","version":"1.4.0","source":"ssm","homepage":"http://www.ccp4.ac.uk/","description":"macromolecular superposition library - development files","long_description":" SSM is a macromolecular coordinate superposition library, written by\n Eugene Krissinel of the EBI.\n .\n The library implements the SSM algorithm of protein structure\n comparison in three dimensions, which includes an original procedure\n of matching graphs built on the protein's secondary-structure\n elements, followed by an iterative three-dimensional alignment of\n protein backbone Calpha atoms.\n .\n This package contains libraries and header files needed for program\n development.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 0 / 147","doi":"10.1107/S0907444904026460","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"sspace","distribution":"debian","release":"sid","component":"main","version":"2.1.1","source":"sspace","homepage":"https://github.com/nsoranzo/sspace_basic","description":"scaffolding pre-assembled contigs after extension","long_description":" SSAKE-based Scaffolding of Pre-Assembled Contigs after Extension (SSPACE)\n is a script able to extend and scaffold pre-assembled contigs using one or\n more mate pairs or paired-end libraries, or even a combination.\n .\n SSPACE is built based on SSAKE. Code of SSAKE is changed to be able to\n extend and scaffold pre-assembled contigs for multiple paired reads\n libraries.\n .\n This is the free 'basic' version of SSPACE. The non-free 'standard' version is\n available directly from Baseclear.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 4 / 54","doi":"10.1093/bioinformatics/btq683","topics":null,"edam_scopes":null,"bio.agents":"sspace","OMICagents":"OMICS_00050","SEQwiki":null,"SciCrunch":{"source":"sspace","name":"SciCrunch","entry":"SCR_005056"},"RRID":null},{"package":"stacks","distribution":"debian","release":"sid","component":"main","version":"2.2","source":"stacks","homepage":"http://creskolab.uoregon.edu/stacks/","description":"pipeline for building loci from short-read DNA sequences","long_description":" Stacks is a software pipeline for building loci from short-read sequences,\n such as those generated on the Illumina platform. Stacks was developed to work\n with restriction enzyme-based data, such as RAD-seq, for the purpose of\n building genetic maps and conducting population genomics and phylogeography.\n .\n Note that this package installs Stacks such that all commands must be run as:\n $ stacks <cmdname> <args>\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 2 / 60","doi":"10.1111/mec.12354","topics":null,"edam_scopes":null,"bio.agents":"Stacks","OMICagents":"OMICS_01567","SEQwiki":null,"SciCrunch":{"source":"stacks","name":"SciCrunch","entry":"SCR_003184"},"RRID":null},{"package":"staden","distribution":"debian","release":"sid","component":"main","version":"2.0.0+b11","source":"staden","homepage":"https://sourceforge.net/projects/staden/","description":"DNA sequence assembly (Gap4/Gap5), editing and analysis agents","long_description":" Staden is a fully developed set of DNA sequence assembly (Gap4 and\n Gap5), editing and analysis agents (Spin).\n .\n Gap4 performs sequence assembly, contig ordering based on read pair\n data, contig joining based on sequence comparisons, assembly checking,\n repeat searching, experiment suggestion, read pair analysis and contig\n editing. It has graphical views of contigs, templates, readings and\n traces which all scroll in register. Contig editor searches and\n experiment suggestion routines use confidence values to calculate the\n confidence of the consensus sequence and hence identify only places\n requiring visual trace inspection or extra data. The result is\n extremely rapid finishing and a consensus of known accuracy.\n .\n Pregap4 provides a graphical user interface to set up the processing\n required to prepare trace data for assembly or analysis, and automates\n these processes.\n .\n Trev is a rapid and flexible viewer and editor for ABI, ALF, SCF and\n ZTR trace files.\n .\n Prefinish analyses partially completed sequence assemblies and suggests\n the most efficient set of experiments to help finish the project.\n .\n Tracediff and hetscan automatically locate mutations by comparing trace\n data against reference traces. They annotate the mutations found ready\n for viewing in gap4.\n .\n Spin analyses nucleotide sequences to find genes, restriction sites,\n motifs, etc. It can perform translations, find open reading frames,\n count codons, etc. Many results are presented graphically and a sliding\n sequence window is linked to the graphics cursor. Spin also compares\n pairs of sequences in many ways. It has very rapid dot matrix analysis,\n global and local alignment algorithms, plus a sliding sequence window\n linked to the graphical plots. It can compare nucleic acid against\n nucleic acid, protein against protein, and protein against nucleic\n acid.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"10 / 6 / 108","doi":"10.1093/bioinformatics/btq268","topics":null,"edam_scopes":null,"bio.agents":"staden","OMICagents":"OMICS_00894","SEQwiki":null,"SciCrunch":{"source":"staden","name":"SciCrunch","entry":"SCR_005629"},"RRID":null},{"package":"libstaden-read-dev","distribution":"debian","release":"sid","component":"main","version":"1.14.11","source":"staden-io-lib","homepage":"https://github.com/jkbonfield/io_lib","description":"development files for libstaden-read","long_description":" This package contains the header and development files needed to build\n programs and packages using the Staden io_lib.\n .\n The io_lib from the Staden package is a library of file reading and writing\n code to provide a general purpose trace file (and Experiment File) reading\n interface. It has been compiled and tested on a variety of unix systems,\n MacOS X and MS Windows.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 2 / 38","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"staden-io-lib-utils","distribution":"debian","release":"sid","component":"main","version":"1.14.11","source":"staden-io-lib","homepage":"https://github.com/jkbonfield/io_lib","description":"programs for manipulating DNA sequencing files","long_description":" The io_lib from the Staden package is a library of file reading and writing\n code to provide a general purpose trace file (and Experiment File) reading\n interface. It has been compiled and tested on a variety of unix systems,\n MacOS X and MS Windows.\n .\n This package contains the programs that are distributed with the Staden io_lib\n for manipulating and converting sequencing data files, and in particular files\n to maniuplate short reads generated by second and third generation sequencers\n and stored in SRF format.\n","interface":["commandline"],"biology":["nuceleic-acids","peptidic"],"fields":["biology:bioinformatics","biology"],"use":["analysing"],"popcon":"11 / 6 / 135","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"strap","distribution":"prospective","release":"vcs","component":"main","version":"1.1.3","source":"strap","homepage":"http://3d-alignment.eu/","description":"Comfortable and intuitive protein alignment editor / viewer","long_description":" Strap is started from the menu \"Science\" in the \"Applications\" menu\n or with the shell command strap_protein_alignment.  Alignments can be\n manually edited or computed automatically using sequence and/or\n structure based methods.  Information can be attached to proteins and\n residue selections such as free text notes, balloon messages,\n cross-references as well as 3D and PDF display styles.  Alignments\n can be exported in several formats: Multiple-Fasta, ClustalW, MSF,\n HSSP, Jalview.  Decorated alignments with residue annotations and\n secondary structure cartoons can be exported to PDF, HTML and\n Word-processors to create figures in publication quality - see\n http://3d-alignment.eu/ for details. Strap is an integrated\n environment for Bioinformatics agents and resources like DAS sequence\n features, 3D-visualization, structure prediction and Blast search. It\n is scriptable and extendable and can be used by other programs to\n display sequence alignments and 3D-superpositions.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"strap-base","distribution":"prospective","release":"vcs","component":"main","version":"1.1.3","source":"strap-base","homepage":"http://www.bioinformatics.org/strap/","description":"essential files for the interactive alignment viewer and editor Strap","long_description":" Most users should install the package strap which in addition\n installs required Debian packages for alignment computation and 3D\n visualization. Strap-base provides utilities for protein and\n alignment file format conversion: strap_to_clustal, strap_to_msf,\n strap_to_fasta, strap_to_multiple_fasta.  It also provides\n interactive alignment visualization and HTML export for other\n bioinformatics software.  The command strap_base with the option\n  -script=file or -script=named_pipe opens a new interactive alignment\n view. Named pipes are the basis for interprocess communication. The\n command strap_to_html is a command line agent to produce\n decorated and annotated alignments suitable for web-browsers with\n script commands as explained in\n http://www.bioinformatics.org/strap/alignment-to-html.html.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"subread","distribution":"debian","release":"sid","component":"main","version":"1.6.3","source":"subread","homepage":"http://sourceforge.net/projects/subread/","description":"agentkit for processing next-gen sequencing data","long_description":" Subread aligner can be used to align both gDNA-seq and RNA-seq reads.\n Subjunc aligner was specified designed for the detection of exon-exon\n junction. For the mapping of RNA-seq reads, Subread performs local\n alignments and Subjunc performs global alignments.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 15 / 78","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"subread","OMICagents":"OMICS_01255","SEQwiki":null,"SciCrunch":{"source":"subread","name":"SciCrunch","entry":"SCR_009803"},"RRID":null},{"package":"suitename","distribution":"debian","release":"sid","component":"main","version":"0.3.070628","source":"suitename","homepage":"http://kinemage.biochem.duke.edu/software/suitename.php","description":"categorize each suite in an RNA backbone","long_description":" Suitename is a program that supports the ROC RNA Ontology Consortium\n consensus RNA backbone nomenclature and conformer-list development.\n .\n From dihedral-angle input for a specific RNA structure (usually from\n Dangle), Suitename categorizes the RNA backbone geometry of each suite\n (the sugar-to-sugar version of a residue) either as an outlier or\n as belonging to one of the 53 defined conformer bins. The output is\n either a one-line-per-suite report, or a linear conformer string (as\n shown below the image here) in one of several variant formats. Suitename\n is built into MolProbity, producing entries in the multi-criterion chart\n for an RNA model and also a suitestring file.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 3 / 60","doi":"10.1261/rna.657708","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_21294","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"sumaclust","distribution":"debian","release":"sid","component":"main","version":"1.0.31","source":"sumaclust","homepage":"http://metabarcoding.org/sumaclust","description":"fast and exact clustering of genomic sequences","long_description":" With the development of next-generation sequencing, efficient agents are\n needed to handle millions of sequences in reasonable amounts of time.\n Sumaclust is a program developed by the LECA. Sumaclust aims to cluster\n sequences in a way that is fast and exact at the same time. This agent\n has been developed to be adapted to the type of data generated by DNA\n metabarcoding, i.e. entirely sequenced, short markers. Sumaclust\n clusters sequences using the same clustering algorithm as UCLUST and CD-\n HIT. This algorithm is mainly useful to detect the 'erroneous' sequences\n created during amplification and sequencing protocols, deriving from\n 'true' sequences.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 3 / 61","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_19112","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"sumatra","distribution":"debian","release":"sid","component":"main","version":"1.0.31","source":"sumatra","homepage":"http://metabarcoding.org/sumatra","description":"fast and exact comparison and clustering of sequences","long_description":" With the development of next-generation sequencing, efficient agents are\n needed to handle millions of sequences in reasonable amounts of time.\n Sumatra is a program developed by the LECA. Sumatra aims to compare\n sequences in a way that is fast and exact at the same time. This agent\n has been developed to be adapted to the type of data generated by DNA\n metabarcoding, i.e. entirely sequenced, short markers. Sumatra computes\n the pairwise alignment scores from one dataset or between two datasets,\n with the possibility to specify a similarity threshold under which pairs\n of sequences that have a lower similarity are not reported. The output\n can then go through a classification process with programs such as MCL\n or MOTHUR.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 3 / 79","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"krona","OMICagents":"OMICS_01498","SEQwiki":null,"SciCrunch":{"source":"sumatra","name":"SciCrunch","entry":"SCR_012785"},"RRID":null},{"package":"surankco","distribution":"debian","release":"sid","component":"main","version":"0.0.r5","source":"surankco","homepage":"https://sourceforge.net/projects/surankco/","description":"Supervised Ranking of Contigs in de novo Assemblies","long_description":" SuRankCo is a machine learning based software to score and rank\n contigs from de novo assemblies of next generation sequencing data. It\n trains with alignments of contigs with known reference genomes and\n predicts scores and ranking for contigs which have no related\n reference genome yet.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 3 / 53","doi":"10.1186/s12859-015-0644-7","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_09480","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"swarm","distribution":"debian","release":"sid","component":"main","version":"2.2.2","source":"swarm-cluster","homepage":"https://github.com/torognes/swarm","description":"robust and fast clustering method for amplicon-based studies","long_description":" The purpose of swarm is to provide a novel clustering algorithm to handle large\n sets of amplicons. Traditional clustering algorithms results are strongly\n input-order dependent, and rely on an arbitrary global clustering threshold.\n swarm results are resilient to input-order changes and rely on a small local\n linking threshold d, the maximum number of differences between two amplicons.\n swarm forms stable high-resolution clusters, with a high yield of biological\n information.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 3 / 105","doi":"https://doi.org/10.7717/peerj.1420","topics":null,"edam_scopes":null,"bio.agents":"swarm","OMICagents":"OMICS_14578","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"sweed","distribution":"debian","release":"sid","component":"main","version":"3.2.1","source":"sweed","homepage":"https://sco.h-its.org/exelixis/web/software/sweed/","description":"assessment of SNPs for their evolutionary advantage","long_description":" Biological sequences are available in ever increasing abundance across\n ever larger populations for ever increasing fractions of the genome. This\n agent sorts the SNPs for their active or passive contribution to a genetic\n drift, i.e. to see particular sequences at a higher fraction over time.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 7 / 14","doi":"10.1093/molbev/mst112","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_08598","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"libswiss-perl","distribution":"debian","release":"sid","component":"main","version":"1.75","source":"swissknife","homepage":"http://swissknife.sourceforge.net","description":"Perl API to the UniProt database","long_description":" UniProt, SwissProt and TrEMBL are different views on protein sequence\n data that is prepared by groups at the European Bioinformatics Institute\n (EMBL-EBI) in Cambridge and the Swiss Bioinformatics Institute (SIB) at\n the University Hospital in Geneva.\n .\n The SwissKnife Perl library is used by the developers of these databases\n to perform all the automated editing and sytax checks. The users of\n this package will profit from the stable API on an ever evolving\n representation of biological knowledge.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 37","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"tab2mage","distribution":"prospective","release":"vcs","component":"main","version":"20080626","source":"tab2mage","homepage":"http://tab2mage.sourceforge.net/","description":"submitting large microarray experiment datasets to public repository database","long_description":" Tab2MAGE is a software package written and supported by the ArrayExpress\n curation team, which aims to ease the process of submitting large\n microarray experiment datasets to our public repository database. To\n this end, Tab2MAGE currently includes two agents, the tab2mage.pl script\n itself, and a data file checking script, expt_check.pl. With these\n scripts it is possible to perform an initial data file validation\n against an array design (e.g., in the form of an \"Array Description\n File\" or ADF), and then to generate MAGE-ML using these data files\n alongside a separate spreadsheet providing MIAME-compliant sample\n annotation.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"tacg","distribution":"prospective","release":"vcs","component":"main","version":"4.1","source":"tacg","homepage":"http://tacg.sourceforge.net/","description":"command line program for finding patterns in nucleic acids","long_description":" tacg is a character-based, command line agent for unix-like operating systems\n for pattern-matching in nucleic acids and performing some of the basic protein\n manipulations. It was originally designed for restriction enzyme analysis of\n DNA, but has been extended to other types of matching. It now handles\n degenerate sequence input in a variety of matching approaches, as well as\n patterns with errors, regular expressions and TRANSFAC-formatted matrices.\n .\n It was designed to be a grep for DNA and like the original grep, its\n capabilities have grown so that now the author has to keep calling up the help\n page to figure out which flags (now ~50) mean what. tacg is NOT a GUI\n application in any sense. However, it's existance as a strictly command-line\n agent lends itself well to Webification and wrapping by various GUI agents and\n it is now distributed with a web interface form and a Perl CGI handler.\n Additionally, it can easily be integrated into editors that support shell\n commands such as nedit.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1186/1471-2105-3-8","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"tantan","distribution":"debian","release":"sid","component":"main","version":"22","source":"tantan","homepage":"http://www.cbrc.jp/tantan/","description":"low complexity and tandem repeat masker for biosequences","long_description":" tantan is a agent to mask simple regions (low complexity and short-period tandem\n repeats) in DNA, RNA, and protein sequences. The aim of tantan is to prevent\n false predictions when searching for homologous regions between two sequences.\n Simple repeats often align strongly to each other, causing false homology\n predictions.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 4 / 61","doi":"10.1093/nar/gkq1212","topics":["Sequence composition, complexity and repeats"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Sequence", "formats": ["FASTA"]}], "outputs": [{"data": "Sequence", "formats": ["FASTA"]}], "function": ["Sequence masking"]}],"bio.agents":null,"OMICagents":"OMICS_15197","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"t-coffee","distribution":"debian","release":"sid","component":"main","version":"12.00.7fb08c2","source":"t-coffee","homepage":"http://www.tcoffee.org/Projects_home_page/t_coffee_home_page.html","description":"Multiple Sequence Alignment","long_description":" T-Coffee is a multiple sequence alignment package. Given a set of\n sequences (Proteins or DNA), T-Coffee generates a multiple sequence\n alignment. Version 2.00 and higher can mix sequences and structures.\n .\n T-Coffee allows the combination of a collection of multiple/pairwise,\n global or local alignments into a single model. It can also\n estimate the level of consistency of each position within the new\n alignment with the rest of the alignments. See the pre-print for more\n information\n .\n T-Coffee has a special called M-Coffee that makes it possible to combine the\n output of many multiple sequence alignment packages. In its published version,\n it uses MUSCLE, PROBCONS, POA, DiAlign-TS, MAFFT, Clustal W, PCMA and\n T-Coffee.  A special version has been made for Debian, DM-Coffee, that uses\n only free software by replacing Clustal W by Kalign. Using the 8 Methods of\n M-Coffee can sometimes be a bit heavy. You can use a subset of your favorite\n methods if you prefer.\n","interface":["commandline"],"biology":null,"fields":["biology","biology:bioinformatics"],"use":["analysing","comparing"],"popcon":"20 / 66 / 925","doi":"10.1006/jmbi.2000.4042","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_00989","SEQwiki":null,"SciCrunch":{"source":"t-coffee","name":"SciCrunch","entry":"SCR_011818"},"RRID":null},{"package":"theseus","distribution":"debian","release":"sid","component":"main","version":"3.3.0","source":"theseus","homepage":"http://www.theseus3d.org","description":"superimpose macromolecules using maximum likelihood","long_description":" Theseus is a program that simultaneously superimposes multiple\n macromolecular structures. Theseus finds the optimal solution to the\n superposition problem using the method of maximum likelihood. By\n down-weighting variable regions of the superposition and by correcting for\n correlations among atoms, the ML superposition method produces very\n accurate structural alignments.\n .\n When macromolecules with different residue sequences are superimposed,\n other programs and algorithms discard residues that are aligned with\n gaps. Theseus, however, uses a novel superimposition algorithm that\n includes all of the data.\n","interface":["commandline"],"biology":["peptidic"],"fields":["biology:structural","biology","biology:bioinformatics"],"use":["analysing","comparing"],"popcon":"7 / 3 / 84","doi":"10.1093/bioinformatics/btl332","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"Theseus","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"tide","distribution":"prospective","release":"vcs","component":"main","version":"0.0.r15918","source":"tide","homepage":"http://cruxagentkit.sourceforge.net/","description":"SEQUEST Searching for Peptide Identification from Tandem Mass Spectra","long_description":" Tide implements the SEQUEST algorithm for peptide identification and\n that achieves a dramatic speedup over Crux and SEQUEST. The\n optimization strategies detailed here employ a combination of\n algorithmic and software engineering techniques to achieve speeds up to\n 170 times faster than a recent version of SEQUEST that uses indexing.\n For example, on a single Xeon CPU, Tide searches 10,000 spectra against\n a tryptic database of 27,499\n C.\\ elegans proteins at a rate of 1,550 spectra per second, which\n compares favorably with a rate of 8.8 spectra per second for a recent\n version of SEQUEST with index running on the same hardware.","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 0 / 1","doi":"10.1021/pr101196n","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"tigr-glimmer","distribution":"debian","release":"sid","component":"main","version":"3.02b","source":"tigr-glimmer","homepage":"http://ccb.jhu.edu/software/glimmer/index.shtml","description":"Gene detection in archea and bacteria","long_description":" Developed by the TIGR institute this software detects coding sequences in\n bacteria and archea.\n .\n Glimmer is a system for finding genes in microbial DNA, especially the\n genomes of bacteria and archaea. Glimmer (Gene Locator and Interpolated\n Markov Modeler) uses interpolated Markov models (IMMs) to identify the\n coding regions and distinguish them from noncoding DNA.\n","interface":["commandline"],"biology":null,"fields":["biology","biology:bioinformatics"],"use":["searching"],"popcon":"20 / 5 / 348","doi":"10.1093/nar/26.2.544","topics":null,"edam_scopes":null,"bio.agents":"glimmer","OMICagents":"OMICS_01486","SEQwiki":null,"SciCrunch":{"source":"tigr-glimmer","name":"SciCrunch","entry":"SCR_011931"},"RRID":null},{"package":"tigr-glimmer-mg","distribution":"prospective","release":"vcs","component":"main","version":"0.3.2","source":"tigr-glimmer-mg","homepage":"http://www.cbcb.umd.edu/software/glimmer-mg/","description":"finding genes in environmental shotgun DNA sequences","long_description":" Glimmer-MG is a system for finding genes in environmental shotgun DNA\n sequences. Glimmer-MG (Gene Locator and Interpolated Markov ModelER -\n MetaGenomics) uses interpolated Markov models (IMMs) to identify the\n coding regions and distinguish them from noncoding DNA.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1093/nar/gkr1067","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"tm-align","distribution":"debian","release":"sid","component":"main","version":"20170708","source":"tm-align","homepage":"http://zhanglab.ccmb.med.umich.edu/TM-align/","description":"structural alignment of proteins","long_description":" TM-align is a computer algorithm for protein structure alignment using\n dynamic programming. The scoring is performed by the TM-score rotation\n matrix. This is similar to the RMSD in that unaligned portions of the\n structure influence the scoring less than the more structurally conserved\n regions.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"18 / 6 / 363","doi":"10.1093/nar/gki524","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_03646","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"tn-seqexplorer","distribution":"prospective","release":"vcs","component":"main","version":"1.5","source":"tn-seqexplorer","homepage":"https://github.com/sina-cb/Tn-seqExplorer","description":"explore and analyze Tn-seq data for prokaryotic genomes","long_description":" Tn-seq Explorer allows users to explore and analyze Tn-seq data for\n prokaryotic (bacterial or archaeal) genomes. It implements two\n alternative methods for identification of essential genes and provides\n additional agents to investigate the Tn-seq data. The primary goal of the\n data analysis is to study fitness by identifying genes that are essentia","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 1","doi":"10.1371/journal.pone.0126070","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"tnseq-transit","distribution":"debian","release":"sid","component":"main","version":"2.3.4","source":"tnseq-transit","homepage":"http://saclab.tamu.edu/essentiality/transit/","description":"statistical calculations of essentiality of genes or genomic regions","long_description":" This is a software that can be used to analyze Tn-Seq datasets. It\n includes various statistical calculations of essentiality of genes or\n genomic regions (including conditional essentiality between 2\n conditions). These methods were developed and tested as a collaboration\n between the Sassetti lab (UMass) and the Ioerger lab (Texas A&M)\n .\n TRANSIT is capable of analyzing TnSeq libraries constructed with Himar1\n or Tn5 datasets.\n .\n TRANSIT assumes you have already done pre-processing of raw sequencing\n files (.fastq) and extracted read counts into a .wig formatted file.\n The .wig file should contain the counts at all sites where an insertion\n could take place (including sites with no reads). For Himar1 datasets\n this is all TA sites in the genome. For Tn5 datasets this would be all\n nucleotides in the genome.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"3 / 6 / 18","doi":"10.1371/journal.pcbi.1004401","topics":null,"edam_scopes":null,"bio.agents":"TRANSIT","OMICagents":"OMICS_10215","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"toil","distribution":"debian","release":"sid","component":"main","version":"3.18.0","source":"toil","homepage":"https://github.com/BD2KGenomics/toil","description":"cross-platform workflow engine","long_description":" Toil is a scalable, efficient, cross-platform and easy-to-use workflow\n engine in pure Python.  It works with several well established load\n balancers like Slurm or the Sun Grid Engine.  Toil is also compatible with\n the Common Workflow Language (CWL) via the \"toil-cwl-runner\" interface, which\n this package make available via the Debian alternativess system under the\n alias \"cwl-runner\".\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"4 / 12 / 20","doi":"10.1038/nbt.3772","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_25666","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"tophat","distribution":"debian","release":"sid","component":"main","version":"2.1.1","source":"tophat","homepage":"http://ccb.jhu.edu/software/tophat","description":"fast splice junction mapper for RNA-Seq reads","long_description":" TopHat aligns RNA-Seq reads to mammalian-sized genomes using the ultra\n high-throughput short read aligner Bowtie, and then analyzes the\n mapping results to identify splice junctions between exons.\n TopHat is a collaborative effort between the University of Maryland\n Center for Bioinformatics and Computational Biology and the\n University of California, Berkeley Departments of Mathematics and\n Molecular and Cell Biology.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"15 / 2 / 164","doi":"10.1093/bioinformatics/btp120","topics":null,"edam_scopes":null,"bio.agents":"tophat","OMICagents":"OMICS_01257","SEQwiki":null,"SciCrunch":{"source":"tophat","name":"SciCrunch","entry":"SCR_013035"},"RRID":null},{"package":"toppred","distribution":"debian","release":"sid","component":"main","version":"1.10","source":"toppred","homepage":"https://github.com/bioinfo-center-pasteur-fr/toppred","description":"transmembrane topology prediction","long_description":" Toppred is a program to determine the topology of a transmembrane\n protein based on G. von Heijne algorithm.\n .\n Each sequence from seq data in fasta format is processed, and toppred\n generate the Hydrophobycity profile of the sequence, and the\n corresponding hydrophobycities values in the file sequence-ID.hydro.\n .\n Furthermore, the predicted topologies are represented as png images.\n Each topology is stored in file sequence-ID-number.png\n .\n The hydrophobicity profile is computed using a window formed by a core\n rectangular window of size n, flanked by 2 triangular windows of size q.\n NB rectangular and triangular mean that the ponderation values inside\n those windows are respectively constant and variable.\n .\n This program is a new implementation of the original toppred program,\n based on G. von Heijne algorithm\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 3 / 65","doi":"10.1016/0022-2836(92)90934-C","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_07268","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"trace2dbest","distribution":"debian","release":"sid","component":"main","version":"3.0.1","source":"trace2dbest","homepage":"http://www.nematodes.org/bioinformatics/trace2dbEST/","description":"bulk submission of chromatogram data to dbEST","long_description":" ESTs are short sequences derived from reverse-transcribed RNA.\n Their abundances yield insights in the expression of genes across\n tissues, support the discovery of new genes and allow one to assess\n the coverage of whole genome sequencing projects. Public databases\n like dbEST at the NCBI collect this data.\n .\n trace2dbEST process raw sequenceing chromatograph trace files from\n EST projects into quality-checked sequences, ready for submission to\n dbEST. trace2dbEST guides you through the creation of all the necessary\n files for submission of ESTs to dbEST. trace2dbest makes use of other\n software (available free under academic licence) that you will need to\n have installed, namely phred, cross_match and (optionally) BLAST.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 7 / 13","doi":"10.1093/bioinformatics/bth101","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"tracetuner","distribution":"debian","release":"sid","component":"main","version":"3.0.6~beta","source":"tracetuner","homepage":"https://sourceforge.net/projects/tracetuner/","description":"interpretation of DNA Sanger sequencing data","long_description":" Tracetuner is a agent for base and quality calling of trace files from\n DNA sequencing instruments.\n Traditional DNA sequencing yields curves from four different\n channels or light frequencies that human or (preferably) machines\n are interpreting to determine the actual base (A,C,G or T) and\n the confidence with which this is determined.\n .\n TraceTuner is a DNA sequencing quality value, base calling and trace\n processing software application originally developed by Paracel,\n Inc. While providing a flexible interface and capability to adopt\n the \"pure\" base calls produced by Phred, KB or any other \"original\"\n caller, it offers competitive features not currently available in other\n agents, such as customized calibration of quality values, advanced\n heterozygote and mixed base calling and deconvolving the \"mixed\"\n electropherograms resulting from the presence of indels into a couple of\n \"pure\" electropherograms.\n .\n Later versions\n Previous versions of TraceTuner were used by\n Celera Genomics to process over 27 million reads from both Drosophila\n and human genome projects.\n In 2000, Applied Biosystems\n bundled TraceTuner with ABI3700 Genome Analyzers and shipped it to the\n customers of these capillary electrophoresis sequencers.\n its SNP detection and genotyping software product SeqScape.\n .\n TraceTuner\n implements an advanced peak processing technology for resolving\n overlapping peaks of the same dye color into individual, or \"intrinsic\"\n peaks.\n TraceTuner, for its support of mixed base calling, have been used by the\n research community, the private biotech sector, and the U.S. government\n as components of different variant detection, genotyping and forensic\n software applications (e.g. Applied Biosystems SeqScape, Paracel Genome\n Assembler, MTexpert, etc.).\n .\n This technology was protected by US Patent #6,681,186. Currently,\n TraceTuner is an open source software, which has been used by J. Craig\n Venter Institute's DNA Sequencing and Resequencing pipelines.\n .\n This package prepares an important piece of human history to be used\n with new data on new machines or to revisit older observations..\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 7 / 13","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_01158","SEQwiki":null,"SciCrunch":{"source":"tracetuner","name":"SciCrunch","entry":"SCR_013019"},"RRID":null},{"package":"transdecoder","distribution":"debian","release":"sid","component":"main","version":"5.0.1","source":"transdecoder","homepage":"https://transdecoder.github.io/","description":"find coding regions within RNA transcript sequences","long_description":" TransDecoder identifies candidate coding regions within transcript sequences,\n such as those generated by de novo RNA-Seq transcript assembly using Trinity,\n or constructed based on RNA-Seq alignments to the genome using Tophat and\n Cufflinks.\n .\n TransDecoder identifies likely coding sequences based on the following\n criteria:\n  * a minimum length open reading frame (ORF) is found in a transcript sequence\n  * a log-likelihood score similar to what is computed by the GeneID software\n    is > 0.\n  * the above coding score is greatest when the ORF is scored in the 1st\n    reading frame as compared to scores in the other 5 reading frames.\n  * if a candidate ORF is found fully encapsulated by the coordinates of\n    another candidate ORF, the longer one is reported. However, a single\n    transcript can report multiple ORFs (allowing for operons, chimeras, etc).\n  * optional the putative peptide has a match to a Pfam domain above the noise\n    cutoff score.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"8 / 4 / 78","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_10852","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"transrate-agents","distribution":"debian","release":"sid","component":"main","version":"1.0.0","source":"transrate-agents","homepage":"http://hibberdlab.com/transrate/","description":"helper for transrate","long_description":" Transrate is a library and command-line agent for quality assessment of de-novo\n transcriptome assemblies.\n .\n This package provides command line agents used by transrate to process BAM\n files.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 3 / 61","doi":"10.1101/gr.196469.115","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_09086","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"transtermhp","distribution":"debian","release":"sid","component":"main","version":"2.09","source":"transtermhp","homepage":"http://transterm.cbcb.umd.edu/","description":"find rho-independent transcription terminators in bacterial genomes","long_description":" TransTermHP finds rho-independent transcription terminators in\n bacterial genomes. Each terminator found by the program is assigned a\n confidence value that estimates its probability of being a true\n terminator. TransTermHP is the successor of TransTerm which was using\n very different search and scoring algorithms.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 4 / 82","doi":"10.1186/gb-2007-8-2-r22","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_06165","SEQwiki":null,"SciCrunch":{"source":"transtermhp","name":"SciCrunch","entry":"SCR_008244"},"RRID":null},{"package":"tree-ppuzzle","distribution":"debian","release":"sid","component":"main","version":"5.2","source":"tree-puzzle","homepage":"http://www.tree-puzzle.de","description":"Parallelized reconstruction of phylogenetic trees by maximum likelihood","long_description":" TREE-PUZZLE (the new name for PUZZLE) is an interactive console program that\n implements a fast tree search algorithm, quartet puzzling, that allows\n analysis of large data sets and automatically assigns estimations of support\n to each internal branch. TREE-PUZZLE also computes pairwise maximum\n likelihood distances as well as branch lengths for user specified trees.\n Branch lengths can also be calculated under the clock-assumption. In\n addition, TREE-PUZZLE offers a novel method, likelihood mapping, to\n investigate the support of a hypothesized internal branch without\n computing an overall tree and to visualize the phylogenetic content of\n a sequence alignment.\n .\n This is the parallelized version of tree-puzzle.\n","interface":["commandline"],"biology":null,"fields":["biology","biology:bioinformatics"],"use":["analysing","comparing"],"popcon":"0 / 0 / 8","doi":"10.1093/bioinformatics/18.3.502","topics":null,"edam_scopes":null,"bio.agents":"TREE-PUZZLE","OMICagents":"OMICS_18458","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"tree-puzzle","distribution":"debian","release":"sid","component":"main","version":"5.2","source":"tree-puzzle","homepage":"http://www.tree-puzzle.de","description":"Reconstruction of phylogenetic trees by maximum likelihood","long_description":" TREE-PUZZLE (the new name for PUZZLE) is an interactive console program that\n implements a fast tree search algorithm, quartet puzzling, that allows\n analysis of large data sets and automatically assigns estimations of support\n to each internal branch. TREE-PUZZLE also computes pairwise maximum\n likelihood distances as well as branch lengths for user specified trees.\n Branch lengths can also be calculated under the clock-assumption. In\n addition, TREE-PUZZLE offers a novel method, likelihood mapping, to\n investigate the support of a hypothesized internal branch without\n computing an overall tree and to visualize the phylogenetic content of\n a sequence alignment.\n","interface":["commandline"],"biology":null,"fields":["biology:bioinformatics","biology"],"use":["analysing","comparing"],"popcon":"11 / 3 / 112","doi":"10.1093/bioinformatics/18.3.502","topics":null,"edam_scopes":null,"bio.agents":"TREE-PUZZLE","OMICagents":"OMICS_18458","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"treeview","distribution":"debian","release":"sid","component":"main","version":"1.1.6.4","source":"treeview","homepage":"http://jtreeview.sourceforge.net","description":"Java re-implementation of Michael Eisen's TreeView","long_description":" TreeView creates a matrix-like display of expression data, known as\n Eisen clustering. The original implementation was a Windows program\n named TreeView by Michael Eisen. This TreeView package, sometimes also\n referred to as jTreeView, was rewritten in Java under a free license.\n .\n Java TreeView is an extensible viewer for microarray data in\n PCL or CDT format.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 11 / 75","doi":"10.1093/bioinformatics/bth349","topics":null,"edam_scopes":null,"bio.agents":"Java_Treeview","OMICagents":"OMICS_01574","SEQwiki":null,"SciCrunch":{"source":"treeview","name":"SciCrunch","entry":"SCR_013503"},"RRID":null},{"package":"treeviewx","distribution":"debian","release":"sid","component":"main","version":"0.5.1+git20100823.7e4d0e9","source":"treeviewx","homepage":"https://github.com/rdmpage/treeviewx","description":"Displays and prints phylogenetic trees","long_description":" TreeView X is an open source and multi-platform program to display\n phylogenetic trees. It can read and display NEXUS and Newick format tree files\n (such as those output by PAUP*, ClustalX, TREE-PUZZLE, and other programs). It\n allows one to order the branches of the trees, and to export the trees in SVG\n format.\n","interface":["x11"],"biology":null,"fields":["biology","biology:bioinformatics"],"use":["viewing"],"popcon":"11 / 5 / 147","doi":"10.1093/bioinformatics/12.4.357","topics":null,"edam_scopes":null,"bio.agents":"TreeView","OMICagents":"OMICS_13038","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"trimmomatic","distribution":"debian","release":"sid","component":"main","version":"0.38","source":"trimmomatic","homepage":"http://www.usadellab.org/cms/index.php?page=trimmomatic","description":"flexible read trimming agent for Illumina NGS data","long_description":" Trimmomatic performs a variety of useful trimming tasks for illumina\n paired-end and single ended data.The selection of trimming steps and\n their associated parameters are supplied on the command line.\n .\n The current trimming steps are:\n  * ILLUMINACLIP: Cut adapter and other illumina-specific sequences from\n    the read.\n  * SLIDINGWINDOW: Perform a sliding window trimming, cutting once thes\n    average quality within the window falls below a threshold.\n  * LEADING: Cut bases off the start of a read, if below a threshold quality\n  * TRAILING: Cut bases off the end of a read, if below a threshold quality\n  * CROP: Cut the read to a specified length\n  * HEADCROP: Cut the specified number of bases from the start of the read\n  * MINLENGTH: Drop the read if it is below a specified length\n  * TOPHRED33: Convert quality scores to Phred-33\n  * TOPHRED64: Convert quality scores to Phred-64\n It works with FASTQ (using phred + 33 or phred + 64 quality scores,\n depending on the Illumina pipeline used), either uncompressed or\n gzipp'ed FASTQ. Use of gzip format is determined based on the .gz\n extension.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"9 / 7 / 107","doi":"10.1093/bioinformatics/btu170","topics":["Sequencing"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Sequence", "formats": ["FASTQ"]}], "outputs": [{"data": "Sequence", "formats": ["FASTQ"]}, {"data": "Report", "formats": ["Text"]}], "function": ["Sequence trimmimg", "Sequencing quality control"]}],"bio.agents":"Trimmomatic","OMICagents":"OMICS_01097","SEQwiki":null,"SciCrunch":{"source":"trimmomatic","name":"SciCrunch","entry":"SCR_011848"},"RRID":null},{"package":"trinityrnaseq","distribution":"debian","release":"sid","component":"main","version":"2.6.6","source":"trinityrnaseq","homepage":"http://trinityrnaseq.github.io/","description":"RNA-Seq De novo Assembly","long_description":" Trinity represents a novel method for the efficient and robust de novo\n reconstruction of transcriptomes from RNA-seq data. Trinity combines three\n independent software modules: Inchworm, Chrysalis, and Butterfly, applied\n sequentially to process large volumes of RNA-seq reads. Trinity partitions\n the sequence data into many individual de Bruijn graphs, each representing the\n transcriptional complexity at a given gene or locus, and then processes\n each graph independently to extract full-length splicing isoforms and to tease\n apart transcripts derived from paralogous genes.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 5 / 48","doi":"10.1038/nbt.1883","topics":null,"edam_scopes":null,"bio.agents":"trinity","OMICagents":"OMICS_01327","SEQwiki":{"source":"trinityrnaseq","name":"SEQwiki","entry":"http://seqanswers.com/wiki/Trinity"},"SciCrunch":{"source":"trinityrnaseq","name":"SciCrunch","entry":"SCR_013048"},"RRID":null},{"package":"trnascan-se","distribution":"debian","release":"sid","component":"non-free","version":"2.0.0","source":"trnascan-se","homepage":"http://lowelab.ucsc.edu/tRNAscan-SE","description":"detection of transfer RNA genes in genomic sequence","long_description":" tRNAscan-SE identifies 99-100% of transfer RNA genes in DNA sequence while\n giving less than one false positive per 15 gigabases. Two previously described\n tRNA detection programs are used as fast, first-pass prefilters to identify\n candidate tRNAs, which are then analyzed by a highly selective tRNA covariance\n model. This work represents a practical application of RNA covariance models,\n which are general, probabilistic secondary structure profiles based on\n stochastic context-free grammars. tRNAscan-SE searches at ~ 30 000 bp/s.\n Additional extensions to tRNAscan-SE detect unusual tRNA homologues such as\n selenocysteine tRNAs, tRNA-derived repetitive elements and tRNA pseudogenes.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1093/nar/25.5.0955","topics":null,"edam_scopes":null,"bio.agents":"trnascan-se","OMICagents":"OMICS_00385","SEQwiki":null,"SciCrunch":{"source":"trnascan-se","name":"SciCrunch","entry":"SCR_010835"},"RRID":null},{"package":"tvc","distribution":"debian","release":"sid","component":"main","version":"5.0.3+git20151221.80e144e","source":"tvc","homepage":"http://ioncommunity.thermofisher.com","description":"genetic variant caller for Ion Torrent sequencing platforms","long_description":" Torrent Variant Caller (TVC) is a genetic variant caller for\n Ion Torrent sequencing platforms, and is specially optimized to exploit the\n underlying flow signal information in the statistical model\n to evaluate variants. Torrent Variant Caller is designed to call\n single-nucleotide polymorphisms (SNPs), multi-nucleotide polymorphisms (MNPs),\n insertions, deletions, and block substitutions.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 7 / 12","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_29293","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"uc-echo","distribution":"debian","release":"sid","component":"main","version":"1.12","source":"uc-echo","homepage":"http://uc-echo.sourceforge.net/","description":"error correction algorithm designed for short-reads from NGS","long_description":" ECHO is an error correction algorithm designed for short-reads\n from next-generation sequencing platforms such as Illumina's\n Genome Analyzer II. The algorithm uses a Bayesian framework to\n improve the quality of the reads in a given data set by employing\n maximum a posteriori estimation.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 2 / 102","doi":"10.1101/gr.111351.110","topics":["Data management","Sequencing"],"edam_scopes":[{"name": "summary", "inputs": [{"data": "Sequence", "formats": ["Text", "FASTQ"]}], "outputs": [{"data": "Sequence", "formats": ["FASTQ"]}], "function": ["Sequencing quality control"]}],"bio.agents":"echo","OMICagents":"OMICS_01102","SEQwiki":null,"SciCrunch":{"source":"uc-echo","name":"SciCrunch","entry":"SCR_011851"},"RRID":null},{"package":"ugene","distribution":"debian","release":"sid","component":"non-free","version":"1.31.1","source":"ugene","homepage":"http://ugene.unipro.ru","description":"integrated bioinformatics agentkit","long_description":" Unipro UGENE is a cross-platform visual environment for DNA and protein\n sequence analysis. UGENE integrates the most important bioinformatics\n computational algorithms and provides an easy-to-use GUI for performing\n complex analysis of the genomic data. One of the main features of UGENE\n is a designer for custom bioinformatics workflows.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 2 / 15","doi":"10.1093/bioinformatics/bts091","topics":null,"edam_scopes":null,"bio.agents":"ugene","OMICagents":"OMICS_01022","SEQwiki":null,"SciCrunch":{"source":"ugene","name":"SciCrunch","entry":"SCR_005579"},"RRID":null},{"package":"umap","distribution":"prospective","release":"vcs","component":"main","version":"1.0.0","source":"umap","homepage":"https://bitbucket.org/hoffmanlab/umap","description":"quantify genome and methylome mappability","long_description":" Umap identifies uniquely mappable regions of any genome. Its Bismap\n extension identifies mappability of the bisulfite converted\n genome (methylome).","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1093/nar/gky677","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_31078","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"unanimity","distribution":"debian","release":"sid","component":"main","version":"3.3.0","source":"unanimity","homepage":"https://github.com/PacificBiosciences/unanimity","description":"generate and process accurate consensus nucleotide sequences","long_description":" Unanimity provides a set of agents for consensus sequences from Pacific\n Biosciences sequencing data:\n  * Circular Consensus Calling\n    ccs takes multiple reads of the same SMRTbell sequence and combines them,\n    employing a statistical model, to produce one high quality consensus\n    sequence.\n  * Minor variant caller\n    juliet identifies minor variants from aligned ccs reads.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 8 / 8","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_26281","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"unc-fish","distribution":"prospective","release":"vcs","component":"main","version":"1.0","source":"unc-fish","homepage":"http://labs.bio.unc.edu/Vision/FISH/","description":"Fast Identification of Segmental Homology","long_description":" FISH is software for identifying regions of common ancestry between\n genome maps.  Fast identification and statistical evaluation of\n segmental homologies in comparative maps. \n .\n Development and maintenance of FISH is supported by funding from the\n National Science Foundation (Plant Genome Research Program Grants\n DBI-0110069 and DBI-0227314 to TJV and DMS-0102008 to PPC).","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1093/bioinformatics/btg1008","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_11724","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"unicycler","distribution":"debian","release":"sid","component":"main","version":"0.4.7","source":"unicycler","homepage":"https://github.com/rrwick/Unicycler","description":"hybrid assembly pipeline for bacterial genomes","long_description":" Unicycler is an assembly pipeline for bacterial genomes. It can assemble\n Illumina-only read sets where it functions as a SPAdes-optimiser. It can\n also assembly long-read-only sets (PacBio or Nanopore) where it runs a\n miniasm+Racon pipeline. For the best possible assemblies, give it both\n Illumina reads and long reads, and it will conduct a hybrid assembly.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 7 / 16","doi":"10.1371/journal.pcbi.1005595","topics":null,"edam_scopes":null,"bio.agents":"Unicycle","OMICagents":"OMICS_14591","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"varmatch","distribution":"prospective","release":"vcs","component":"main","version":"0+git20180126.5c6fed5","source":"varmatch","homepage":"https://github.com/medvedevgroup/varmatch","description":"robust matching of small genomic variant datasets","long_description":" Small variant calling is an important component of many analyses, and, in\n many instances, it is important to determine the set of variants which appear\n in multiple callsets. Variant matching is complicated by variants that have\n multiple equivalent representations. Normalization and decomposition\n algorithms have been proposed, but are not robust to different\n representation of complex variants. The VarMatch algorithm is robust to\n different representation of complex variants and is particularly effective\n in low complexity regions or those dense in variants. VarMatch also provides\n summary statistics, annotations, and visualizations that are useful for\n understanding callers' performance.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1093/bioinformatics/btw797","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_14435","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"varna","distribution":"debian","release":"sid","component":"main","version":"3-93+ds","source":"varna","homepage":"http://varna.lri.fr/","description":"Visualization Applet for RNA","long_description":" VARNA is Java lightweight Applet dedicated to drawing the secondary structure\n of RNA. It is also a Swing component that can be very easily included in an\n existing Java code working with RNA secondary structure to provide a fast and\n interactive visualization.\n .\n Being free of fancy external library dependency and/or network access, the\n VARNA Applet can be used as a base for a standalone applet. It looks\n reasonably good and scales up or down nicely to adapt to the space available\n on a web page, thanks to the anti-aliasing drawing primitives of Swing.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 0 / 56","doi":"http://dx.doi.org/10.1093/bioinformatics/btp250","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_04455","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"varscan","distribution":"debian","release":"sid","component":"non-free","version":"2.4.3","source":"varscan","homepage":"https://dkoboldt.github.io/varscan/","description":"variant detection in next-generation sequencing data","long_description":" Variant detection in massively parallel sequencing. For one sample,\n calls SNPs, indels, and consensus genotypes. For tumor-normal pairs,\n further classifies each variant as Germline, Somatic, or LOH, and also\n detects somatic copy number changes.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"0 / 1 / 9","doi":"10.1101/gr.129684.111","topics":null,"edam_scopes":null,"bio.agents":"varscan","OMICagents":"OMICS_00093","SEQwiki":null,"SciCrunch":{"source":"varscan","name":"SciCrunch","entry":"SCR_006849"},"RRID":null},{"package":"vcfagents","distribution":"debian","release":"sid","component":"main","version":"0.1.16","source":"vcfagents","homepage":"https://vcfagents.github.io/","description":"Collection of agents to work with VCF files","long_description":" VCFagents is a program package designed for working with VCF files, such as\n those generated by the 1000 Genomes Project. The aim of VCFagents is to\n provide methods for working with VCF files: validating, merging, comparing\n and calculate some basic population genetic statistics.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"26 / 6 / 213","doi":"10.1093/bioinformatics/btr330","topics":null,"edam_scopes":null,"bio.agents":"vcfagents","OMICagents":"OMICS_02105","SEQwiki":null,"SciCrunch":{"source":"vcfagents","name":"SciCrunch","entry":"SCR_001235"},"RRID":null},{"package":"vdjagents","distribution":"prospective","release":"vcs","component":"non-free","version":"1.2.1","source":"vdjagents","homepage":"http://maven.apache.org","description":"post-analysis of B/T cell repertoires","long_description":" VDJagents is a complementary software suite that solves a wide range of T\n cell receptor (TCR) repertoires post-analysis tasks, provides a detailed\n tabular output and publication-ready graphics, and is built on top of a\n flexible API. Using TCR datasets for a large cohort of unrelated healthy\n donors, twins, and multiple sclerosis patients we demonstrate that\n VDJagents greatly facilitates the analysis and leads to sound biological\n conclusions.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":"10.1371/journal.pcbi.1004503","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"velvet","distribution":"debian","release":"sid","component":"main","version":"1.2.10","source":"velvet","homepage":"http://www.ebi.ac.uk/~zerbino/velvet/","description":"Nucleic acid sequence assembler for very short reads","long_description":" Velvet is a de novo genomic assembler specially designed for short read\n sequencing technologies, such as Solexa or 454, developed by Daniel Zerbino and\n Ewan Birney at the European Bioinformatics Institute (EMBL-EBI), near\n Cambridge, in the United Kingdom.\n .\n Velvet currently takes in short read sequences, removes errors then produces\n high quality unique contigs. It then uses paired read information, if\n available, to retrieve the repeated areas between contigs.\n","interface":["commandline"],"biology":["nuceleic-acids"],"fields":["biology","biology:bioinformatics"],"use":["analysing"],"popcon":"10 / 3 / 148","doi":"10.1101/gr.074492.107","topics":null,"edam_scopes":null,"bio.agents":"velvet","OMICagents":"OMICS_00038","SEQwiki":null,"SciCrunch":{"source":"velvet","name":"SciCrunch","entry":"SCR_010755"},"RRID":null},{"package":"velvet-long","distribution":"debian","release":"sid","component":"main","version":"1.2.10","source":"velvet","homepage":"http://www.ebi.ac.uk/~zerbino/velvet/","description":"Nucleic acid sequence assembler for very short reads, long version","long_description":" Velvet is a de novo genomic assembler specially designed for short read\n sequencing technologies, such as Solexa or 454, developed by Daniel Zerbino and\n Ewan Birney at the European Bioinformatics Institute (EMBL-EBI), near\n Cambridge, in the United Kingdom.\n .\n Velvet currently takes in short read sequences, removes errors then produces\n high quality unique contigs. It then uses paired read information, if\n available, to retrieve the repeated areas between contigs.\n .\n This package installs special long-mode versions of Velvet, as recommended\n in the Velvet tutorials.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 1 / 12","doi":"10.1101/gr.074492.107","topics":null,"edam_scopes":null,"bio.agents":"velvet","OMICagents":"OMICS_00038","SEQwiki":null,"SciCrunch":{"source":"velvet","name":"SciCrunch","entry":"SCR_010755"},"RRID":null},{"package":"velvetoptimiser","distribution":"debian","release":"sid","component":"main","version":"2.2.6","source":"velvetoptimiser","homepage":"https://github.com/tseemann/VelvetOptimiser/","description":"automatically optimise Velvet do novo assembly parameters","long_description":" VelvetOptimiser is a multi-threaded Perl script for automatically optimising\n the three primary parameter options (K, -exp_cov, -cov_cutoff) for the Velvet\n de novo sequence assembler.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"5 / 3 / 108","doi":null,"topics":null,"edam_scopes":null,"bio.agents":"velvetoptimiser","OMICagents":"OMICS_14601","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"vienna-rna","distribution":"prospective","release":"vcs","component":"non-free","version":"2.4.6","source":"vienna-rna","homepage":"https://www.tbi.univie.ac.at/RNA/","description":"RNA sequence analysis","long_description":" The Vienna RNA Package consists of a C code library and several\n stand-alone programs for the prediction and comparison of RNA secondary\n structures. It is developed and maintained by the group of Ivo Hofacker\n in Vienna.\n .\n RNA secondary structure prediction through energy minimization is the\n most used function in the package. It provides three kinds of dynamic\n programming algorithms for structure prediction:\n  * the minimum free energy algorithm of (Zuker & Stiegler 1981) which\n    yields a single optimal structure, \n  * the partition function algorithm of (McCaskill 1990) which calculates\n    base pair probabilities in the thermodynamic ensemble, and the\n    suboptimal folding algorithm of (Wuchty et.al 1999) which generates\n    all suboptimal structures within a given energy range of the optimal\n    energy.\n .\n For secondary structure comparison, the package contains several\n measures of distance (dissimilarities) using either string alignment or\n tree-editing (Shapiro & Zhang 1990). Finally, is provided an algorithm\n to design sequences with a predefined structure (inverse folding).\n The RNAforester package is a agent for aligning RNA secondary structures\n and it's user interface integrates to those of the agents of the\n Vienna RNA package.","interface":null,"biology":null,"fields":null,"use":null,"popcon":"1 / 0 / 4","doi":"10.1186/1748-7188-6-26","topics":null,"edam_scopes":null,"bio.agents":"vienna_rna_package","OMICagents":"OMICS_09351","SEQwiki":null,"SciCrunch":{"source":"vienna-rna","name":"SciCrunch","entry":"SCR_008550"},"RRID":null},{"package":"viewmol","distribution":"debian","release":"sid","component":"main","version":"2.4.1","source":"viewmol","homepage":"http://viewmol.sourceforge.net/","description":"graphical front end for computational chemistry programs","long_description":" Viewmol is able to graphically aid in the generation of molecular\n structures for computations and to visualize their results.\n .\n At present Viewmol includes input filters for Discover, DMol3, Gamess,\n Gaussian 9x/03, Gulp, Mopac, PQS, Turbomole, and Vamp outputs as well as\n for PDB files. Structures can be saved as Accelrys' car-files, MDL files,\n and Turbomole coordinate files. Viewmol can generate input files for\n Gaussian 9x/03. Viewmol's file format has been added to OpenBabel so that\n OpenBabel can serve as an input as well as an output filter for\n coordinates.\n","interface":["3d","x11"],"biology":null,"fields":["chemistry"],"use":["learning","viewing"],"popcon":"32 / 45 / 505","doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_05057","SEQwiki":null,"SciCrunch":{"source":"viewmol","name":"SciCrunch","entry":"SCR_012088"},"RRID":null},{"package":"vmd","distribution":"prospective","release":"vcs","component":"non-free","version":"1.9.1","source":"vmd","homepage":"http://www.ks.uiuc.edu/Research/vmd/","description":"presentation of traces of molecular dynamics runs","long_description":" VMD stands for Visual Molecular Dynamics. While text books\n and even structure databases because of technical problems only\n present static pictures of proteins or DNA, for the understanding\n of the properties of those molecules their vibration or their\n movement in general is important.\n .\n The movements itself are calculated by molecular dynamics programs,\n such as NAMD (by the same group), Rosetta, BALLView or GROMACS. The\n latter two are already in the distribution, we have package build\n instructions for Rosetta.\n .\n VMD has a series of nice features, from displaying through animation\n to analysing.  It can be scripted, clustered, and runs on all common OS.\n Its license does not allow to redistribute a Debian package. But\n to share these build instructions for such a package is just fine.","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 2 / 13","doi":"10.1016/0263-7855(96)00018-5","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"vsearch","distribution":"debian","release":"sid","component":"main","version":"2.10.4","source":"vsearch","homepage":"https://github.com/torognes/vsearch/","description":"agent for processing metagenomic sequences","long_description":" Versatile 64-bit multithreaded agent for processing metagenomic sequences,\n including searching, clustering, chimera detection, dereplication, sorting,\n masking and shuffling\n .\n The aim of this project is to create an alternative to the USEARCH agent\n developed by Robert C. Edgar (2010). The new agent should:\n .\n  - have a 64-bit design that handles very large databases and much more\n    than 4GB of memory\n  - be as accurate or more accurate than usearch\n  - be as fast or faster than usearch\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"6 / 6 / 72","doi":"https://doi.org/10.7717/peerj.2584","topics":null,"edam_scopes":null,"bio.agents":"vsearch","OMICagents":"OMICS_14601","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"wise","distribution":"debian","release":"sid","component":"main","version":"2.4.1","source":"wise","homepage":"http://www.ebi.ac.uk/~birney/wise2/","description":"comparison of biopolymers, like DNA and protein sequences","long_description":" Wise2 is a package focused on comparisons of biopolymers, commonly DNA\n and protein sequences. There are many other packages which do\n this, probably the best known being BLAST package (from NCBI) and the\n Fasta package (from Bill Pearson). There are other packages, such as\n the HMMER package (Sean Eddy) or SAM package (UC Santa Cruz) focused\n on hidden Markov models (HMMs) of biopolymers.\n .\n Wise2's particular forte is the comparison of DNA sequence at the level\n of its protein translation. This comparison allows the simultaneous\n prediction of say gene structure with homology based alignment.\n .\n Wise2 also contains other algorithms, such as the venerable Smith-Waterman\n algorithm, or more modern ones such as Stephen Altschul's generalised\n gap penalties, or even experimental ones developed in house, such as\n dba. The development of these algorithms is due to the ease of developing\n such algorithms in the environment used by Wise2.\n .\n Wise2 has also been written with an eye for reuse and maintainability.\n Although it is a pure C package you can access its functionality\n directly in Perl. Parts of the package (or the entire package) can\n be used by other C or C++ programs without namespace clashes as all\n externally linked variables have the unique identifier Wise2 prepended.\n","interface":["commandline"],"biology":null,"fields":["biology","biology:bioinformatics"],"use":["comparing"],"popcon":"22 / 28 / 911","doi":"10.1101/gr.1865504","topics":null,"edam_scopes":null,"bio.agents":"Wise","OMICagents":"OMICS_11233","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"yaha","distribution":"debian","release":"sid","component":"main","version":"0.1.83","source":"yaha","homepage":"https://github.com/GregoryFaust/yaha","description":"find split-read mappings on single-end queries","long_description":" yaha is an open source, flexible, sensitive and accurate DNA aligner\n designed for single-end reads. It supports three major modes of\n operation:\n  * The default “Optimal Query Coverage” (-OQC) mode reports the\n    best set of alignments that cover the length of each query.\n  * Using “Filter By Similarity” (-FBS), along with the best set of\n    alignments, yaha will also output alignments that are highly similar\n    to an alignment in the best set.\n  * Finally, yaha can output all the alignments found for each query.\n The -OQC and -FBS modes are specifically tuned to form split read\n mappings that can be used to accurately identify structural variation\n events (deletions, duplications, insertions or inversions) between the\n subject query and the reference genome.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"2 / 7 / 14","doi":"10.1093/bioinformatics/bts456","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_04675","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"zalign","distribution":"debian","release":"sid","component":"main","version":"0.9.1","source":"zalign","homepage":"https://launchpad.net/zalign","description":"parallel local alignment of biological sequences","long_description":" zAlign is a local sequence aligner, especially intended for use with\n large biological DNA sequences, with more than 1Mbp (Millions of base\n pairs). It uses the Smith-Waterman exact algorithm with affine gap cost\n function to perform this task.\n .\n zAlign can be used both in distributed (clusters, for\n example) or standalone environments. Currently it has\n been tested on Linux and Sun Solaris, using both the MPICH\n (http://www.mcs.anl.gov/research/projects/mpi/mpich1/) and OpenMPI\n (http://www.open-mpi.org/) implementations. Ports for other Unix-like\n environments are highly considered.\n","interface":null,"biology":null,"fields":null,"use":null,"popcon":"7 / 2 / 115","doi":"10.1016/j.jpdc.2007.08.007","topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":"OMICS_21299","SEQwiki":null,"SciCrunch":null,"RRID":null},{"package":"zodiac-zeden","distribution":"prospective","release":"vcs","component":"main","version":"0.6.5","source":"zodiac-zeden","homepage":"https://sourceforge.net/projects/zodiac-zeden/","description":"ZODIAC - Zeden's Organise DIsplay And Compute","long_description":" Zodiac is a molecular modelling suite for computation, analysis and display of\n molecular data. It features state-of-the-art agents for managing molecular \n databases, run molecular docking experiments, compute raytraced images \n and much more.","interface":null,"biology":null,"fields":null,"use":null,"popcon":null,"doi":null,"topics":null,"edam_scopes":null,"bio.agents":null,"OMICagents":null,"SEQwiki":null,"SciCrunch":null,"RRID":null}]

